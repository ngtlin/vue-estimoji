(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict"; // Math.sign (used in ProgressFull)

if (!("sign" in Math)) {
  Math.sign = function (x) {
    return x > 0 ? 1 : x < 0 ? -1 : +x;
  };
}

},{}],2:[function(require,module,exports){
"use strict";

if (!String.prototype.startsWith) {
  String.prototype.startsWith = function (searchString, position) {
    position = position || 0;
    return this.indexOf(searchString, position) === position;
  };
}

},{}],3:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _tslib = require("tslib");

require("./polyfills/Math.sign");

require("./polyfills/startsWith");

var sdxExports = _interopRequireWildcard(require("./src/sdx"));

/* Polyfills */
var sdx = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, sdxExports), window.sdx || {}), {
  VERSION: "2.11.2"
});
window.sdx = sdx;
sdxExports.utils.onDocumentReady(function () {
  sdxExports.initInputField();
  sdxExports.initTextarea();
  sdxExports.initSelect();
  sdxExports.initLoaderBar();
  sdxExports.initAutocomplete();
  sdxExports.initProgressLight();
  sdxExports.initProgressFull();
  sdxExports.initRange();
  sdxExports.initModal();
  sdxExports.initAccordion();
  sdxExports.initCollapse();
  sdxExports.initMenuFlyout();
  sdxExports.initNavigation();
  sdxExports.initNavigationSide();
  sdxExports.initSearchInput();
  sdxExports.initEmptyState();
  sdxExports.initCarousel();
  sdxExports.initTable();
  sdxExports.initPieChart();
  sdxExports.initBarChartHorizontal();
  sdxExports.initBarChartVertical();
});

},{"./polyfills/Math.sign":1,"./polyfills/startsWith":2,"./src/sdx":29,"@babel/runtime/helpers/interopRequireWildcard":34,"tslib":43}],4:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var Dom = _interopRequireWildcard(require("./DomFunctions"));

var htmlEvents;
/**
 * A wrapper class for DOM Elements.
 */

var DomElement =
/** @class */
function () {
  /**
   * Creates a new instance.
   * @param {Element} - The element to wrap.
   * @param {String} - The DOM element to create.
   */
  function DomElement(element) {
    if (typeof element === "string") {
      this.element = document.createElement(element);
    } else {
      this.element = element;
    }
  }
  /**
   * Adds the specified CSS class to the element.
   * @param {String} - The class name to add.
   * @return {DomElement} Returns the current instance for fluent chaining of calls.
   */


  DomElement.prototype.addClass = function (name) {
    Dom.addClass(this.element, name);
    return this;
  };
  /**
   * Removes the specified CSS class from the element.
   * @param {String} - The class name to remove.
   * @return {DomElement} Returns the current instance for fluent chaining of calls.
   */


  DomElement.prototype.removeClass = function (name) {
    Dom.removeClass(this.element, name);
    return this;
  };

  DomElement.prototype.hasClass = function (name) {
    return Dom.hasClass(this.element, name);
  };

  DomElement.prototype.toggleClass = function (name) {
    Dom.toggleClass(this.element, name);
    return this;
  };

  Object.defineProperty(DomElement.prototype, "classes", {
    get: function get() {
      return this.element.classList;
    },
    enumerable: false,
    configurable: true
  });

  DomElement.prototype.setId = function (id) {
    this.element.setAttribute("id", id);
    return this;
  };

  Object.defineProperty(DomElement.prototype, "innerText", {
    get: function get() {
      return Dom.text(this.element);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DomElement.prototype, "innerHtml", {
    get: function get() {
      return this.element.innerHTML;
    },
    enumerable: false,
    configurable: true
  });

  DomElement.prototype.setHtml = function (value) {
    if (typeof value !== "string") {
      throw new Error("Expected HTML string");
    }

    this.element.innerHTML = value;
    return this;
  };

  DomElement.prototype.getAttribute = function (name) {
    return this.element.getAttribute(name);
  };

  DomElement.prototype.setAttribute = function (name, value) {
    this.element.setAttribute(name, value);
    return this;
  };
  /**
   * Registers an event listener.
   */


  DomElement.prototype.addEventListener = function (type, listener) {
    this.element.addEventListener(type, listener);
  };
  /**
   * Unregisters an event listener on the component.
   */


  DomElement.prototype.removeEventListener = function (type, listener) {
    this.element.removeEventListener(type, listener);
  };

  DomElement.prototype.appendChild = function (newChild) {
    if (!(newChild instanceof DomElement)) {
      throw new Error("Only other DomElements can be added as children");
    }

    this.element.appendChild(newChild.element);
    return this;
  };

  DomElement.prototype.prependChild = function (newChild) {
    if (!(newChild instanceof DomElement)) {
      throw new Error("Only other DomElements can be added as children");
    }

    this.element.insertBefore(newChild.element, this.element.firstChild);
    return this;
  };

  DomElement.prototype.insertBefore = function (newChild) {
    if (!(newChild instanceof DomElement)) {
      throw new Error("Only other DomElements can be added as children");
    }

    if (!this.element.parentNode) {
      throw new Error("Element is not attached");
    }

    this.element.parentNode.insertBefore(newChild.element, this.element);
    return this;
  };

  DomElement.prototype.insertAfter = function (newChild) {
    if (!(newChild instanceof DomElement)) {
      throw new Error("Only other DomElements can be added as children");
    }

    if (!this.element.parentNode) {
      throw new Error("Element is not attached");
    }

    this.element.parentNode.insertBefore(newChild.element, this.element.nextSibling);
    return this;
  };

  DomElement.prototype.removeChild = function (oldChild) {
    if (!(oldChild instanceof DomElement)) {
      throw new Error("Only a DomElements child can be removed");
    }

    this.element.removeChild(oldChild.element);
  };

  DomElement.prototype.find = function (selectors) {
    var e = this.element.querySelector(selectors);

    if (e) {
      return new DomElement(e);
    }

    return undefined;
  };

  DomElement.prototype.wrapWithElement = function (wrapperElement) {
    if (!this.element.parentNode) {
      throw new Error("Element is not attached");
    }

    this.element.parentNode.replaceChild(wrapperElement.element, this.element);
    wrapperElement.element.appendChild(this.element);
    return this;
  };

  DomElement.prototype.dispatchEvent = function (eventName) {
    var event;
    var el = this.element;

    if (document.createEvent) {
      event = document.createEvent("HTMLEvents");
      event.initEvent(eventName, true, true);
    } else if (document.createEventObject) {
      // IE < 9
      event = document.createEventObject();
      event.eventType = eventName;
    }

    event.eventName = eventName;

    if (el.dispatchEvent) {
      el.dispatchEvent(event);
    } else if (el.fireEvent && htmlEvents["on" + eventName]) {
      // IE < 9
      el.fireEvent("on" + event.eventType, event); // can trigger only real event (e.g. 'click')
    } else if (el[eventName]) {
      el[eventName]();
    } else if (el["on" + eventName]) {
      el["on" + eventName]();
    }
  };

  DomElement.prototype.css = function (property) {
    return Dom.css(this.element, property);
  };
  /**
   * Removes all child nodes of the current DomElement.
   */


  DomElement.prototype.empty = function () {
    Dom.empty(this.element);
  };

  return DomElement;
}();

var _default = DomElement;
exports["default"] = _default;

},{"./DomFunctions":5,"@babel/runtime/helpers/interopRequireWildcard":34}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.hasClass = hasClass;
exports.toggleClass = toggleClass;
exports.isHidden = isHidden;
exports.text = text;
exports.parentWithClass = parentWithClass;
exports.textWidth = textWidth;
exports.css = css;
exports.getAttributeReference = getAttributeReference;
exports.getRootElement = getRootElement;
exports.empty = empty;

function addClass(element, name) {
  if (typeof name !== "string") {
    throw new Error("Expected string class name");
  }

  element.classList.add(name);
}

function removeClass(element, name) {
  if (typeof name !== "string") {
    throw new Error("Expected string class name");
  }

  element.classList.remove(name);
}

function hasClass(element, name) {
  if (typeof name !== "string") {
    throw new Error("Expected string class name");
  }

  return element.classList.contains(name);
}

function toggleClass(element, name) {
  if (typeof name !== "string") {
    throw new Error("Expected string class name");
  }

  element.classList.toggle(name);
}
/**
 * Determines if the given element is hidden from view.
 * @param {Element} Element The dom element to check.
 * @param {boolean} includeParents If set to `true` searches up the DOM and checks parent visibility as well. Defaults to `false`.
 */


function isHidden(element, includeParents) {
  if (includeParents === void 0) {
    includeParents = false;
  }

  if (includeParents === false) {
    var style = window.getComputedStyle(element);
    return style.display === "none" || element.offsetLeft < 0;
  }

  var result; // tslint:disable-next-line:no-conditional-assignment

  while ((result = isHidden(element, false)) === false && element.parentElement) {
    element = element.parentElement;
  }

  return result;
}
/**
 * Gets the text of an element an makes sure this works on all browsers.
 */


function text(element) {
  return element.textContent || element.innerText;
}

function parentWithClass(element, className) {
  var current = element;

  while (!hasClass(current, className) && current.parentElement) {
    current = current.parentElement;
  }

  if (hasClass(current, className)) {
    return current;
  }

  return undefined;
}

function textWidth(text, font) {
  // NOTE: this width measuring algorithm is a lot faster
  // but does unfortunately not work on IE 10...
  // let canvas = document.createElement("canvas")
  // let context = canvas.getContext("2d")
  // context.font = font
  // let metrics = context.measureText(text)
  // return Math.round(metrics.width)
  var div = document.createElement("div");
  div.innerHTML = text;
  div.style.font = font;
  div.style.position = "absolute";
  div.style.visibility = "hidden";
  document.body.appendChild(div);
  var result = div.offsetWidth;
  document.body.removeChild(div);
  return result;
}

function css(element, property) {
  return window.getComputedStyle(element).getPropertyValue(property);
}
/**
 * Gets the single element referenced in an items data-* attribute.
 * @param {DomElement} element - The element containing the reference attribute.
 * @param {string} attribute - The name of the reference attribute.
 * @returns {DomElement} The referenced element; or `undefined` if the reference is invalid
 * or the attribute could not be found.
 */


function getAttributeReference(element, attribute) {
  var attrValue = element.getAttribute(attribute);

  if (!attrValue || attrValue === "") {
    return undefined;
  }

  return document.querySelector(attrValue);
}
/**
 * Gets the document root element (normally the body element)
 * If the document uses a sdx-container wrapper this is returned instead.
 * @returns {Element} The root dom element.
 */


function getRootElement() {
  var element = document.querySelector(".sdx-container");

  if (!element) {
    element = document.body;
  }

  return element;
}
/**
 * Removes all child nodes from the provided element.
 * @param {Element} element The Dom element
 */


function empty(element) {
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
}

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getKeyValue = exports.containsKey = exports.KEY_NR_9 = exports.KEY_NR_1 = exports.KEY_NR_0 = exports.KEY_PAGE_DOWN = exports.KEY_PAGE_UP = exports.KEY_ARROW_RIGHT = exports.KEY_ARROW_LEFT = exports.KEY_ARROW_DOWN = exports.KEY_ARROW_UP = exports.KEY_ESCAPE = exports.KEY_ENTER = exports.KEY_TAB = void 0;

/* Keyboard input keycode definitions */
var KEY_TAB = 9;
exports.KEY_TAB = KEY_TAB;
var KEY_ENTER = 13;
exports.KEY_ENTER = KEY_ENTER;
var KEY_ESCAPE = 27; // Arrow keys

exports.KEY_ESCAPE = KEY_ESCAPE;
var KEY_ARROW_UP = 38;
exports.KEY_ARROW_UP = KEY_ARROW_UP;
var KEY_ARROW_DOWN = 40;
exports.KEY_ARROW_DOWN = KEY_ARROW_DOWN;
var KEY_ARROW_LEFT = 37;
exports.KEY_ARROW_LEFT = KEY_ARROW_LEFT;
var KEY_ARROW_RIGHT = 39; // Page keys

exports.KEY_ARROW_RIGHT = KEY_ARROW_RIGHT;
var KEY_PAGE_UP = 33;
exports.KEY_PAGE_UP = KEY_PAGE_UP;
var KEY_PAGE_DOWN = 34; // Numbers

exports.KEY_PAGE_DOWN = KEY_PAGE_DOWN;
var KEY_NR_0 = 48;
exports.KEY_NR_0 = KEY_NR_0;
var KEY_NR_1 = 49;
exports.KEY_NR_1 = KEY_NR_1;
var KEY_NR_9 = 57; // helper functions

exports.KEY_NR_9 = KEY_NR_9;

var containsKey = function containsKey(keycode, inputsKeys) {
  var hasKey = false;

  if (inputsKeys && inputsKeys.length > 0) {
    [].forEach.call(inputsKeys, function (inputsKey) {
      if (keycode === inputsKey) {
        hasKey = true;
      }
    });
  }

  return hasKey;
};

exports.containsKey = containsKey;

var getKeyValue = function getKeyValue(keycode) {
  if (keycode < 48 || keycode > 105) {
    return "";
  }

  return String.fromCharCode(96 <= keycode && keycode <= 105 ? keycode - 48 : keycode).toLowerCase();
};

exports.getKeyValue = getKeyValue;

},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onDocumentReady = onDocumentReady;
exports.searchAndInitialize = searchAndInitialize;
exports.clamp = clamp;
exports.preventDefault = preventDefault;
exports.remove = remove;
exports.find = find;
exports.internetExplorerOrEdgeVersion = internetExplorerOrEdgeVersion;
exports.scrollIntoView = scrollIntoView;

var _tslib = require("tslib");

/**
 * Calls the callback function when the document has been completely parsed.
 * @param {callback} value The callback function to execute.
 */
function onDocumentReady(callback) {
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed, false);
    window.removeEventListener("load", completed, false);
    callback();
  }

  if (document.readyState === "complete") {
    setTimeout(callback);
  } else {
    document.addEventListener("DOMContentLoaded", completed, false); // A fallback to window.onload, that will always work

    window.addEventListener("load", completed, false);
  }
}

function searchAndInitialize(selector, callback, initSelector) {
  var e_1, _a;

  if (!callback) {
    throw new Error("The callback cannot be undefined");
  }

  var elements = document.querySelectorAll(selector);

  try {
    for (var elements_1 = (0, _tslib.__values)(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
      var e = elements_1_1.value;
      var initElement = e;

      if (initSelector) {
        initElement = initSelector(e);
      }

      if (initElement.getAttribute("data-init") === "auto") {
        callback(e);
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (elements_1_1 && !elements_1_1.done && (_a = elements_1["return"])) _a.call(elements_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
}
/**
 * Returns a number whose value is limited to the given range.
 *
 * Example: limit the output of this computation to between 0 and 255
 * Utils.clamp(number, 0, 255)
 *
 * @param {Number} value The number to clamp
 * @param {Number} min The lower boundary of the output range
 * @param {Number} max The upper boundary of the output range
 * @returns A number in the range [min, max]
 * @type Number
 */


function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
/**
 * A polyfill for Event.preventDefault().
 * @param {Event} event - The event to prevent the default action.
 */


function preventDefault(event) {
  if (event.preventDefault) {
    event.preventDefault();
  } else {
    event.returnValue = false;
  }
}
/**
 * A polyfill for Node.remove().
 * @param {Node} node - The node to remove.
 */


function remove(node) {
  if (!node || !node.parentNode) {
    return;
  }

  node.parentNode.removeChild(node);
}
/**
 * A simple polyfill for the Array.find() method.
 * @param {Array} array - The array to search in.
 * @param {function} expression - The expression to evaluate. Must return true if the element matches.
 */


function find(array, expression) {
  for (var i = 0; i < array.length; i++) {
    var item = array[i];

    if (expression(item) === true) {
      return item;
    }
  }

  return undefined;
}
/**
 * Checks the useragent and returns the Microsoft Internet Explorer / Edge version.
 * If another browser is detected 0 is returned.
 */


function internetExplorerOrEdgeVersion(userAgent) {
  if (userAgent === void 0) {
    userAgent = navigator.userAgent;
  } // handle IE and Edge


  var ieOrEdge = userAgent.search(/MSIE |Edge[/]/);

  if (ieOrEdge > 0) {
    return parseInt(userAgent.substring(ieOrEdge + 5, userAgent.indexOf(".", ieOrEdge)), 10);
  } // handle IE11


  if (userAgent.indexOf("Trident/") > 0) {
    var rv = userAgent.indexOf("rv:");
    return parseInt(userAgent.substring(rv + 3, userAgent.indexOf(".", rv)), 10);
  }

  return 0;
}
/**
 * Tries to move a child element to the top by scrolling the parent element, if it is not already fully visible.
 */


function scrollIntoView(child) {
  var parent = child.parentNode;
  var parentRect = parent.getBoundingClientRect();
  var childRect = child.getBoundingClientRect();
  var isFullyVisible = childRect.top >= parentRect.top && childRect.bottom <= parentRect.top + parent.clientHeight;

  if (!isFullyVisible) {
    parent.scrollTop = childRect.top + parent.scrollTop - parentRect.top;
  }
}

},{"tslib":43}],8:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _Utils = require("../Utils");

var _animejs = _interopRequireDefault(require("animejs"));

var _DomElement = _interopRequireDefault(require("../DomElement"));

var Dom = _interopRequireWildcard(require("../DomFunctions"));

var QUERY_TOGGLE = ".accordion__toggle";
var QUERY_OPEN_SECTION = ".accordion__item.is-open";
var QUERY_COLLAPSE = ".accordion__collapse";
var CLASS_ITEM = "accordion__item";
var CLASS_OPEN = "is-open";
var CLASS_KEEP_OPEN = "accordion__keep-open";
var REGEX_HIDDEN = /accordion--hidden-.*/;
var ANIMATION_OPEN = 300;
/**
 * The Accordion component
 */

var Accordion =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Accordion, _super);
  /**
   * Creates and initializes the Accordion component.
   * @param {DomElement} - The root element of the Accordion component.
   */

  function Accordion(element) {
    var _this = _super.call(this, element) || this;

    _this._sectionClickHandler = _this._handleSectionClick.bind(_this);

    _this._initialize();

    return _this;
  }
  /**
   * Initializes the Accordion component.
   * @private
   */


  Accordion.prototype._initialize = function () {
    var e_1, _a;

    if (this.element.className.split(" ").some(function (c) {
      return REGEX_HIDDEN.test(c);
    })) {
      var indicator = new _DomElement["default"]("input").setAttribute("type", "hidden").addClass("js-hidden");
      this.appendChild(indicator);
      this._hiddenIndicator = indicator.element;
    }

    try {
      for (var _b = (0, _tslib.__values)(this.element.querySelectorAll(QUERY_TOGGLE)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var toggle = _c.value;
        toggle.addEventListener("click", this._sectionClickHandler);
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  };

  Accordion.prototype._handleSectionClick = function (event) {
    if (this._hiddenIndicator) {
      var style = window.getComputedStyle(this._hiddenIndicator);

      if (style.visibility !== "visible") {
        return;
      }
    }

    var navSection = event.target.parentElement;

    while (!Dom.hasClass(navSection, CLASS_ITEM) && navSection.parentElement) {
      navSection = navSection.parentElement;
    }

    var prevSection = this.element.querySelector(QUERY_OPEN_SECTION);

    if (prevSection && prevSection !== navSection) {
      if (!Dom.hasClass(this.element, CLASS_KEEP_OPEN)) {
        this._toggleSection(prevSection);
      }
    }

    this._toggleSection(navSection);
  };

  Accordion.prototype._toggleSection = function (accSection) {
    var collapseElement = accSection.querySelector(QUERY_COLLAPSE);

    if (Dom.hasClass(accSection, CLASS_OPEN)) {
      Dom.removeClass(accSection, CLASS_OPEN);

      this._closeCollapseSection(collapseElement);
    } else {
      Dom.addClass(accSection, CLASS_OPEN);

      if (collapseElement) {
        // to ignore the case when there is no collapsible element (see sdx doku navigation, "all the basics") in a list of accordion
        this._openCollapseSection(collapseElement);
      }
    }
  };

  Accordion.prototype._openCollapseSection = function (el) {
    el.style.display = "block";
    (0, _animejs["default"])({
      targets: el,
      duration: ANIMATION_OPEN,
      height: el.scrollHeight,
      opacity: 1,
      easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
      complete: function complete() {
        el.setAttribute("aria-expanded", "true");
        el.classList.add(CLASS_OPEN);
        el.style.height = "auto"; // allow to grow or shrink with content
      }
    });
  };

  Accordion.prototype._closeCollapseSection = function (el) {
    // Can't animate "auto", therefore update to current height
    el.style.height = el.scrollHeight + "px";
    (0, _animejs["default"])({
      targets: el,
      duration: ANIMATION_OPEN,
      height: 0,
      opacity: 0,
      easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
      complete: function complete() {
        el.setAttribute("aria-expanded", "false");
        el.style.removeProperty("display"); // removes extra padding in Footer after opening and closing

        el.style.removeProperty("height"); // SDX-691 Missing items in Footer after resizing

        el.style.removeProperty("opacity"); // SDX-691 Missing items in Footer after resizing

        el.classList.remove(CLASS_OPEN);
      }
    });
  };
  /**
   * Removes all event handlers and clears references.
   */


  Accordion.prototype.destroy = function () {
    var e_2, _a;

    try {
      for (var _b = (0, _tslib.__values)(this.element.querySelectorAll(QUERY_TOGGLE)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var toggle = _c.value;
        toggle.removeEventListener("click", this._sectionClickHandler);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    this._sectionClickHandler = null;
    this.element = null;
  };

  return Accordion;
}(_DomElement["default"]);

function init() {
  (0, _Utils.searchAndInitialize)(".accordion", function (e) {
    new Accordion(e);
  });
}

var _default = Accordion;
exports["default"] = _default;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"@babel/runtime/helpers/interopRequireWildcard":34,"animejs":36,"tslib":43}],9:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _Utils = require("../Utils");

var _DomElement = _interopRequireDefault(require("../DomElement"));

var Inputs = _interopRequireWildcard(require("../Inputs"));

var Dom = _interopRequireWildcard(require("../DomFunctions"));

var QUERY_SLIDER = ".carousel__container";
var QUERY_SLIDE_AREA = ".carousel__slider";
var QUERY_WRAPPER = ".carousel__slider-wrapper";
var QUERY_PAGINATION = ".carousel__pagination";
var CLASS_ACTIVE = "slide--active";
var CLASS_PREV = "slide--prev";
var CLASS_NEXT = "slide--next";
var CLASS_BULLET = "pagination-bullet";
var CLASS_BULLET_ACTIVE = "pagination-bullet--active";
var QUERY_BTN_PREV = ".carousel__button-prev";
var QUERY_BTN_NEXT = ".carousel__button-next";
var QUERY_BTN_WRAPPER = ".carousel__button-wrapper";
var ATTRIBUTE_INDEX = "js-index";
var ANIMATION_DURATION = 350;
var ANIMATION_EASING = "ease-in-out";
var TOUCH_DURATION = 300;
var TOUCH_DELTA_MIN = 25;
/**
 * The carousel component definition.
 */

var Carousel =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Carousel, _super);
  /**
   * Creates and initializes the carousel component.
   * @param {DomElement} element - The root element of the Carousel component.
   * @param {Number} index - The initial index.
   */

  function Carousel(element, index) {
    if (index === void 0) {
      index = 0;
    }

    var _this = _super.call(this, element) || this;

    _this._slider = _this.element.querySelector(QUERY_SLIDER);
    _this._wrapper = _this._slider.querySelector(QUERY_WRAPPER);
    _this._pagination = _this._slider.querySelector(QUERY_PAGINATION);
    _this._slideArea = _this._slider.querySelector(QUERY_SLIDE_AREA);
    _this._btnWrapper = _this.element.querySelector(QUERY_BTN_WRAPPER);
    _this._prevCtrl = _this.element.querySelector(QUERY_BTN_PREV);
    _this._nextCtrl = _this.element.querySelector(QUERY_BTN_NEXT);
    _this._slides = [];
    _this._index = index || 0;
    _this._slidesPerGroup = 1;
    _this._sliderWrapper = new SliderWrapper(_this._wrapper, _this._slideArea, _this.element);
    _this._sliderWrapper.index = _this._index;
    _this._additionalSlideMargin = 0;
    _this._resizeHandler = _this._onresize.bind(_this);
    _this._prevHandler = _this.prev.bind(_this);
    _this._nextHandler = _this.next.bind(_this);
    _this._paginationClickHandler = _this._handlePaginationClick.bind(_this);
    _this._keydownHandler = _this._handleKeydown.bind(_this);
    _this._handleTouchstart = _this._onTouchstart.bind(_this);
    _this._handleTouchmove = _this._onTouchmove.bind(_this);
    _this._handleTouchend = _this._onTouchend.bind(_this);

    _this._initialize();

    _this.slide(_this._index, 0, false);

    _this._updateCtrlOffsets();

    return _this;
  }
  /**
   * Initializes the carousel component.
   * @private
   */


  Carousel.prototype._initialize = function () {
    // responsive helpers
    this._breakpointPhone = new _DomElement["default"]("div").addClass("js-phone").element;
    this._breakpointTablet = new _DomElement["default"]("div").addClass("js-tablet").element;
    this._breakpointDesktop = new _DomElement["default"]("div").addClass("js-desktop").element;
    this.element.appendChild(this._breakpointPhone);
    this.element.appendChild(this._breakpointTablet);
    this.element.appendChild(this._breakpointDesktop);

    if (this._prevCtrl && this._nextCtrl) {
      this._prevCtrl.addEventListener("click", this._prevHandler);

      this._nextCtrl.addEventListener("click", this._nextHandler);
    }

    if (this._pagination) {
      this._pagination.addEventListener("click", this._paginationClickHandler);
    }

    this._slides = Array.from(this._wrapper.children);

    if (this._slides.length === 0) {
      throw Error("Provide at least one slide to the slider");
    }

    for (var i = 0; i < this._slides.length; i++) {
      var slide = this._slides[i];
      slide.setAttribute(ATTRIBUTE_INDEX, String(i));
    }

    this._updateResponsiveOptions();

    this._sliderWrapper.initialize();

    this.reset();
    this.element.addEventListener("keydown", this._keydownHandler);

    this._slideArea.addEventListener("mousedown", this._handleTouchstart);

    this._slideArea.addEventListener("touchstart", this._handleTouchstart);

    window.addEventListener("resize", this._resizeHandler);
    window.addEventListener("orientationchange", this._resizeHandler);
  };

  Carousel.prototype._isBreakpointActive = function (breakpoint) {
    var style = window.getComputedStyle(breakpoint);
    return style.visibility === "visible";
  };

  Carousel.prototype._onresize = function () {
    this.reset();

    this._updateCtrlOffsets();
  };
  /**
   * Makes sure the index is always in the range of available slide
   * In case it's to high or to low it is wrapped around
   * @param {Number} index - The index to adjust and sanitize
   * @returns {Number} index - The adjusted index
   * @private
   */


  Carousel.prototype._adjustIndex = function (index) {
    if (typeof index !== "number") {
      index = 0;
    }

    if (index < 0) {
      index = this._wrapround(index, 0, this._slides.length);
    } else if (index >= this._slides.length) {
      index %= this._slides.length;
    }

    return Math.floor(index / this._slidesPerGroup) * this._slidesPerGroup;
  };

  Carousel.prototype._wrapround = function (n, min, max) {
    if (n >= max) {
      return min;
    }

    if (n < min) {
      return max - 1;
    }

    return n;
  };

  Carousel.prototype._wraproundCount = function (a, b, min, max, direction) {
    if (direction === 0) {
      return 0;
    }

    if (a < min || a >= max) {
      throw new Error("Argument 'a' is out of range, Value: " + a + " Min: " + min + ", Max: " + max);
    }

    if (b < min || b >= max) {
      throw new Error("Argument 'b' is out of range, Value: " + b + " Min: " + min + ", Max: " + max);
    }

    var i = 0;

    while (a !== b) {
      i++;
      a = this._wrapround(a + direction, min, max);
    }

    return i;
  };

  Carousel.prototype._updateCtrlOffsets = function () {
    if (!this._nextCtrl || !this._prevCtrl || !this._btnWrapper) {
      return;
    }

    var prevCtrlMargin = 0;
    var nextCtrlMargin = 0;

    if (this._slidesPerGroup > 1) {
      var wrapperRect = this._btnWrapper.getBoundingClientRect();

      var prevSlideCount = Math.floor(0.5 * this._slidesPerGroup);
      var rightIndex = this._sliderWrapper.index + prevSlideCount + 1;
      var leftIndex = this._sliderWrapper.index - 1;

      if (this._slidesPerGroup % 2 !== 0) {
        leftIndex -= prevSlideCount;
      }

      if (leftIndex >= 0 && leftIndex < this._wrapper.children.length && rightIndex >= 0 && rightIndex < this._wrapper.children.length) {
        var leftSlide = this._sliderWrapper.getSlideProperties(leftIndex);

        var rightSlide = this._sliderWrapper.getSlideProperties(rightIndex);

        var btnWidth = this._prevCtrl.offsetWidth;

        if (btnWidth <= 0) {
          btnWidth = 60;
        }

        prevCtrlMargin = leftSlide.right - wrapperRect.left - btnWidth;
        nextCtrlMargin = wrapperRect.right - rightSlide.left - btnWidth;
      }
    }

    var left = prevCtrlMargin !== 0 ? prevCtrlMargin + "px" : "";
    this._prevCtrl.style.left = left;
    var right = nextCtrlMargin !== 0 ? nextCtrlMargin + "px" : "";
    this._nextCtrl.style.right = right;
  };

  Carousel.prototype._updateActiveSlides = function (nextIndex) {
    var prevSlideCount = Math.floor(0.5 * (this._slidesPerGroup - 1));
    var evenGroup = this._slidesPerGroup % 2 === 0;

    for (var i = 0; i < this._wrapper.children.length; i++) {
      var slide = this._wrapper.children[i];

      if (i === nextIndex || evenGroup && i === nextIndex + 1) {
        Dom.addClass(slide, CLASS_ACTIVE);
      } else {
        Dom.removeClass(slide, CLASS_ACTIVE);
      }

      if (i < nextIndex && i >= nextIndex - prevSlideCount) {
        Dom.addClass(slide, CLASS_PREV);
      } else {
        Dom.removeClass(slide, CLASS_PREV);
      }

      if (i > nextIndex && (i <= nextIndex + prevSlideCount || evenGroup && i <= nextIndex + 1 + prevSlideCount)) {
        Dom.addClass(slide, CLASS_NEXT);
      } else {
        Dom.removeClass(slide, CLASS_NEXT);
      }
    }
  };
  /**
   * Updates and creates the pagination bullets.
   * @private
   */


  Carousel.prototype._updatePagination = function () {
    if (!this._pagination) {
      return;
    }

    var to = this._index;
    var bullets = this._pagination.children;
    var totalItems = Math.max(this._slides.length, bullets.length);
    var slideCount = Math.ceil(this._slides.length / this._slidesPerGroup);
    var activeSlideIndex = Math.floor(to / this._slidesPerGroup);

    for (var i = 0; i < totalItems; i++) {
      var bullet = void 0;

      if (bullets.length > i) {
        if (bullets.length <= slideCount) {
          bullet = bullets[i];
        } else {
          (0, _Utils.remove)(bullets[i]);
        }
      } else if (i < slideCount) {
        bullet = new _DomElement["default"]("div").addClass(CLASS_BULLET).element;

        this._pagination.appendChild(bullet);
      }

      if (bullet && i < slideCount) {
        if (i === activeSlideIndex) {
          Dom.addClass(bullet, CLASS_BULLET_ACTIVE);
        } else {
          Dom.removeClass(bullet, CLASS_BULLET_ACTIVE);
        }
      }
    }
  };

  Carousel.prototype._handlePaginationClick = function (e) {
    if (!Dom.hasClass(e.target, CLASS_BULLET)) {
      return;
    }

    var index = Array.from(this._pagination.children).indexOf(e.target);
    var slideNumber = index * this._slidesPerGroup;
    this.slideTo(slideNumber);
  };

  Carousel.prototype._handleKeydown = function (event) {
    var keycode = event.which || event.keyCode;

    switch (keycode) {
      case Inputs.KEY_ARROW_LEFT:
        this.prev();
        break;

      case Inputs.KEY_ARROW_RIGHT:
        this.next();
        break;

      case Inputs.KEY_ESCAPE:
        this.element.blur();
        break;

      default:
    }
  };

  Carousel.prototype._onTouchstart = function (event) {
    var touch = event.touches ? event.touches[0] : event;

    this._slideArea.removeEventListener("mousedown", this._handleTouchstart);

    this._slideArea.removeEventListener("touchstart", this._handleTouchstart);

    this._sliderWrapper.beginDrag();

    var pageX = touch.pageX;
    this._touchOffset = {
      x: pageX,
      time: Date.now()
    };
    this._delta = {
      x: 0,
      lastMove: pageX
    };
    document.addEventListener("mousemove", this._handleTouchmove);
    document.addEventListener("touchmove", this._handleTouchmove);
    document.addEventListener("mouseup", this._handleTouchend);
    document.addEventListener("mouseleave", this._handleTouchend);
    document.addEventListener("touchend", this._handleTouchend);
  };

  Carousel.prototype._onTouchmove = function (event) {
    var touch = event.touches ? event.touches[0] : event;
    var pageX = touch.pageX;
    var deltaMove = pageX - this._delta.lastMove;
    this._delta = {
      x: pageX - this._touchOffset.x,
      lastMove: pageX
    };

    if (this._touchOffset) {
      (0, _Utils.preventDefault)(event);

      this._sliderWrapper.move(deltaMove);

      this._cloneSlidesToFitWrapper(false, deltaMove);
    }
  };

  Carousel.prototype._onTouchend = function () {
    var duration = this._touchOffset ? Date.now() - this._touchOffset.time : undefined;
    var isValid = Number(duration) < TOUCH_DURATION && Math.abs(this._delta.x) > TOUCH_DELTA_MIN || Math.abs(this._delta.x) > this._frameWidth / 3;

    if (isValid) {
      var direction = (0, _Utils.clamp)(this._delta.x, -1, 1) * -1;
      this.slide(false, direction, true);

      this._sliderWrapper.endDrag();
    } else {
      // Slide back to the starting point of the drag operation
      this._sliderWrapper.cancelDrag();
    }

    this._touchOffset = undefined;

    this._slideArea.addEventListener("mousedown", this._handleTouchstart);

    this._slideArea.addEventListener("touchstart", this._handleTouchstart);

    document.removeEventListener("mousemove", this._handleTouchmove);
    document.removeEventListener("mouseup", this._handleTouchend);
    document.removeEventListener("mouseleave", this._handleTouchend);
    document.removeEventListener("touchmove", this._handleTouchmove);
    document.removeEventListener("touchend", this._handleTouchend);
  };
  /**
   * Updated parameters in regard to the currently active responsive
   * breakpoint.
   * @private
   */


  Carousel.prototype._updateResponsiveOptions = function () {
    if (this._isBreakpointActive(this._breakpointPhone)) {
      this._slidesPerGroup = 1;
    }

    if (this._isBreakpointActive(this._breakpointTablet)) {
      this._slidesPerGroup = 2;
    }

    if (this._isBreakpointActive(this._breakpointDesktop)) {
      this._slidesPerGroup = 3;
    }

    this._sliderWrapper.slidesPerGroup = this._slidesPerGroup;
  };
  /**
   * Clones the requested slide and adds it to the slider.
   * @param {Number} index - The original slide index of the template slide
   * @param {Number} direction - The direction in which to add the slides, -1 for left, 1 for right
   * @private
   */


  Carousel.prototype._cloneSlide = function (index, direction) {
    var clone = this._slides[index].cloneNode(true);

    Dom.removeClass(clone, CLASS_ACTIVE);
    Dom.removeClass(clone, CLASS_PREV);
    Dom.removeClass(clone, CLASS_NEXT);

    this._sliderWrapper.addSlide(clone, direction);

    var slideMargin = this._additionalSlideMargin > 0 ? this._additionalSlideMargin + "px" : "";
    clone.style.marginLeft = slideMargin;
    clone.style.marginRight = slideMargin;
    return clone.offsetWidth;
  };
  /**
   * Clones and adds the requested ammount of slides.
   * @param {Number} slideCount - The number of slides to add
   * @param {Number} direction - The direction in which to add the slides, -1 for left, 1 for right
   * @private
   */


  Carousel.prototype._cloneSlidesByCount = function (slideCount, direction) {
    var originalIndex = direction < 0 ? 0 : this._wrapper.children.length - 1;
    var index = parseInt(this._wrapper.children[originalIndex].getAttribute(ATTRIBUTE_INDEX), 10);

    while (slideCount > 0) {
      index = this._wrapround(index + direction, 0, this._slides.length);

      this._cloneSlide(index, direction);

      slideCount--;
    }
  };
  /**
   * Calculates the scroll clount and inserts the required ammount of slides
   * in the apropriate direction.
   * @param {Number} nextIndex - The slide to scroll to
   * @param {Number} direction - The direction of the scroll
   * @private
   */


  Carousel.prototype._cloneSlidesByScrollCount = function (nextIndex, direction) {
    var scrollCount = this._wraproundCount(this._index, nextIndex, 0, this._slides.length, direction);

    var outerSlideProps = this._sliderWrapper.getSlideProperties(direction > 0 ? this._wrapper.children.length - 1 : 0);

    var indexToOuterSlideCount = this._wraproundCount(this._index, outerSlideProps.index, 0, this._slides.length, direction);

    var slidesToInsert = scrollCount - indexToOuterSlideCount;

    if (slidesToInsert > 0) {
      this._cloneSlidesByCount(slidesToInsert, direction);
    }
  };

  Carousel.prototype._cloneSlidesByToFill = function (spaceToFill, direction) {
    var originalIndex = direction < 0 ? 0 : this._wrapper.children.length - 1;
    var index = parseInt(this._wrapper.children[originalIndex].getAttribute(ATTRIBUTE_INDEX), 10);

    while (spaceToFill > 0) {
      index = this._wrapround(index + direction, 0, this._slides.length);
      spaceToFill -= this._cloneSlide(index, direction);
    }
  };

  Carousel.prototype._cloneSlidesToFitWrapper = function (cleanup, slideDelta) {
    if (cleanup === void 0) {
      cleanup = true;
    }

    if (slideDelta === void 0) {
      slideDelta = 0;
    }

    var realIndex = this._sliderWrapper.index;
    var first;
    var last;

    if (cleanup === false) {
      first = this._sliderWrapper.getSlideProperties(0);
      last = this._sliderWrapper.getSlideProperties(this._wrapper.children.length - 1);
    } else {
      var result = this._sliderWrapper.getRemovableSlides(slideDelta);

      first = result.first;
      last = result.last; // Remove the slides from view

      for (var i = result.slides.length - 1; i >= 0; i--) {
        if (result.slides[i] === true) {
          this._sliderWrapper.removeSlide(i);
        }
      }
    }

    var spaceToFill = this._sliderWrapper.getEmptySpace(first.left, last.right); // Check if additional slides are required on the left


    if (first.visible === true && spaceToFill.left > 0) {
      this._cloneSlidesByToFill(spaceToFill.left, -1);
    } // Check if additional slides are required on the right


    if (last.visible === true && spaceToFill.right > 0) {
      this._cloneSlidesByToFill(spaceToFill.right, 1);
    }

    return realIndex - this._sliderWrapper.index;
  };
  /**
   * Gets the real (wrapper) index for the slide with the given original index
   * @param {Number} index - The index to search for
   * @param {Number} direction - The direction in which to search
   * @returns {Number} The wrapper index
   * @private
   */


  Carousel.prototype._getRealIndexFor = function (index, direction) {
    var i = this._sliderWrapper.index;

    while (i >= 0 && i < this._wrapper.children.length) {
      var slideIndex = parseInt(this._wrapper.children[i].getAttribute(ATTRIBUTE_INDEX), 10);

      if (slideIndex === index) {
        return i;
      }

      i += direction;
    }

    throw new Error("Cloud not find real index for slide " + index + " in direction " + direction);
  };

  Object.defineProperty(Carousel.prototype, "index", {
    /**
     * Gets the index of the current active slide. If the slides are grouped evenly
     * the active slide is always the first in the group.
     * @returns {Number} The index of the active slide.
     */
    get: function get() {
      return this._index;
    },
    enumerable: false,
    configurable: true
  });

  Carousel.prototype.reset = function () {
    this._frameWidth = this._slider.getBoundingClientRect().width || this._slider.offsetWidth;

    this._updateResponsiveOptions();

    if (this._nextCtrl) {
      this._nextCtrl.disabled = false;
    }

    if (this._prevCtrl) {
      this._prevCtrl.disabled = false;
    }

    if (this._slidesPerGroup === 1) {
      var style = window.getComputedStyle(this._slider.parentElement);
      var parentWidth = this._slider.parentElement.clientWidth + (parseFloat(style.marginLeft) || 0) + (parseFloat(style.marginRight) || 0);
      var outerMargin = Math.ceil(parentWidth - this._frameWidth);
      this._additionalSlideMargin = Math.ceil(outerMargin * 0.5) + 1;
    } else {
      this._additionalSlideMargin = 0;
    }

    var slideMargin = this._additionalSlideMargin > 0 ? this._additionalSlideMargin + "px" : "";

    for (var i = 0; i < this._wrapper.children.length; i++) {
      var slide = this._wrapper.children[i];
      slide.style.marginLeft = slideMargin;
      slide.style.marginRight = slideMargin;
    }

    this._sliderWrapper.onresize();

    this._cloneSlidesToFitWrapper(false);

    this._sliderWrapper.moveTo(this._sliderWrapper.index);

    this._updatePagination();

    this._updateActiveSlides(this._sliderWrapper.index);
  };
  /**
   * Moves the slider to the next item.
   */


  Carousel.prototype.prev = function () {
    this.slide(false, -1);
  };
  /**
   * Moves the slider to the previous item.
   */


  Carousel.prototype.next = function () {
    this.slide(false, 1);
  };

  Carousel.prototype.slide = function (nextIndex, direction, animate) {
    if (animate === void 0) {
      animate = true;
    }

    if (typeof nextIndex !== "number") {
      if (direction > 0) {
        nextIndex = this._index + this._slidesPerGroup;
        direction = 1;
      } else {
        nextIndex = this._index - this._slidesPerGroup;
        direction = -1;
      }
    }

    nextIndex = this._adjustIndex(nextIndex);

    if (!direction) {
      direction = (0, _Utils.clamp)(nextIndex - this._index, -1, 1);
    } // Make sure there are enought slides on screen


    this._cloneSlidesToFitWrapper(false); // Make sure there are enough slides for the scroll operation


    this._cloneSlidesByScrollCount(nextIndex, direction);

    var realIndex = this._getRealIndexFor(nextIndex, direction);

    var slideDelta = this._sliderWrapper.getSlideDelta(realIndex);

    realIndex = Math.max(realIndex - this._cloneSlidesToFitWrapper(true, slideDelta), 0);

    this._sliderWrapper.moveTo(realIndex, undefined, animate); // Update the active index


    this._index = nextIndex; // Mark slides as active

    this._updatePagination();

    this._updateActiveSlides(realIndex); // console.log(`Performed slide to ${this._index}, realIndex: ${this._sliderWrapper.index}`)

  };
  /**
   * Moves the slider to the selected slide.
   * @param {Number} index - The index of the slide to slide to.
   * @param {Boolean} animate - `True` if the slide should be animated; otherwise `false`. Defaults to `true`.
   */


  Carousel.prototype.slideTo = function (index, animate) {
    if (animate === void 0) {
      animate = true;
    }

    this.slide(index, undefined, animate);
  };
  /**
   * Destroys the components and frees all references.
   */


  Carousel.prototype.destroy = function () {
    window.removeEventListener("resize", this._resizeHandler);
    window.removeEventListener("orientationchange", this._resizeHandler);
    this.element.removeEventListener("keydown", this._keydownHandler);

    this._slideArea.removeEventListener("mousedown", this._handleTouchstart);

    this._slideArea.removeEventListener("touchstart", this._handleTouchstart);

    this._breakpointPhone.remove();

    this._breakpointTablet.remove();

    this._breakpointDesktop.remove();

    if (this._prevCtrl && this._nextCtrl) {
      this._prevCtrl.removeEventListener("click", this._prevHandler);

      this._nextCtrl.removeEventListener("click", this._nextHandler);
    }

    this._prevCtrl = undefined;
    this._nextCtrl = undefined;

    if (this._pagination) {
      this._pagination.removeEventListener("click", this._paginationClickHandler);

      this._pagination = undefined;
    }

    this._sliderWrapper.destroy();

    this._sliderWrapper = undefined;
  };

  return Carousel;
}(_DomElement["default"]);

var TRANSFORM = "transform";
var DURATION = "transitionDuration";
var TIMING = "transitionTimingFunction";

var SliderWrapper =
/** @class */
function () {
  function SliderWrapper(wrapperElement, slideAreaElement, carouselElement) {
    this._wrapperElement = wrapperElement;
    this._slideAreaElement = slideAreaElement;
    this._carouselElement = carouselElement;
    this._position = 0;
    this._index = 0;
    this._isdragging = false;
  }

  SliderWrapper.prototype._getSlide = function (index) {
    if (index < 0 || index >= this._wrapperElement.children.length) {
      throw new Error("Argument 'index' is out of range, Value: " + index + " Min: 0, Max: " + (this._wrapperElement.children.length - 1));
    }

    return this._wrapperElement.children[index];
  };

  SliderWrapper.prototype._setTransform = function (targetPosition, animated, duration, ease) {
    if (animated === void 0) {
      animated = false;
    }

    if (duration === void 0) {
      duration = ANIMATION_DURATION;
    }

    if (ease === void 0) {
      ease = ANIMATION_EASING;
    }

    if (animated === false) {
      duration = 0;
    }

    var style = this._wrapperElement.style;

    if (style) {
      style[DURATION] = duration + "ms";
      style[TIMING] = ease; // No sub pixel transitions.

      targetPosition = Math.floor(targetPosition);
      style[TRANSFORM] = "translate(" + targetPosition + "px, 0)";
      this._position = targetPosition;
    }
  };

  SliderWrapper.prototype._getWrapperSlidePosition = function (index) {
    var wrapperCenter = 0.5 * this._wrapperElement.offsetWidth;

    var slide = this._getSlide(index);

    var result = 0; // Calculate the position of the slide (centered)

    if (this._slidesPerGroup % 2 === 0) {
      var slideStyle = window.getComputedStyle(slide);
      var slideMargin = slideStyle ? parseInt(slideStyle.marginRight, 10) : 0; // Centered to the space between the two center slides of the group

      result = -slide.offsetLeft - slide.clientWidth + wrapperCenter - slideMargin;
    } else {
      result = -slide.offsetLeft - 0.5 * slide.clientWidth + wrapperCenter;
    }

    return result;
  };

  Object.defineProperty(SliderWrapper.prototype, "position", {
    get: function get() {
      return this._position;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SliderWrapper.prototype, "index", {
    get: function get() {
      return this._index;
    },
    set: function set(index) {
      this._index = index;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SliderWrapper.prototype, "slidesPerGroup", {
    set: function set(value) {
      this._slidesPerGroup = value;
    },
    enumerable: false,
    configurable: true
  });

  SliderWrapper.prototype.initialize = function () {
    this.onresize();
  };

  SliderWrapper.prototype.onresize = function () {
    // update the area offset for slide position calculation
    this._areaOffset = this._slideAreaElement.getBoundingClientRect().left; // Get the container dimensions

    var containerRect = this._carouselElement.getBoundingClientRect();

    this._containerMin = containerRect.left;
    this._containerMax = containerRect.right;
  };

  SliderWrapper.prototype.beginDrag = function () {
    this._isdragging = true;
    this._dragStartPosition = this._position;
  };

  SliderWrapper.prototype.cancelDrag = function () {
    this._isdragging = false;

    this._setTransform(this._dragStartPosition, true, ANIMATION_DURATION, ANIMATION_EASING);

    this._dragStartPosition = undefined;
  };

  SliderWrapper.prototype.endDrag = function () {
    this._isdragging = false;
    this._dragStartPosition = undefined;
  };

  SliderWrapper.prototype.move = function (delta, animated, duration, ease) {
    if (animated === void 0) {
      animated = false;
    }

    if (duration === void 0) {
      duration = ANIMATION_DURATION;
    }

    if (ease === void 0) {
      ease = ANIMATION_EASING;
    }

    delta = Math.trunc(delta);

    if (Math.abs(delta) <= 0) {
      return;
    }

    var targetPosition = this._position += delta;

    this._setTransform(targetPosition, animated, duration, ease);
  };

  SliderWrapper.prototype.moveTo = function (index, delta, animated) {
    if (animated === void 0) {
      animated = false;
    }

    var newPosition = 0;

    if (!delta) {
      newPosition = this._getWrapperSlidePosition(index);
    } else {
      newPosition = this._position += delta;
    }

    this._index = index;

    this._setTransform(newPosition, animated);
  };

  SliderWrapper.prototype.addSlide = function (slide, position) {
    if (!slide) {
      throw new Error("Cannot add an undefined slide");
    }

    if (position !== -1 && position !== 1) {
      throw new Error("Argument out of range, 'position' must be either 1 or -1. Value " + position);
    }

    if (position > 0) {
      this._wrapperElement.appendChild(slide);
    } else {
      this._wrapperElement.insertBefore(slide, this._wrapperElement.children[0]);

      this._index++;
    }

    if (position < 0) {
      var width = slide.offsetWidth;
      var style = window.getComputedStyle(slide);
      var marginLeft = style ? parseInt(style.marginLeft, 10) : 0;
      var marginRight = style ? parseInt(style.marginRight, 10) : 0;
      this.move(-(width + marginLeft + marginRight));
    }
  };

  SliderWrapper.prototype.removeSlide = function (index) {
    var slide = this._getSlide(index);

    var width = slide.offsetWidth;

    if (index <= this._index) {
      width *= -1;
      this._index--;
    }

    (0, _Utils.remove)(slide);

    if (width < 0) {
      this.move(-width);
    }
  };

  SliderWrapper.prototype.getSlideDelta = function (index) {
    var currentPosition = this._position;

    if (this._isdragging === true) {
      currentPosition = this._dragStartPosition - this._position;
    }

    var newPosition = this._getWrapperSlidePosition(index);

    return newPosition - currentPosition;
  };

  SliderWrapper.prototype.getSlideProperties = function (index, delta) {
    if (delta === void 0) {
      delta = 0;
    }

    var currentOffset = this._areaOffset + this._position + delta;
    var currentLeft = currentOffset;
    var currentRight = currentOffset;

    var _a = (0, _tslib.__read)([0, 0], 2),
        currentMarginLeft = _a[0],
        currentMarginRight = _a[1];

    var slide = this._getSlide(index);

    var slideIndex = parseInt(slide.getAttribute(ATTRIBUTE_INDEX), 10);

    for (var i = 0; i <= index; i++) {
      slide = this._getSlide(i);
      var slideStyle = window.getComputedStyle(slide);
      currentMarginLeft = parseInt(slideStyle.marginLeft, 10);
      currentMarginRight = parseInt(slideStyle.marginRight, 10);
      currentOffset += currentMarginLeft;
      currentLeft = currentOffset;
      currentRight = currentLeft + slide.offsetWidth;

      if (i < index) {
        currentOffset = currentRight + currentMarginRight;
      }
    }

    var visible = false;

    if (currentLeft > this._containerMin && currentLeft < this._containerMax || currentRight > this._containerMin && currentRight < this._containerMax) {
      visible = true;
    }

    return {
      visible: visible,
      index: slideIndex,
      left: currentLeft,
      right: currentRight,
      width: currentRight - currentLeft,
      marginLeft: currentMarginLeft,
      marginRight: currentMarginRight
    };
  };

  SliderWrapper.prototype.getRemovableSlides = function (delta) {
    var slides = [];
    var first;
    var last;
    var index = this._wrapperElement.children.length;

    while (index > 0) {
      index--;
      var propsNow = this.getSlideProperties(index);
      var propsNew = this.getSlideProperties(index, delta);

      if (index === this._wrapperElement.children.length - 1) {
        last = propsNew;
      }

      if (index === 0) {
        first = propsNew;
      }

      if (propsNow.visible === false && propsNew.visible === false && index !== this._index && this._isdragging === false) {
        slides.push(true);
      } else {
        slides.push(false);
      }
    }

    slides.reverse();
    var firstToKeep = slides.indexOf(false);
    var lastToKeep = slides.lastIndexOf(false);

    for (var i = firstToKeep; i < lastToKeep; i++) {
      slides[i] = false;
    }

    return {
      slides: slides,
      first: first,
      last: last
    };
  };

  SliderWrapper.prototype.getEmptySpace = function (left, right) {
    return {
      left: Math.max(Math.ceil(left - this._containerMin), 0),
      right: Math.max(Math.ceil(this._containerMax - right), 0)
    };
  };

  SliderWrapper.prototype.destroy = function () {
    this._wrapperElement = null;
    this._slideAreaElement = null;
    this._carouselElement = null;
  };
  /**
   * @deprecated use destroy() instead.
   * @todo remove in version 2.0.0
   */


  SliderWrapper.prototype.destory = function () {
    this.destroy();
  };

  return SliderWrapper;
}();

function init() {
  (0, _Utils.searchAndInitialize)(".carousel", function (e) {
    new Carousel(e);
  });
}

var _default = Carousel;
exports["default"] = _default;

},{"../DomElement":4,"../DomFunctions":5,"../Inputs":6,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"@babel/runtime/helpers/interopRequireWildcard":34,"tslib":43}],10:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _DomElement = _interopRequireDefault(require("../DomElement"));

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

var _ChartFunctions = require("./ChartFunctions");

var _animejs = _interopRequireDefault(require("animejs"));

var QUERY_DETAIL_RIGHT = ".detail-right";
var QUERY_DETAIL_BOTTOM = ".detail-bottom";
var QUERY_PROGRESS = ".bar-chart__progress";
var CLASS_UNLIMITED = "bar-chart-horizontal--unlimited";
var CLASS_LIMITED = "bar-chart-horizontal--limited";
var CLASS_DETAIL_VALUE = "value";
var CLASS_DETAIL_UNIT = "unit";
var CLASS_INDICATOR = "indicator";
var CLASS_INDICATOR_WRAPPER = "indicator-wrapper";
var CLASS_TOOLTIP = "tooltip";
var CLASS_TOOLTIP_MULTILINE = "tooltip--multiline";
var ANIMATION_DURATION = 500;
/**
 * Bar Chart Horizontal Component.
 */

var BarChartHorizontal =
/** @class */
function (_super) {
  (0, _tslib.__extends)(BarChartHorizontal, _super);
  /**
   * Creates and initializes the bar chart horizontal component.
   * @param {DomElement} - root element of the chart.
   */

  function BarChartHorizontal(element, data) {
    var _this = _super.call(this, element) || this;

    if (data) {
      _this._data = data;
    }

    _this._legendItems = [];

    _this._initialize();

    return _this;
  }

  BarChartHorizontal.prototype._initialize = function () {
    this._unit = this.getAttribute("data-unit") || "";
    this._maxValue = parseFloat(this.getAttribute("data-max"));
    this._precision = parseInt(this.getAttribute("data-precision"), 10) || 0;
    this._isUnlimited = this.hasClass(CLASS_UNLIMITED);
    this._isLimited = this.hasClass(CLASS_LIMITED);
    this._progessWrapper = this.element.querySelector(QUERY_PROGRESS);

    if (this._isLimited === true) {
      this._detailRight = this.element.querySelector(QUERY_DETAIL_BOTTOM);
    } else {
      this._detailRight = this.element.querySelector(QUERY_DETAIL_RIGHT);
    }

    if (this._isUnlimited === false && this._isLimited === false) {
      this._legend = (0, _DomFunctions.getAttributeReference)(this.element, "data-legend");
    }

    if (!this._data) {
      this._data = (0, _ChartFunctions.tryGetData)(this.element);
    }

    this._render();
  };

  BarChartHorizontal.prototype._render = function () {
    var e_1, _a;

    var dataOne = this._data[0];
    var dataTwo = this._data[1];
    var tooltip = this._isLimited === false ? this._getTooltipContent(this._data) : undefined;
    var animatedValueElement; // Cleanup

    (0, _ChartFunctions.removeAllChildren)(this._detailRight);
    (0, _ChartFunctions.removeAllChildren)(this._progessWrapper);

    try {
      // Clear only own legend items
      for (var _b = (0, _tslib.__values)(this._legendItems), _c = _b.next(); !_c.done; _c = _b.next()) {
        var item = _c.value;
        (0, _Utils.remove)(item);
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }

    this._legendItems = [];

    if (dataOne) {
      if (this._isUnlimited === false || this._isUnlimited === true && !dataTwo) {
        var valElement = animatedValueElement = this._createValueElement(dataOne);

        this._detailRight.appendChild(valElement);

        if (this._isLimited === false) {
          var separatorElement = new _DomElement["default"]("div").addClass(CLASS_DETAIL_UNIT).element;
          separatorElement.innerText = " " + this._unit;

          this._detailRight.appendChild(separatorElement);
        }
      } // Add the indicator


      var indicator = this._addIndicator(dataOne, tooltip);

      this._animateIndicator(indicator, 0); // Animate the value if required


      if (animatedValueElement && this._isLimited === true) {
        this._animateValueElement(animatedValueElement, dataOne.value);
      } // Add the legend


      if (this._legend) {
        var legendItem = (0, _ChartFunctions.createLegendItem)(dataOne);

        this._legend.appendChild(legendItem);

        this._legendItems.push(legendItem);

        this._animateLegend(legendItem, 0);
      }
    }

    if (dataTwo) {
      var valElement = this._createValueElement(dataTwo);

      var unitElement = new _DomElement["default"]("div").addClass(CLASS_DETAIL_UNIT).element;
      unitElement.innerText = " " + this._unit;

      this._detailRight.appendChild(valElement);

      this._detailRight.appendChild(unitElement); // Add the indicator


      var indicator = this._addIndicator(dataTwo, tooltip);

      this._animateIndicator(indicator, ANIMATION_DURATION); // Add the legend


      if (this._legend) {
        var legendItem = (0, _ChartFunctions.createLegendItem)(dataTwo);

        this._legend.appendChild(legendItem);

        this._legendItems.push(legendItem);

        this._animateLegend(legendItem, ANIMATION_DURATION);
      }
    }

    if (this._isLimited === true) {
      var valElement = this._createValueElement({
        value: this._maxValue
      });

      var unitElement = new _DomElement["default"]("div").addClass(CLASS_DETAIL_UNIT).element;
      unitElement.innerText = " " + this._unit;

      this._detailRight.appendChild(valElement);

      this._detailRight.appendChild(unitElement);
    }
  };

  BarChartHorizontal.prototype._animateValueElement = function (animatedValueElement, toValue) {
    var counter = {
      "var": 0
    };
    (0, _animejs["default"])({
      targets: counter,
      "var": toValue,
      duration: ANIMATION_DURATION,
      easing: "easeOutQuint",
      round: 1,
      update: function update() {
        animatedValueElement.innerText = "" + counter["var"];
      }
    });
  };

  BarChartHorizontal.prototype._animateIndicator = function (indicatorWrapper, animationOffset) {
    var indicator = indicatorWrapper.getElementsByClassName("indicator")[0];
    var indicatorWidth = indicator.scrollWidth;
    indicator.style.width = "0px";
    (0, _animejs["default"])({
      targets: indicator,
      duration: ANIMATION_DURATION,
      width: indicatorWidth + "px",
      easing: "easeInOutQuint",
      delay: animationOffset,
      complete: function complete() {
        indicator.style.width = "";
      }
    });
  };

  BarChartHorizontal.prototype._animateLegend = function (legendItem, animationOffset) {
    legendItem.style.opacity = "0";
    (0, _animejs["default"])({
      targets: legendItem,
      duration: ANIMATION_DURATION,
      opacity: 1,
      easing: "easeInOutQuint",
      delay: animationOffset,
      complete: function complete() {
        legendItem.style.removeProperty("opacity");
      }
    });
  };

  BarChartHorizontal.prototype._createValueElement = function (data) {
    var unlimitedPrefix = "";

    if (this._isUnlimited === true) {
      unlimitedPrefix = "+";
    }

    var value = parseFloat(data.value);

    if (value <= 0) {
      if (this._precision === 0) {
        value = "0";
      } else {
        value = ".";

        for (var i = 0; i < this._precision; i++) {
          value += "0";
        }
      }
    } else {
      value = value.toFixed(this._precision);
    }

    var valueElement = new _DomElement["default"]("div").addClass(CLASS_DETAIL_VALUE).element;
    valueElement.innerText = "" + unlimitedPrefix + value;
    return valueElement;
  };

  BarChartHorizontal.prototype._addIndicator = function (data, tooltip) {
    var width = 100.0 / this._maxValue * data.value;
    var indicator = new _DomElement["default"]("div").addClass(CLASS_INDICATOR);

    if ((0, _ChartFunctions.isColor)(data.color) === true) {
      indicator.setAttribute("style", "background-color: " + data.color + ";");
    } else {
      indicator.addClass(data.color);
    }

    var indicatorWrapper = new _DomElement["default"]("div").addClass(CLASS_INDICATOR_WRAPPER).setAttribute("style", "width: " + width + "%").appendChild(indicator).setAttribute("onclick", "void(0)");

    if (tooltip && tooltip !== "") {
      indicatorWrapper.addClass(CLASS_TOOLTIP).addClass(CLASS_TOOLTIP_MULTILINE).setAttribute("aria-label", tooltip);
    }

    this._progessWrapper.appendChild(indicatorWrapper.element);

    return indicatorWrapper.element;
  };

  BarChartHorizontal.prototype._getTooltipContent = function (dataList) {
    var e_2, _a;

    var tooltip = "";

    try {
      for (var dataList_1 = (0, _tslib.__values)(dataList), dataList_1_1 = dataList_1.next(); !dataList_1_1.done; dataList_1_1 = dataList_1.next()) {
        var data = dataList_1_1.value;
        tooltip += data.title + ": " + data.value + " " + this._unit + "\n";
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (dataList_1_1 && !dataList_1_1.done && (_a = dataList_1["return"])) _a.call(dataList_1);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    return tooltip.trim();
  };
  /**
   * Updates the bar chart with the specified data definitions.
   * @param {Array} - bar chart data definitions.
   */


  BarChartHorizontal.prototype.update = function (data) {
    if (data) {
      this._data = data;
    }

    this._render();
  };
  /**
   * Removes all event handlers and clears references.
   */


  BarChartHorizontal.prototype.destroy = function () {
    var e_3, _a;

    this._data = undefined;
    (0, _ChartFunctions.removeAllChildren)(this._detailRight);
    (0, _ChartFunctions.removeAllChildren)(this._progessWrapper);
    this._detailRight = undefined;
    this._progessWrapper = undefined;

    try {
      for (var _b = (0, _tslib.__values)(this._legendItems), _c = _b.next(); !_c.done; _c = _b.next()) {
        var item = _c.value;
        (0, _Utils.remove)(item);
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    this._legendItems = undefined;
    this._legend = undefined;
  };
  /**
   * @deprecated use destroy() instead.
   * @todo remove in version 2.0.0
   */


  BarChartHorizontal.prototype.destory = function () {
    this.destroy();
  };

  return BarChartHorizontal;
}(_DomElement["default"]);

function init() {
  (0, _Utils.searchAndInitialize)(".bar-chart-horizontal", function (e) {
    new BarChartHorizontal(e);
  });
}

var _default = BarChartHorizontal;
exports["default"] = _default;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"./ChartFunctions":12,"@babel/runtime/helpers/interopRequireDefault":33,"animejs":36,"tslib":43}],11:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _DomElement = _interopRequireDefault(require("../DomElement"));

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

var _ChartFunctions = require("./ChartFunctions");

var _animejs = _interopRequireDefault(require("animejs"));

var QUERY_DATA_CATEGORIES = ".js-data-list .js-category";
var QUERY_DATA_ITEMS = ".js-data-list .js-data";
var QUERY_CHART = ".js-chart";
var QUERY_LEGEND = ".bar-chart__legend";
var CLASS_INDICATOR = "indicator";
var CLASS_LABEL_X = "axis-x-label";
var CLASS_INDICATOR_WRAPPER = "indicator-wrapper";
var CLASS_INDICATOR_INNER_WRAPPER = "indicator-wrapper-inner";
var CLASS_INDICATOR_EMPTY = "empty";
var CLASS_TOOLTIP = "tooltip";
var CLASS_TOOLTIP_LEFT = "tooltip--left";
var CLASS_TOOLTIP_RIGHT = "tooltip--right";
var CLASS_TOOLTIP_MULTILINE = "tooltip--multiline";
var ANIMATION_DURATION = 500;
/**
 * Bar Chart Horizontal Component.
 */

var BarChartVertical =
/** @class */
function (_super) {
  (0, _tslib.__extends)(BarChartVertical, _super);
  /**
   * Creates and initializes the bar chart horizontal component.
   * @param element - root element of the chart.
   * @param data - data for the chart.
   */

  function BarChartVertical(element, data) {
    var _this = _super.call(this, element) || this;

    if (data) {
      _this._data = data;
    }

    _this._initialize();

    return _this;
  }

  BarChartVertical.prototype._initialize = function () {
    this._unit = this.getAttribute("data-unit") || "";
    this._maxValue = parseFloat(this.getAttribute("data-max")) || 100;
    this._chart = this.element.querySelector(QUERY_CHART);
    this._legend = this.element.querySelector(QUERY_LEGEND);

    if (!this._data) {
      this._data = this._tryGetData(this.element);
    }

    this._render();
  };

  BarChartVertical.prototype._tryGetData = function (element) {
    var e_1, _a, e_2, _b, e_3, _c;

    var data = {
      categories: [],
      items: []
    };
    var categories = element.querySelectorAll(QUERY_DATA_CATEGORIES);
    var items = element.querySelectorAll(QUERY_DATA_ITEMS);

    try {
      for (var categories_1 = (0, _tslib.__values)(categories), categories_1_1 = categories_1.next(); !categories_1_1.done; categories_1_1 = categories_1.next()) {
        var category = categories_1_1.value;
        data.categories.push({
          title: (0, _DomFunctions.text)(category),
          color: category.getAttribute("data-color")
        });
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (categories_1_1 && !categories_1_1.done && (_a = categories_1["return"])) _a.call(categories_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }

    try {
      for (var items_1 = (0, _tslib.__values)(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
        var item = items_1_1.value;
        var dataEnty = {
          title: (0, _DomFunctions.text)(item),
          "class": item.getAttribute("data-class"),
          values: []
        };
        var vals = item.getAttribute("data-value");

        if (vals) {
          try {
            for (var _d = (e_3 = void 0, (0, _tslib.__values)(vals.split(","))), _e = _d.next(); !_e.done; _e = _d.next()) {
              var val = _e.value;
              dataEnty.values.push(parseFloat(val));
            }
          } catch (e_3_1) {
            e_3 = {
              error: e_3_1
            };
          } finally {
            try {
              if (_e && !_e.done && (_c = _d["return"])) _c.call(_d);
            } finally {
              if (e_3) throw e_3.error;
            }
          }
        }

        data.items.push(dataEnty);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (items_1_1 && !items_1_1.done && (_b = items_1["return"])) _b.call(items_1);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    return data;
  };

  BarChartVertical.prototype._getTooltipContent = function (entry, categories) {
    var tooltip = "";

    for (var i = 0; i < entry.values.length; i++) {
      tooltip += categories[i].title + ": " + entry.values[i] + " " + this._unit + "\n";
    }

    return tooltip.trim();
  };

  BarChartVertical.prototype._render = function () {
    var e_4, _a, e_5, _b;

    if (this._legend) {
      (0, _ChartFunctions.removeAllChildren)(this._legend);

      try {
        for (var _c = (0, _tslib.__values)(this._data.categories), _d = _c.next(); !_d.done; _d = _c.next()) {
          var category = _d.value;
          var legendItem = (0, _ChartFunctions.createLegendItem)(category);

          this._legend.appendChild(legendItem);
        }
      } catch (e_4_1) {
        e_4 = {
          error: e_4_1
        };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c["return"])) _a.call(_c);
        } finally {
          if (e_4) throw e_4.error;
        }
      }
    }

    (0, _ChartFunctions.removeAllChildren)(this._chart);
    var animationStages = [];
    var leftSideItems = Math.floor(this._data.items.length / 2);

    try {
      for (var _e = (0, _tslib.__values)(this._data.items), _f = _e.next(); !_f.done; _f = _e.next()) {
        var item = _f.value;
        var element = new _DomElement["default"]("li");

        if (item["class"]) {
          element.addClass(item["class"]);
        }

        var listElement = new _DomElement["default"]("ul").addClass(CLASS_INDICATOR_WRAPPER);
        var wrapper = new _DomElement["default"]("div").addClass(CLASS_INDICATOR_INNER_WRAPPER);
        listElement.appendChild(wrapper);
        element.appendChild(listElement);

        var tooltip = this._getTooltipContent(item, this._data.categories);

        if (tooltip) {
          wrapper.addClass(CLASS_TOOLTIP).addClass(leftSideItems <= 0 ? CLASS_TOOLTIP_LEFT : CLASS_TOOLTIP_RIGHT).setAttribute("aria-label", tooltip);

          if (item.values.length > 1) {
            wrapper.addClass(CLASS_TOOLTIP_MULTILINE);
          }
        }

        for (var i = 0; i < item.values.length; i++) {
          var height = this._chart.offsetHeight / this._maxValue * item.values[i];
          var indicator = new _DomElement["default"]("li").addClass(CLASS_INDICATOR).setAttribute("style", "height: " + height + "px;");

          if (height > 0) {
            var color = this._data.categories[i].color;

            if ((0, _ChartFunctions.isColor)(color)) {
              indicator.setAttribute("style", "background-color: " + color + ";");
            } else {
              indicator.addClass(color);
            }

            if (animationStages.length <= i) {
              animationStages.push([]);
            }

            animationStages[i].push(indicator.element);
          } else {
            indicator.addClass(CLASS_INDICATOR_EMPTY);
          }

          wrapper.appendChild(indicator);
        }

        var titleDomElement = new _DomElement["default"]("div").addClass(CLASS_LABEL_X);
        var titleElement = titleDomElement.element;
        titleElement.innerText = item.title;
        element.appendChild(titleDomElement);

        this._chart.appendChild(element.element);

        leftSideItems -= 1;
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (_f && !_f.done && (_b = _e["return"])) _b.call(_e);
      } finally {
        if (e_5) throw e_5.error;
      }
    }

    for (var i = 0; i < animationStages.length; i++) {
      var offset = ANIMATION_DURATION * i;

      this._animateBars(animationStages[i], offset);

      if (this._legend) {
        this._animateLegend(this._legend.children[i], offset);
      }
    }
  };

  BarChartVertical.prototype._animateBars = function (bars, animationOffset) {
    for (var i = 0; i < bars.length; i++) {
      var bar = bars[i];
      var barHeight = bar.style.height;
      bar.style.height = "0";
      (0, _animejs["default"])({
        targets: bars[i],
        height: barHeight,
        easing: "easeInOutQuint",
        duration: ANIMATION_DURATION,
        delay: animationOffset
      });
    }
  };

  BarChartVertical.prototype._animateLegend = function (legend, animationOffset) {
    legend.style.opacity = "0";
    (0, _animejs["default"])({
      targets: legend,
      opacity: 1,
      easing: "easeInOutQuint",
      duration: ANIMATION_DURATION,
      delay: animationOffset
    });
  };
  /**
   * Updates the bar chart with the specified data definitions.
   * @param {Array} - bar chart data definitions.
   */


  BarChartVertical.prototype.update = function (data) {
    if (data) {
      this._data = data;
    }

    this._render();
  };
  /**
   * Removes all event handlers and clears references.
   */


  BarChartVertical.prototype.destroy = function () {
    this._data = undefined;

    if (this._legend) {
      (0, _ChartFunctions.removeAllChildren)(this._legend);
      this._legend = undefined;
    }
  };
  /**
   * @deprecated use destroy() instead.
   * @todo remove in version 2.0.0
   */


  BarChartVertical.prototype.destory = function () {
    this.destroy();
  };

  return BarChartVertical;
}(_DomElement["default"]);

function init() {
  (0, _Utils.searchAndInitialize)(".bar-chart-vertical", function (e) {
    new BarChartVertical(e);
  });
}

var _default = BarChartVertical;
exports["default"] = _default;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"./ChartFunctions":12,"@babel/runtime/helpers/interopRequireDefault":33,"animejs":36,"tslib":43}],12:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tryGetData = tryGetData;
exports.removeAllChildren = removeAllChildren;
exports.createLegendItem = createLegendItem;
exports.isColor = isColor;

var _tslib = require("tslib");

var _DomElement = _interopRequireDefault(require("../DomElement"));

var _DomFunctions = require("../DomFunctions");

var QUERY_DATA = ".js-data";

function tryGetData(element) {
  var e_1, _a;

  var data = [];
  var elements = element.querySelectorAll(QUERY_DATA);

  try {
    for (var elements_1 = (0, _tslib.__values)(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
      var entry = elements_1_1.value;
      var value = parseFloat(entry.getAttribute("data-value"));
      var color = entry.getAttribute("data-color");
      var title = (0, _DomFunctions.text)(entry);
      var item = {
        title: title,
        value: value,
        color: color
      };
      data.push(item);
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (elements_1_1 && !elements_1_1.done && (_a = elements_1["return"])) _a.call(elements_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  return data;
}

function removeAllChildren(node) {
  while (node.firstChild) {
    node.removeChild(node.firstChild);
  }
}

function createLegendItem(data) {
  var bullet = new _DomElement["default"]("span").addClass("bullet");

  if (isColor(data.color) === true) {
    bullet.setAttribute("style", "background-color: " + data.color + ";");
  } else {
    bullet.addClass(data.color);
  }

  var caption = new _DomElement["default"]("span").setHtml(data.title);
  return new _DomElement["default"]("li").appendChild(bullet).appendChild(caption).element;
}

function isColor(str) {
  var pattern = /^#/i;
  return pattern.test(str);
}

},{"../DomElement":4,"../DomFunctions":5,"@babel/runtime/helpers/interopRequireDefault":33,"tslib":43}],13:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _DomElement = _interopRequireDefault(require("../DomElement"));

var _Utils = require("../Utils");

var _ChartFunctions = require("./ChartFunctions");

var _animejs = _interopRequireDefault(require("animejs"));

var QUERY_CHART = ".js-chart";
var QUERY_LEGEND = ".js-legend";
var DASH_SEPARATOR_WIDTH = 3;
var ANIMATION_DURATION = 1500;
var ANIMATION_DURATION_LEGEND = 500;
var QUERY_META_TITLE = ".meta .title";
var QUERY_META_SUBTITLE = ".meta .subtitle";
/**
 * Pie Chart Component.
 */

var PieChart =
/** @class */
function (_super) {
  (0, _tslib.__extends)(PieChart, _super);
  /**
   * Creates and initializes the Pie Chart component.
   * @param {DomElement} - root element of the chart.
   * @param {Array} - pie chart data definitions.
   */

  function PieChart(element, data) {
    var _this = _super.call(this, element) || this;

    if (data) {
      _this._data = data;
    }

    _this._initialize();

    return _this;
  }

  PieChart.prototype._initialize = function () {
    this._chart = this.element.querySelector(QUERY_CHART);
    this._legend = this.element.querySelector(QUERY_LEGEND);
    this._title = this.element.querySelector(QUERY_META_TITLE);
    this._subtitle = this.element.querySelector(QUERY_META_SUBTITLE);
    this._unit = this.getAttribute("data-unit") || "";
    this._alwaysShowLegend = this.element.hasAttribute("data-always-show-legend");

    if (!this._data) {
      this._data = (0, _ChartFunctions.tryGetData)(this.element);
    }

    this._render();
  };

  PieChart.prototype._render = function () {
    var total = this._data.reduce(function (a, b) {
      return a + b.value;
    }, 0);

    var r = 16;
    var dashTotal = 2 * r * Math.PI;
    var currentRotate = 9; // Cleanup

    (0, _ChartFunctions.removeAllChildren)(this._chart);

    if (this._legend) {
      (0, _ChartFunctions.removeAllChildren)(this._legend);
    }

    var percentageAdjustTotal = 0;
    var percentageAdjust = 0;
    var separatorPercentage = DASH_SEPARATOR_WIDTH / 100;

    for (var i = 0; i < this._data.length; i++) {
      var entry = this._data[i];
      var percentage = entry.value / total;

      if (percentage < separatorPercentage) {
        percentageAdjustTotal += separatorPercentage - percentage;
        percentageAdjust++;
      }
    }

    if (percentageAdjust > 0) {
      percentageAdjust = percentageAdjustTotal / (this._data.length - percentageAdjust);
    }

    var animations = _animejs["default"].timeline();

    var animationOffset = 0;

    var _loop_1 = function _loop_1(i) {
      var entry = this_1._data[i];
      var displayPercentage = entry.value / total;
      var percentage = Math.max(separatorPercentage, displayPercentage - percentageAdjust);
      var dashWidth = percentage * dashTotal - DASH_SEPARATOR_WIDTH;
      var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("viewBox", "0 0 34 34");
      svg.setAttribute("role", "img");
      svg.setAttribute("aria-labelledby", "title desc");
      var title = document.createElementNS("http://www.w3.org/2000/svg", "title");
      title.setAttribute("id", "title");
      title.innerHTML = "Pie chart segment " + Math.floor(displayPercentage * 100) + "%";
      var description = document.createElementNS("http://www.w3.org/2000/svg", "desc");
      description.setAttribute("id", "desc");
      description.innerHTML = entry.title + ": " + entry.value;
      var circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      circle.setAttribute("cx", "17");
      circle.setAttribute("cy", "17");
      circle.setAttribute("r", String(r));

      if ((0, _ChartFunctions.isColor)(entry.color) === true) {
        circle.setAttribute("stroke", "" + entry.color);
      } else {
        circle.setAttribute("class", entry.color);
      }

      circle.setAttribute("role", "presentation");
      svg.setAttribute("style", "transform: rotate(" + currentRotate + "deg);");
      svg.appendChild(title);
      svg.appendChild(description);
      svg.appendChild(circle);

      this_1._chart.appendChild(svg);

      var animationDuration = ANIMATION_DURATION * percentage;
      circle.style.display = "none";
      var counter = {
        "var": 0.5
      };
      animations.add({
        targets: counter,
        "var": dashWidth,
        begin: function begin() {
          circle.style.display = "";
        },
        update: function update() {
          circle.setAttribute("stroke-dasharray", counter["var"] + " " + dashTotal);
        },
        duration: animationDuration,
        easing: "easeInQuint"
      }); // Legend

      if (this_1._legend && this_1._data.length > 1 || this_1._alwaysShowLegend) {
        var bullet = new _DomElement["default"]("span").addClass("bullet");

        if ((0, _ChartFunctions.isColor)(entry.color) === true) {
          bullet.setAttribute("style", "background-color: " + entry.color);
        } else {
          bullet.addClass(entry.color);
        }

        var caption = new _DomElement["default"]("span");
        var captionElement = caption.element;
        captionElement.innerText = entry.title;
        var legendItem = new _DomElement["default"]("li").appendChild(bullet).appendChild(caption);

        this_1._legend.appendChild(legendItem.element);

        this_1._animateLegend(legendItem.element, animationOffset);
      }

      animationOffset += animationDuration;
      currentRotate += 360 * percentage;

      if (i === this_1._data.length - 1) {
        this_1._title.innerHTML = entry.value + " " + this_1._unit;
        this_1._subtitle.innerHTML = entry.title;
      }
    };

    var this_1 = this;

    for (var i = 0; i < this._data.length; i++) {
      _loop_1(i);
    }
  };

  PieChart.prototype._animateLegend = function (legendItem, animationOffset) {
    legendItem.style.opacity = "0";
    (0, _animejs["default"])({
      targets: legendItem,
      duration: ANIMATION_DURATION_LEGEND,
      opacity: 1,
      easing: "easeInOutQuint",
      delay: animationOffset,
      complete: function complete() {
        legendItem.style.removeProperty("opacity");
      }
    });
  };
  /**
   * Updates the pie chart with the specified data definitions.
   * @param {Array} - pie chart data definitions.
   */


  PieChart.prototype.update = function (data) {
    if (data) {
      this._data = data;
    }

    this._render();
  };
  /**
   * Removes all event handlers and clears references.
   */


  PieChart.prototype.destroy = function () {
    this._data = undefined;
    this._title = undefined;
    this._subtitle = undefined;
    this._unit = undefined;
    (0, _ChartFunctions.removeAllChildren)(this._chart);
    this._chart = undefined;

    if (this._legend) {
      (0, _ChartFunctions.removeAllChildren)(this._legend);
      this._legend = undefined;
    }
  };
  /**
   * @deprecated use destroy() instead.
   * @todo remove in version 2.0.0
   */


  PieChart.prototype.destory = function () {
    this.destroy();
  };

  return PieChart;
}(_DomElement["default"]);

function init() {
  (0, _Utils.searchAndInitialize)(".pie-chart", function (e) {
    new PieChart(e);
  });
}

var _default = PieChart;
exports["default"] = _default;

},{"../DomElement":4,"../Utils":7,"./ChartFunctions":12,"@babel/runtime/helpers/interopRequireDefault":33,"animejs":36,"tslib":43}],14:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _Utils = require("../Utils");

var _animejs = _interopRequireDefault(require("animejs"));

var _DomElement = _interopRequireDefault(require("../DomElement"));

var _DomFunctions = require("../DomFunctions");

var CLASS_OPEN = "is-open";
var ANIMATION_OPEN = 300;
/**
 * The Collapse component.
 */

var Collapse =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Collapse, _super);
  /**
   * Creates and initializes the Collapse component.
   * @param {DomElement} - The root element of the Collapse component.
   */

  function Collapse(element) {
    var _this = _super.call(this, element) || this;

    _this._clickHandler = _this._handleClick.bind(_this);

    _this._initialize();

    return _this;
  }
  /**
   * Initializes the Collapse component.
   * @private
   */


  Collapse.prototype._initialize = function () {
    var dataTarget = this.element.getAttribute("data-target");

    if (dataTarget === null || dataTarget === "") {
      /* tslint:disable:no-console */
      console.error("A collapsible element requires a 'data-target' that specifies the element to collapse");
      console.info(this.element);
      /* tslint:enable:no-console */

      return;
    }

    var hiddenTarget = this.element.getAttribute("data-hidden");

    if (hiddenTarget !== null && hiddenTarget !== "") {
      this._hiddenIndicator = document.querySelector(hiddenTarget);
    }

    this._collapsibleElements = document.querySelectorAll(dataTarget);
    this.element.addEventListener("click", this._clickHandler);
  };

  Collapse.prototype._handleClick = function (event) {
    (0, _Utils.preventDefault)(event);
    this.toggle();
  };
  /**
   * Toggles the collapseible.
   */


  Collapse.prototype.toggle = function () {
    var e_1, _a, e_2, _b;

    if (this._hiddenIndicator && (0, _DomFunctions.isHidden)(this._hiddenIndicator, false) === true) {
      return;
    }

    if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
      (0, _DomFunctions.addClass)(this.element, CLASS_OPEN);

      try {
        for (var _c = (0, _tslib.__values)(this._collapsibleElements), _d = _c.next(); !_d.done; _d = _c.next()) {
          var s = _d.value;

          this._openCollapse(s);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c["return"])) _a.call(_c);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    } else {
      (0, _DomFunctions.removeClass)(this.element, CLASS_OPEN);

      try {
        for (var _e = (0, _tslib.__values)(this._collapsibleElements), _f = _e.next(); !_f.done; _f = _e.next()) {
          var s = _f.value;

          this._closeCollapse(s);
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (_f && !_f.done && (_b = _e["return"])) _b.call(_e);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
    }
  };

  Collapse.prototype._openCollapse = function (el) {
    _animejs["default"].remove(el);

    el.style.display = "block";
    (0, _animejs["default"])({
      targets: el,
      duration: ANIMATION_OPEN,
      height: el.scrollHeight + "px",
      easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
      complete: function complete() {
        var domEl = new _DomElement["default"](el);
        domEl.addClass(CLASS_OPEN);
        domEl.setAttribute("style", "");
      }
    }); // set aria expanded

    el.setAttribute("aria-expanded", "true");
  };

  Collapse.prototype._closeCollapse = function (el) {
    _animejs["default"].remove(el);

    (0, _animejs["default"])({
      targets: el,
      duration: ANIMATION_OPEN,
      height: 0,
      easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
      complete: function complete() {
        var domEl = new _DomElement["default"](el);
        domEl.removeClass(CLASS_OPEN);
        domEl.setAttribute("style", "");
      }
    }); // set aria expanded

    el.setAttribute("aria-expanded", "false");
  };
  /**
   * Removes all event handlers and clears references.
   */


  Collapse.prototype.destroy = function () {
    this._collapsibleElements = null;

    if (this._clickHandler) {
      this.element.removeEventListener("click", this._clickHandler);
    }

    this.element = null;
  };

  return Collapse;
}(_DomElement["default"]);

function init() {
  var e_3, _a;

  var elements = document.querySelectorAll("[data-toggle='collapse']");

  try {
    for (var elements_1 = (0, _tslib.__values)(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
      var e = elements_1_1.value;

      if (e.getAttribute("data-init") === "auto") {
        new Collapse(e);
      }
    }
  } catch (e_3_1) {
    e_3 = {
      error: e_3_1
    };
  } finally {
    try {
      if (elements_1_1 && !elements_1_1.done && (_a = elements_1["return"])) _a.call(elements_1);
    } finally {
      if (e_3) throw e_3.error;
    }
  }
}

var _default = Collapse;
exports["default"] = _default;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"animejs":36,"tslib":43}],15:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _Utils = require("../Utils");

var _DomElement = _interopRequireDefault(require("../DomElement"));

var _DomFunctions = require("../DomFunctions");

var CLASS_BORDER = "empty-state__border";
var CLASS_BORDER_MODAL = "empty-state__border--modal";
var CLASS_ACTIVE = "is-active";
var CLASS_HASFILES = "has-files";
var CLASS_MODAL = "empty-state--modal";
var CLASS_MODAL_CONTENT = "modal__content";
var QUERY_MODAL_BODY = ".modal__body";
var QUERY_FILE = "input[type='file']";
/**
 * Empty state pattern
 */

var EmptyState =
/** @class */
function (_super) {
  (0, _tslib.__extends)(EmptyState, _super);
  /**
   * Creates and initializes the Empty-State pattern component.
   * @param {DomElement} - root element of the empty-state pattern.
   */

  function EmptyState(element) {
    var _this = _super.call(this, element) || this;

    _this._fileInput = _this.element.querySelector(QUERY_FILE);
    _this._button = _this.element.querySelector("label");
    _this._fileChangedHandler = _this._handleFileChanged.bind(_this);
    _this._preventEventsHandler = _this._preventDragEvents.bind(_this);
    _this._dragEnterHandler = _this._handleDragEnter.bind(_this);
    _this._dragLeaveHandler = _this._handleDragLeave.bind(_this);
    _this._dropHandler = _this._handleDrop.bind(_this);
    _this._isDragging = false;

    _this._initialize();

    return _this;
  }

  EmptyState.prototype._initialize = function () {
    var e_1, _a;

    if (this.hasClass(CLASS_MODAL)) {
      // handle modal dialogs
      this._dragArea = (0, _DomFunctions.parentWithClass)(this.element, CLASS_MODAL_CONTENT);

      var borderArea = this._dragArea.querySelector(QUERY_MODAL_BODY);

      borderArea.setAttribute("style", "pointer-events: none;");
      this._border = new _DomElement["default"]("div").addClass(CLASS_BORDER).addClass(CLASS_BORDER_MODAL);
      borderArea.appendChild(this._border.element);
    } else {
      // normal modal dialog
      this._dragArea = this.element;
      var borderArea = (0, _DomFunctions.getRootElement)();
      this._border = new _DomElement["default"]("div").addClass(CLASS_BORDER);

      if (!borderArea.querySelector("." + CLASS_BORDER)) {
        borderArea.appendChild(this._border.element);
      }
    }

    var form = this.element.querySelector("form");

    try {
      for (var _b = (0, _tslib.__values)(["drag", "dragstart", "dragend", "dragover", "dragenter", "dragleave", "drop"]), _c = _b.next(); !_c.done; _c = _b.next()) {
        var event_1 = _c.value;
        this.element.addEventListener(event_1, this._preventEventsHandler);
        form.addEventListener(event_1, this._preventEventsHandler);

        this._dragArea.addEventListener(event_1, this._preventEventsHandler);
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }

    this._dragArea.addEventListener("dragover", this._dragEnterHandler);

    this._dragArea.addEventListener("dragenter", this._dragEnterHandler);

    this._dragArea.addEventListener("dragleave", this._dragLeaveHandler);

    this._dragArea.addEventListener("dragend", this._dragLeaveHandler);

    this._dragArea.addEventListener("drop", this._dragLeaveHandler);

    this._dragArea.addEventListener("drop", this._dropHandler);

    this._fileInput.addEventListener("change", this._fileChangedHandler);
  };

  EmptyState.prototype._preventDragEvents = function (e) {
    e.preventDefault();
    e.stopPropagation();
    return false;
  };

  EmptyState.prototype._handleDragEnter = function () {
    if (this._isDragging === true) {
      return;
    }

    this._isDragging = true;

    this._button.setAttribute("style", "pointer-events: none;");

    this.addClass(CLASS_ACTIVE);

    this._border.addClass(CLASS_ACTIVE);
  };

  EmptyState.prototype._handleDragLeave = function () {
    if (this._isDragging === false) {
      return;
    }

    this._isDragging = false;

    this._button.setAttribute("style", "");

    this.removeClass(CLASS_ACTIVE);

    this._border.removeClass(CLASS_ACTIVE);
  };

  EmptyState.prototype._handleDrop = function (e) {
    var dragEvent = e;
    this._fileInput.files = dragEvent.dataTransfer.files;
  };

  EmptyState.prototype._handleFileChanged = function () {
    var files = this._fileInput.files;

    if (files && files.length > 0) {
      this.addClass(CLASS_HASFILES);
    } else {
      this.removeClass(CLASS_HASFILES);
    }
  };

  Object.defineProperty(EmptyState.prototype, "files", {
    /**
     * Gets the currently selected files.
     */
    get: function get() {
      return this._fileInput.files;
    },
    enumerable: false,
    configurable: true
  });
  return EmptyState;
}(_DomElement["default"]);

function init() {
  (0, _Utils.searchAndInitialize)(".empty-state", function (e) {
    new EmptyState(e);
  });
}

var _default = EmptyState;
exports["default"] = _default;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"tslib":43}],16:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

var _DomElement = _interopRequireDefault(require("../DomElement"));

var Inputs = _interopRequireWildcard(require("../Inputs"));

var QUERY_DROPDOWN = ".js-autocomplete";
var CLASS_RESULT = "autocomplete__result";
var CLASS_OPEN = "is-open";
var CLASS_HOVER = "js-hover";
var ATTRIBUTE_VALUE = "data-value";
var TIMEOUT_BLUR = 400;
/**
 * Autocomplete component
 * @fires Autocomplete#change
 */

var Autocomplete =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Autocomplete, _super);

  function Autocomplete(element, configuration) {
    var _this = _super.call(this, element) || this;

    _this._input = _this.element.querySelector("input");
    _this._dropdown = _this.element.querySelector(QUERY_DROPDOWN); // Setup event context

    _this._clickHandler = _this._handleClick.bind(_this);
    _this._windowClickHandler = _this._handleWindowClick.bind(_this);
    _this._keyUpHandler = _this._handleKeyUp.bind(_this);
    _this._keyDownHandler = _this._handleKeyDown.bind(_this);
    _this._blurHandler = _this._handleBlur.bind(_this);

    if (configuration) {
      _this._minChars = configuration.minChars;
      _this._source = configuration.source;
    }

    if (!_this._minChars || _this._minChars < 0) {
      _this._minChars = 2;
    }

    _this._initialize();

    return _this;
  }
  /**
   * Initializes the Autocomplete component.
   * @private
   */


  Autocomplete.prototype._initialize = function () {
    this._clearSuggestions();

    if (this._input.getAttribute("disabled")) {
      this.disable();
    } else {
      this.enable();
    } // Disable browser autofill


    this._input.setAttribute("autocomplete", "off");
  };
  /**
   * The Autocomplete component configuration object
   * @callback Autocomplete~Suggest
   * @property {String} term - The current search term.
   * @property {String[]} matches - The list of matching strings.
   */

  /**
   * The Autocomplete component configuration object
   * @callback Autocomplete~Source
   * @property {String} term - The current search term.
   * @property {Autocomplete~Suggest} suggest - The autocomplete callback function to report the results.
   */

  /**
   * The Autocomplete component configuration object
   * @typedef {Object} Autocomplete~Config
   * @property {Number} minChars - The minimal required characters to start querying for autocomplete matches.
   * @property {Autocomplete~Source} source - The autocomplete source function.
   */

  /**
   * Updates the autocomplete component configuration for the current instance
   * @param {Autocomplete~Config} configuration The configuration object
   */


  Autocomplete.prototype.configure = function (configuration) {
    if (!configuration) {
      return;
    }

    if (configuration.minChars) {
      this._minChars = Math.min(configuration.minChars, 1);
    }

    if (configuration.source) {
      this._source = configuration.source;
    }

    this._clearSuggestions();
  };
  /**
   * Sets the select control to the enabled state.
   */


  Autocomplete.prototype.enable = function () {
    if (!this._input) {
      return;
    }

    this._input.removeAttribute("disabled");

    this._input.addEventListener("keyup", this._keyUpHandler);

    this._input.addEventListener("keydown", this._keyDownHandler);

    this._input.addEventListener("blur", this._blurHandler);
  };
  /**
   * Sets the select control to the disabled state.
   */


  Autocomplete.prototype.disable = function () {
    if (!this._input) {
      return;
    }

    this._input.setAttribute("disabled", "true");

    this._input.removeEventListener("keyup", this._keyUpHandler);

    this._input.removeEventListener("keydown", this._keyDownHandler);

    this._input.removeEventListener("blur", this._blurHandler);

    this.close();
  };
  /**
   * Destroys the component and frees all references.
   */


  Autocomplete.prototype.destroy = function () {
    this.disable();
    this._keyUpHandler = undefined;
    this._keyDownHandler = undefined;
    this._windowClickHandler = undefined;
    this._blurHandler = undefined;
    this._input = undefined;
  };
  /**
   * Closes the suggestions dropdown.
   */


  Autocomplete.prototype.open = function () {
    this._dropdown.addEventListener("click", this._clickHandler);

    window.addEventListener("click", this._windowClickHandler);
    this.addClass(CLASS_OPEN);
  };
  /**
   * Opens the suggestions dropdown.
   */


  Autocomplete.prototype.close = function () {
    this._dropdown.removeEventListener("click", this._clickHandler);

    window.removeEventListener("click", this._windowClickHandler);
    this.removeClass(CLASS_OPEN);
  };

  Object.defineProperty(Autocomplete.prototype, "value", {
    /**
     * Gets the value of the input field.
     * @returns {String} The value of the input field.
     */
    get: function get() {
      return this._input.value;
    },
    enumerable: false,
    configurable: true
  });

  Autocomplete.prototype._handleClick = function (event) {
    if (!this._isDropdownTarget(event.target)) {
      return;
    }

    var current = event.target;

    while (current.nodeName !== "LI" && current.parentNode) {
      current = current.parentNode;
    }

    if (current.nodeName === "LI") {
      (0, _Utils.preventDefault)(event);

      this._selectItem(current);
    }
  };

  Autocomplete.prototype._handleBlur = function () {
    var _this = this;

    setTimeout(function () {
      _this.close();
    }, TIMEOUT_BLUR);
  };

  Autocomplete.prototype._handleKeyUp = function (evt) {
    var keycode = evt.which || evt.keyCode;

    if (Inputs.containsKey(keycode, [Inputs.KEY_ARROW_UP, Inputs.KEY_ARROW_DOWN, Inputs.KEY_ENTER, Inputs.KEY_TAB])) {
      // Do not handle these events on keyup
      (0, _Utils.preventDefault)(evt);
      return;
    }

    var target = evt.currentTarget;

    if (evt.currentTarget && target.value && target.value.length >= this._minChars) {
      this._getSuggestion(target.value);
    } else {
      this.close();
    }
  };

  Autocomplete.prototype._handleKeyDown = function (evt) {
    var keycode = evt.which || evt.keyCode;
    var isOpen = (0, _DomFunctions.hasClass)(this.element, CLASS_OPEN);

    if (keycode === Inputs.KEY_ESCAPE && isOpen === true) {
      // handle Escape key (ESC)
      this.close();
      (0, _Utils.preventDefault)(evt);
      return;
    }

    if (isOpen === true && Inputs.containsKey(keycode, [Inputs.KEY_ENTER, Inputs.KEY_TAB])) {
      var focusedElement = this._suggestionList.querySelector("." + CLASS_HOVER);

      (0, _Utils.preventDefault)(evt);

      this._selectItem(focusedElement);

      return;
    }

    if (isOpen === true && Inputs.containsKey(keycode, [Inputs.KEY_ARROW_UP, Inputs.KEY_ARROW_DOWN])) {
      // Up and down arrows
      var focusedElement = this._suggestionList.querySelector("." + CLASS_HOVER);

      if (focusedElement) {
        (0, _DomFunctions.removeClass)(focusedElement, CLASS_HOVER);
        var children = Array.prototype.slice.call(this._suggestionList.childNodes);
        var totalNodes = children.length - 1;
        var direction = keycode === Inputs.KEY_ARROW_UP ? -1 : 1;
        var index = children.indexOf(focusedElement);
        index = Math.max(Math.min(index + direction, totalNodes), 0);
        focusedElement = this._suggestionList.childNodes[index];
      } else {
        focusedElement = this._suggestionList.querySelector("li");
      }

      (0, _DomFunctions.addClass)(focusedElement, CLASS_HOVER);
      (0, _Utils.preventDefault)(evt);
      return;
    }
  };

  Autocomplete.prototype._handleWindowClick = function (event) {
    if (this._isDropdownTarget(event.target)) {
      return;
    }

    this.close();
  };

  Autocomplete.prototype._selectItem = function (item) {
    if (!item) {
      return;
    }

    var text = item.getAttribute(ATTRIBUTE_VALUE);

    if (text) {
      this._input.value = text; // Dispatch the changed event

      this.dispatchEvent("change");
    }

    this.close();
  };

  Autocomplete.prototype._isDropdownTarget = function (target) {
    var current = target;

    while (current !== this._dropdown && current.parentNode) {
      current = current.parentNode;
    }

    return current === this._dropdown;
  };

  Autocomplete.prototype._clearSuggestions = function () {
    // Clear the dropdown item
    (0, _DomFunctions.empty)(this._dropdown);
    this._suggestionList = document.createElement("ul");

    this._dropdown.appendChild(this._suggestionList);
  };

  Autocomplete.prototype._addSuggestion = function (text, term) {
    var sanitizedTerm = term.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&");
    var html = text.replace(new RegExp("(" + sanitizedTerm + ")", "gi"), "<strong>$1</strong>");
    var textElement = new _DomElement["default"]("span").setHtml(html);
    var innerElement = new _DomElement["default"]("div").addClass(CLASS_RESULT).appendChild(textElement);
    var liElement = new _DomElement["default"]("li").setAttribute(ATTRIBUTE_VALUE, text).appendChild(innerElement);

    this._suggestionList.appendChild(liElement.element);
  };

  Autocomplete.prototype._getSuggestion = function (term) {
    var _this = this;

    if (!this._source) {
      throw new Error("The source function is undefined, cannot load suggestions");
    }

    this._source(term, function (matches, termused) {
      _this._onMatchesReceived(matches, termused);
    });
  };

  Autocomplete.prototype._onMatchesReceived = function (matches, term) {
    var e_1, _a;

    this._clearSuggestions();

    if (!matches || matches.length === 0) {
      this.close();
    } else {
      // Clear the dropdown item
      (0, _DomFunctions.empty)(this._suggestionList);

      try {
        for (var matches_1 = (0, _tslib.__values)(matches), matches_1_1 = matches_1.next(); !matches_1_1.done; matches_1_1 = matches_1.next()) {
          var match = matches_1_1.value;

          this._addSuggestion(match, term);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (matches_1_1 && !matches_1_1.done && (_a = matches_1["return"])) _a.call(matches_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }

      this.open();
    }
  };

  return Autocomplete;
}(_DomElement["default"]);
/**
 * Change event
 *
 * @event Autocomplete#change
 * @type {object}
 */


function init() {
  (0, _Utils.searchAndInitialize)(".input-field--autocomplete", function (e) {
    new Autocomplete(e);
  });
}

var _default = Autocomplete;
exports["default"] = _default;

},{"../DomElement":4,"../DomFunctions":5,"../Inputs":6,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"@babel/runtime/helpers/interopRequireWildcard":34,"tslib":43}],17:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _Utils = require("../Utils");

var _DomElement = _interopRequireDefault(require("../DomElement"));

var _flatpickr = _interopRequireDefault(require("flatpickr"));

var _it = require("flatpickr/dist/l10n/it.js");

var _fr = require("flatpickr/dist/l10n/fr.js");

var _de = require("flatpickr/dist/l10n/de.js");

_flatpickr["default"].localize(_it.Italian);

_flatpickr["default"].localize(_fr.French);

_flatpickr["default"].localize(_de.German);

var DEFAULTS_FLATPICKR = {
  wrap: true,
  allowInput: true,
  locale: "de",
  dateFormat: "d.m.Y",
  time_24hr: true
};
var CLASS_HAS_VALUE = "is-fixed";
var CLASS_MESSAGE = ".message";
/**
 * Input field component
 */

var InputField =
/** @class */
function (_super) {
  (0, _tslib.__extends)(InputField, _super);

  function InputField(element, datePickerOptions) {
    var _this = _super.call(this, element) || this;

    _this._changedHandler = _this.onValueChanged.bind(_this);
    _this._animationStartHandler = _this._onAnimationStart.bind(_this);
    _this._datePickerOptions = datePickerOptions;

    _this._initialize();

    return _this;
  }
  /**
   * Initializes the input field component.
   * @private
   */


  InputField.prototype._initialize = function () {
    this.element.addEventListener("input", this._changedHandler);

    if (this.element.getAttribute("type") === "password") {
      this.element.addEventListener("animationstart", this._animationStartHandler);
    }

    this._initializeDatePicker();

    this.onValueChanged();
  };

  InputField.prototype._initializeDatePicker = function () {
    var picker = this.element.parentElement;

    if (!picker || !picker.classList.contains("flatpickr")) {
      return;
    }

    if (!this._datePickerOptions) {
      try {
        this._datePickerOptions = JSON.parse(picker.dataset.options || "{}");
      } catch (e) {
        this._datePickerOptions = {}; // tslint:disable-next-line:no-console

        console.warn("_initializeDatePicker JSON.parse failed", picker.dataset.options, e);
      }
    }

    this._flatpickrInstance = (0, _flatpickr["default"])(picker, Object.assign({}, DEFAULTS_FLATPICKR, this._datePickerOptions));
  };

  InputField.prototype._destroyDatePicker = function () {
    if (this._flatpickrInstance) {
      this._flatpickrInstance.destroy();
    }
  };

  InputField.prototype._onAnimationStart = function (e) {
    if (e.animationName === "onAutoFillStart") {
      this.onValueChanged(true);
    }
  };
  /**
   * Notifies the input field component that it's value has been changed.
   */


  InputField.prototype.onValueChanged = function (force) {
    if (force === void 0) {
      force = false;
    }

    if (this.element.value && this.element.value !== "" || force === true) {
      this.addClass(CLASS_HAS_VALUE);
    } else {
      this.removeClass(CLASS_HAS_VALUE);
      this.element.value = "";
    }
  };
  /**
   * Destroys the component and frees all references.
   */


  InputField.prototype.destroy = function () {
    this.element.removeEventListener("input", this._changedHandler);

    if (this.element.getAttribute("type") === "password") {
      this.element.removeEventListener("animationstart", this._animationStartHandler);
    }

    this._changedHandler = undefined;
    this._animationStartHandler = undefined;

    this._destroyDatePicker();
  };
  /**
   * Displays the specified error text underneath the input field.
   * @param {text} text The error text/html to display; or undefined to hide the message.
   */


  InputField.prototype.showError = function (text) {
    var message;

    if (this.element.parentElement) {
      var msg_1 = this.element.parentElement.querySelector(CLASS_MESSAGE);

      if (msg_1) {
        message = new _DomElement["default"](msg_1);
      }
    }

    if (!text || text === "") {
      if (message) {
        (0, _Utils.remove)(message.element);
      }

      this.removeClass("invalid");
      return;
    }

    this.addClass("invalid");

    if (!message) {
      message = new _DomElement["default"]("div").addClass("message");
      this.element.parentElement.appendChild(message.element);
    } else {
      message.empty();
    }

    var icon = new _DomElement["default"]("i").addClass("icon").addClass("icon-026-exclamation-mark-circle").setAttribute("aria-hidden", "true");
    var msg = new _DomElement["default"]("span").setHtml(text);
    message.appendChild(icon);
    message.appendChild(msg);
  };

  return InputField;
}(_DomElement["default"]);

function init() {
  (0, _Utils.searchAndInitialize)(".input-field input", function (e) {
    new InputField(e);
  }, function (e) {
    return e.parentElement;
  });
}

var _default = InputField;
exports["default"] = _default;

},{"../DomElement":4,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"flatpickr":38,"flatpickr/dist/l10n/de.js":39,"flatpickr/dist/l10n/fr.js":40,"flatpickr/dist/l10n/it.js":41,"tslib":43}],18:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _animejs = _interopRequireDefault(require("animejs"));

var _Utils = require("../Utils");

var Inputs = _interopRequireWildcard(require("../Inputs"));

var _DomElement = _interopRequireDefault(require("../DomElement"));

var MARGIN_TICK = 32;
var CLASS_HTML5 = "html5";
var RANGE_LIGHT = "range--light";
var CLASS_CONTAINER = "range-container";
var CLASS_SLIDER = "range-slider";
var CLASS_ACTIVE = "range--active";
var CLASS_TRACK = "range-track";
var CLASS_TRACK_PROGRESS = "range-track__progress";
var CLASS_TICK = "range-tick";
var CLASS_TICK_LABEL = "range-tick__label";
var CLASS_TICK_ACTIVE = "range-tick--active";
var CLASS_THUMB = "range-thumb";
var CLASS_THUMB_VALUE = "range-thumb__value";
var CLASS_DISABLED = "range--disabled";
var CLASS_DRAGGING = "range--dragging";
/**
 * The range slider component definition.
 */

var Range =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Range, _super);

  function Range(element) {
    var _this = _super.call(this, element) || this; // Setup event context


    _this._downHandler = _this._handleDown.bind(_this);
    _this._moveHandler = _this._handleMove.bind(_this);
    _this._endHandler = _this._handleEnd.bind(_this);
    _this._keydownHandler = _this._handleKeydown.bind(_this);
    _this._focusHandler = _this._handleFocus.bind(_this);
    _this._blurHandler = _this._handleBlur.bind(_this);
    _this._resizeHandler = _this.layout.bind(_this);

    _this._initialize();

    if (_this.element.disabled) {
      _this.disable();
    } else {
      _this.enable();
    }

    return _this;
  }
  /**
   * Initializes the range slider component.
   *
   * This method inspects the select definition and its options and
   * generates new stylable DOM elements around the original range input-element
   * definitions.
   * @private
   */


  Range.prototype._initialize = function () {
    if (this.hasClass(CLASS_HTML5)) {
      // This element uses HTML5 styling, do not touch it...
      return;
    }

    this._wrapperElement = new _DomElement["default"](this.element.parentElement);
    this._rangeContainer = new _DomElement["default"]("div").addClass(CLASS_CONTAINER);
    this._rangeTrack = new _DomElement["default"]("div").addClass(CLASS_TRACK); // check if range--light slider then add progress

    if (this._wrapperElement.hasClass(RANGE_LIGHT)) {
      this._rangeProgress = new _DomElement["default"]("div").addClass(CLASS_TRACK_PROGRESS);

      this._rangeTrack.appendChild(this._rangeProgress);
    }

    this._rangeThumb = new _DomElement["default"]("div").addClass(CLASS_THUMB);
    this._ticksWrapper = new _DomElement["default"]("div").addClass(CLASS_SLIDER);

    this._rangeContainer.appendChild(this._rangeTrack);

    this._rangeContainer.appendChild(this._ticksWrapper);

    this._rangeContainer.appendChild(this._rangeThumb); // add container to wrapper


    this._wrapperElement.appendChild(this._rangeContainer); // get min & max definitions


    this._minValue = parseFloat(this.element.min) || 0;
    this._maxValue = parseFloat(this.element.max) || 1; // get the label/output format string

    this._formatter = window[this.getAttribute("formatter")]; // get the output label and move it below the container

    if (this.element.id) {
      this._outputLabel = this._wrapperElement.find("output[for='" + this.element.id + "']");

      if (this._outputLabel) {
        this._wrapperElement.appendChild(this._outputLabel);
      }
    }

    if (!this.element.step) {
      // fix issues with float sliders if the step is undefined
      this.element.step = "any";
    }

    var options = this._getOptionsList();

    if (options && options.length) {
      this._addTicks(options);
    }

    if (this._rangeContainer.element.querySelectorAll("." + CLASS_TICK_LABEL).length <= 1) {
      this._thumbValue = new _DomElement["default"]("div").addClass(CLASS_THUMB_VALUE);

      this._rangeThumb.appendChild(this._thumbValue);
    }

    this._trackValueTotal = this._maxValue - this._minValue;
    this.layout();

    this._updateTickState(); // Apply the tab index


    var tabIndex = this.element.getAttribute("tabindex");

    if (tabIndex) {
      this._rangeContainer.setAttribute("tabindex", tabIndex);
    }

    window.addEventListener("resize", this._resizeHandler);
    window.addEventListener("orientationchange", this._resizeHandler);
  };

  Range.prototype._getOptionsList = function () {
    var e_1, _a;

    var options = [];
    var listId = this.getAttribute("list");

    if (listId) {
      var dataList = document.querySelector("#" + listId);

      if (dataList) {
        try {
          for (var _b = (0, _tslib.__values)(dataList.querySelectorAll("option")), _c = _b.next(); !_c.done; _c = _b.next()) {
            var entry = _c.value;
            var value = parseFloat(entry.innerText);
            var label = entry.getAttribute("label") || parseFloat(value.toFixed(2));
            options.push({
              value: value,
              label: label
            });
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    } // Sort the list to enable snapping


    options = options.sort(function (a, b) {
      return a.value - b.value;
    });

    if (options.length > 1) {
      this._minValue = Number.MAX_VALUE;
      this._maxValue = Number.MIN_VALUE;

      for (var i = 0; i < options.length; i++) {
        this._minValue = Math.min(this._minValue, options[i].value);
        this._maxValue = Math.max(this._maxValue, options[i].value);
      }
    }

    return options;
  };

  Range.prototype._addTicks = function (dataItems) {
    var e_2, _a;

    try {
      for (var dataItems_1 = (0, _tslib.__values)(dataItems), dataItems_1_1 = dataItems_1.next(); !dataItems_1_1.done; dataItems_1_1 = dataItems_1.next()) {
        var entry = dataItems_1_1.value;
        var tickElement = new _DomElement["default"]("div").setAttribute("data-value", String(entry.value)).addClass(CLASS_TICK);
        var tickLabel = new _DomElement["default"]("span").addClass(CLASS_TICK_LABEL).setHtml(String(entry.label));
        tickElement.appendChild(tickLabel);

        this._ticksWrapper.appendChild(tickElement);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (dataItems_1_1 && !dataItems_1_1.done && (_a = dataItems_1["return"])) _a.call(dataItems_1);
      } finally {
        if (e_2) throw e_2.error;
      }
    }
  };

  Range.prototype._isEventOnLabel = function (event) {
    var el = event.target;
    return !!(el === null || el === void 0 ? void 0 : el.classList.contains(CLASS_TICK_LABEL));
  };

  Range.prototype._handleDown = function (event) {
    this._wrapperElement.addClass(CLASS_DRAGGING);

    this._rangeContainer.element.addEventListener("mouseup", this._endHandler);

    document.addEventListener("mousemove", this._moveHandler);
    document.addEventListener("mouseup", this._endHandler);

    this._rangeContainer.element.addEventListener("touchmove", this._moveHandler);

    document.addEventListener("touchend", this._endHandler); // Ignore clicks directly on the thumb

    if (event.target !== this._rangeThumb.element && !this._isEventOnLabel(event)) {
      var pos = this._getRelativePosition(event);

      this._setPosition(pos, true, false, false);
    }
  };

  Range.prototype._handleMove = function (event) {
    (0, _Utils.preventDefault)(event);

    this._unfocus();

    if (!this._isEventOnLabel(event)) {
      var pos = this._getRelativePosition(event);

      this._setPosition(pos, true, false, false);
    }
  };

  Range.prototype._handleEnd = function (event) {
    this._wrapperElement.removeClass(CLASS_DRAGGING);

    this._rangeContainer.element.removeEventListener("mouseup", this._endHandler);

    document.removeEventListener("mouseup", this._endHandler);
    document.removeEventListener("mousemove", this._moveHandler);

    this._rangeContainer.element.removeEventListener("touchmove", this._moveHandler);

    document.removeEventListener("touchend", this._endHandler);

    var pos = this._getRelativePosition(event);

    this._setPosition(pos, true, true, true);

    this._handleBlur();
  };

  Range.prototype._handleKeydown = function (event) {
    var keycode = event.which || event.keyCode;

    if (keycode === Inputs.KEY_ESCAPE) {
      // handle Escape key (ESC)
      this._rangeContainer.element.blur();

      return;
    }

    var isUp = keycode === Inputs.KEY_ARROW_UP || keycode === Inputs.KEY_ARROW_RIGHT || keycode === Inputs.KEY_PAGE_UP;
    var isDown = keycode === Inputs.KEY_ARROW_DOWN || keycode === Inputs.KEY_ARROW_LEFT || keycode === Inputs.KEY_PAGE_DOWN;

    if (isUp || isDown) {
      event.preventDefault();
      var direction = isDown ? -1 : 1; // make a larger step if its the vertical arrow or page keys

      if (keycode === Inputs.KEY_ARROW_UP || keycode === Inputs.KEY_ARROW_DOWN || keycode === Inputs.KEY_PAGE_UP || keycode === Inputs.KEY_PAGE_DOWN) {
        direction *= 10;
      }

      var val = this.value;

      if (this._ticksWrapper.element.childNodes.length > 1) {
        val = this._getNextValue(val, direction);
      } else {
        var step = this.element.step;

        if (!step || step === "any") {
          step = "0.1";
        }

        var newVal = val + parseFloat(step) * direction;
        val = newVal;
      }

      this._setValue(val, true, true);

      return;
    }
  };

  Range.prototype._handleFocus = function () {
    this._rangeContainer.addClass(CLASS_ACTIVE);
  };

  Range.prototype._handleBlur = function () {
    this._rangeContainer.removeClass(CLASS_ACTIVE);
  };

  Range.prototype._unfocus = function () {
    if (document.selection) {
      document.selection.empty();
    } else {
      window.getSelection().removeAllRanges();
    }
  };

  Range.prototype._getRelativePosition = function (event) {
    var pageX;

    if ("pageX" in event) {
      pageX = event.pageX;
    } else {
      pageX = (event.touches[0] || event.changedTouches[0]).pageX;
    }

    return pageX - this._trackLeftPosition + this._grabPosition;
  };
  /**
   * Validates and updates the position and sets the corresponding value on the slider.
   * @param {position} the new position to set.
   * @param {updateValue} true if the value should be updated as well; otherwise false.
   * @param {snap} true if snapping should be used; otherwise false.
   * @param {animate} true if the UI update should be animated; otherwise false.
   * @private
   */


  Range.prototype._setPosition = function (position, updateValue, snap, animate) {
    if (updateValue === void 0) {
      updateValue = true;
    }

    if (snap === void 0) {
      snap = false;
    }

    if (animate === void 0) {
      animate = true;
    }

    if (position === undefined || position === null || Number.isNaN(position)) {
      throw new Error("Position is not a number");
    } // Clamp to min and max range


    var newPos = (0, _Utils.clamp)(position, this._trackPositionMin, this._trackPositionMax);

    if (updateValue) {
      var value = this._trackValueTotal / this._trackWidth * newPos + this._minValue;

      if (this._ticksWrapper.element.childNodes.length > 1 && snap) {
        var snapPos = this._getSnapPosition(newPos);

        newPos = snapPos.position;
        value = snapPos.value;
      } else if (this.element.step && this.element.step !== "any") {
        var step = parseFloat(this.element.step);
        value = Math.round(value / step) * step;
      }

      this._setValue(value, false, false);
    }

    if (animate && updateValue) {
      this._updateTickState();
    }

    if (animate) {
      (0, _animejs["default"])({
        targets: this._rangeThumb.element,
        duration: 200,
        left: newPos,
        easing: "easeInOutQuint"
      });

      if (this._rangeProgress) {
        (0, _animejs["default"])({
          targets: this._rangeProgress.element,
          duration: 200,
          width: newPos,
          easing: "easeInOutQuint"
        });
      }
    } else {
      this._rangeThumb.element.style.left = newPos + "px";

      if (this._rangeProgress) {
        this._rangeProgress.element.style.width = newPos + "px";
      }
    }
  };
  /**
   * Gets the snap value corresponding to the given value.
   * @param {value} the target value.
   * @returns an object containing the snap position and the corresponding value.
   * @private
   */


  Range.prototype._getSnapValue = function (value) {
    var ticks = this._ticksWrapper.element.children;
    var currentPosition = 0;

    for (var i = 0; i < ticks.length; i++) {
      var currentElement = new _DomElement["default"](ticks[i]);
      var currentValue = parseFloat(currentElement.getAttribute("data-value"));
      var currentWidth = currentElement.element.clientWidth;
      var nextElement = void 0;
      var nextValue = Number.MAX_VALUE;

      if (i < ticks.length - 1) {
        nextElement = new _DomElement["default"](ticks[i + 1]);
        nextValue = parseFloat(nextElement.getAttribute("data-value"));
      } // left most element


      if (i === 0 && value <= currentValue) {
        return {
          value: currentValue,
          position: MARGIN_TICK - this._grabPosition
        };
      } // right most element


      if (!nextElement && value >= currentValue) {
        return {
          value: currentValue,
          position: currentPosition + (currentWidth - MARGIN_TICK) - this._grabPosition - 1
        };
      }

      if (value >= currentValue && value < nextValue) {
        return {
          value: currentValue,
          position: currentPosition + 0.5 * currentWidth - this._grabPosition
        };
      }

      currentPosition += currentWidth;
    }

    throw new Error("Could not determine snap value");
  };
  /**
   * Gets the snap position corresponding to the given position.
   * @param {position} the target position.
   * @returns an object containing the snap position and the corresponding value.
   * @private
   */


  Range.prototype._getSnapPosition = function (position) {
    if (position === undefined || position === null || Number.isNaN(position)) {
      throw new Error("position is not a number");
    }

    var ticks = this._ticksWrapper.element.children;
    var currentPosition = 0;

    for (var i = 0; i < ticks.length; i++) {
      var currentElement = new _DomElement["default"](ticks[i]);
      var currentValue = parseFloat(currentElement.getAttribute("data-value"));
      var currentWidth = currentElement.element.clientWidth;
      var nextElement = void 0;

      if (i < ticks.length - 1) {
        nextElement = new _DomElement["default"](ticks[i + 1]);
      } // left most element


      if (i === 0 && position <= currentPosition + currentWidth) {
        return {
          value: currentValue,
          position: MARGIN_TICK - this._grabPosition
        };
      } // right most element


      if (!nextElement && position >= currentPosition) {
        return {
          value: currentValue,
          position: currentPosition + (currentWidth - MARGIN_TICK) - this._grabPosition - 1
        };
      }

      if (position >= currentPosition && position < currentPosition + currentWidth) {
        return {
          value: currentValue,
          position: currentPosition + 0.5 * currentWidth - this._grabPosition
        };
      }

      currentPosition += currentWidth;
    } // No ticks found (e.g. for "Free Slider")


    return {
      value: 0,
      position: 0
    };
  };
  /**
   * Gets the next value in the given direction with regards to snapping.
   * @param {value} The current value.
   * @param {direction} The direction (positive or negative integer).
   * @returns The next value.
   * @private
   */


  Range.prototype._getNextValue = function (value, direction) {
    var ticks = this._ticksWrapper.element.children;

    for (var i = 0; i < ticks.length; i++) {
      var currentElement = new _DomElement["default"](ticks[i]);
      var currentVal = parseFloat(currentElement.getAttribute("data-value"));

      if (value === currentVal) {
        var index = (0, _Utils.clamp)(i + direction, 0, ticks.length - 1);
        value = parseFloat(ticks[index].getAttribute("data-value"));
      }
    }

    return value;
  };

  Range.prototype._updateTickState = function () {
    if (this._ticksWrapper.element.childNodes.length > 1) {
      var activeTick = this._ticksWrapper.find("." + CLASS_TICK_ACTIVE);

      if (activeTick) {
        activeTick.removeClass(CLASS_TICK_ACTIVE);
      }

      var newActiveTick = this._ticksWrapper.find("." + CLASS_TICK + "[data-value='" + this.value + "']");

      if (newActiveTick) {
        newActiveTick.addClass(CLASS_TICK_ACTIVE);
      }
    }
  };

  Range.prototype._adjustTickLabelPosition = function (tickItem, left) {
    var label = new _DomElement["default"](tickItem.querySelector("." + CLASS_TICK_LABEL));
    var dummyElement = new _DomElement["default"]("span").addClass(CLASS_TICK_LABEL).setAttribute("style", "visibility: hidden; display: inline-block;").setHtml(label.innerText);

    this._rangeContainer.appendChild(dummyElement);

    var width = dummyElement.element.clientWidth / 2;

    this._rangeContainer.removeChild(dummyElement);

    var floatPosition = left ? "left" : "right";

    if (width < MARGIN_TICK) {
      // center small items on the tick
      label.setAttribute("style", floatPosition + ": " + (MARGIN_TICK - Math.floor(width)) + "px; text-align: " + floatPosition + ";");
    }
  };

  Range.prototype._formatOutput = function (value, _short) {
    if (this._formatter) {
      return this._formatter(value, _short);
    }

    var str = parseFloat(value.toFixed(2));
    return str.toString();
  };
  /**
   * Validates and updates the range value.
   * @param {value} the new value to set.
   * @param {update} true if the UI should be updated; otherwise false.
   * @param {animate} true if the UI update should be animated; otherwise false.
   * @private
   */


  Range.prototype._setValue = function (value, update, animate) {
    if (update === void 0) {
      update = true;
    }

    if (animate === void 0) {
      animate = false;
    }

    var val = (0, _Utils.clamp)(value, this._minValue, this._maxValue);
    var position;

    if (this._ticksWrapper.element.childNodes.length > 1) {
      // at least 2 ticks present
      var snapValue = this._getSnapValue(val);

      position = snapValue.position;
      val = snapValue.value;
    } else if (this._ticksWrapper.element.childNodes.length === 1) {
      // only 1 tick present
      // This shouldn't happen (but it does, e.g. when generating Sliders based on incomplete data).
      // Fall back to the first tick position and disable the component.
      position = this._getSnapPosition(val).position;
      this.disable();
    } else {
      // no ticks present, e.g. "Free Slider"
      position = this._trackWidth / this._trackValueTotal * (value - this._minValue);
    }

    this.element.value = String(val);

    if (this._thumbValue) {
      this._thumbValue.setHtml(this._formatOutput(val, true));
    }

    if (this._outputLabel) {
      this._outputLabel.setHtml(this._formatOutput(val, false));
    }

    if (update) {
      this._setPosition(position, false, false, animate);

      this._updateTickState();
    }

    this.dispatchEvent("input");
  };

  Object.defineProperty(Range.prototype, "value", {
    /**
     * Gets the current value.
     */
    get: function get() {
      return parseFloat(this.element.value);
    },

    /**
     * Sets the value of the range slider.
     */
    set: function set(value) {
      this._setValue(value, true, true);
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Force the component to re-layout itself.
   */

  Range.prototype.layout = function () {
    this._grabPosition = Math.round(this._rangeThumb.element.offsetWidth / 2);

    var tickItems = this._rangeContainer.element.querySelectorAll("." + CLASS_TICK);

    var ticksOffset = tickItems && tickItems.length > 0 ? 2 * MARGIN_TICK : MARGIN_TICK;
    this._trackWidth = this._rangeTrack.element.offsetWidth - ticksOffset;
    this._trackPositionMin = 0;
    this._trackPositionMax = this._rangeTrack.element.clientWidth - this._rangeThumb.element.offsetWidth + 1;
    this._trackLeftPosition = this._rangeTrack.element.getBoundingClientRect().left + MARGIN_TICK;
    var itemCount = tickItems.length - 1;
    this._itemWidth = this._trackWidth / itemCount;
    var outerItemsWidth = this._itemWidth * 0.5 + MARGIN_TICK;

    for (var i = 0; i <= itemCount; i++) {
      var width = this._itemWidth;

      if (i === 0 || i === itemCount) {
        width = outerItemsWidth;
      }

      var item = new _DomElement["default"](tickItems[i]);
      item.setAttribute("style", "width: " + Math.floor(width) + "px;");
    } // adjust first and last label positions


    if (tickItems.length > 1) {
      this._adjustTickLabelPosition(tickItems[0], true);

      this._adjustTickLabelPosition(tickItems[tickItems.length - 1], false);
    } // update the value


    this._setValue(parseFloat(this.element.value), true, false);
  };
  /**
   * Destroys the components and frees all references.
   */


  Range.prototype.destroy = function () {
    window.removeEventListener("resize", this._resizeHandler);
    window.removeEventListener("orientationchange", this._resizeHandler);
    this._downHandler = null;
    this._moveHandler = null;
    this._endHandler = null;
    this._focusHandler = null;
    this._blurHandler = null;
    this.element = null;
    this._rangeContainer = null;
    this._wrapperElement = null;
  };
  /**
   * @deprecated use destroy() instead.
   * @todo remove in version 2.0.0
   */


  Range.prototype.destoy = function () {
    this.destroy();
  };
  /**
   * Sets the component to the enabled state.
   */


  Range.prototype.enable = function () {
    this.element.removeAttribute("disabled");

    this._wrapperElement.removeClass(CLASS_DISABLED);

    this._rangeContainer.element.addEventListener("mousedown", this._downHandler);

    this._rangeContainer.element.addEventListener("touchstart", this._downHandler);

    this._rangeContainer.element.addEventListener("keydown", this._keydownHandler);

    this._rangeContainer.element.addEventListener("focus", this._focusHandler);

    this._rangeContainer.element.addEventListener("blur", this._blurHandler);
  };
  /**
   * Sets the component to the disabled state.
   */


  Range.prototype.disable = function () {
    this.element.setAttribute("disabled", "");

    this._wrapperElement.addClass(CLASS_DISABLED);

    this._rangeContainer.element.removeEventListener("mousedown", this._downHandler);

    this._rangeContainer.element.removeEventListener("mouseup", this._endHandler);

    this._rangeContainer.element.removeEventListener("mousemove", this._moveHandler);

    this._rangeContainer.element.removeEventListener("touchstart", this._downHandler);

    this._rangeContainer.element.removeEventListener("focus", this._focusHandler);

    this._rangeContainer.element.removeEventListener("blur", this._blurHandler);
  };

  return Range;
}(_DomElement["default"]);

function init() {
  (0, _Utils.searchAndInitialize)("input[type='range']", function (e) {
    new Range(e);
  });
}

var _default = Range;
exports["default"] = _default;

},{"../DomElement":4,"../Inputs":6,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"@babel/runtime/helpers/interopRequireWildcard":34,"animejs":36,"tslib":43}],19:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _Utils = require("../Utils");

var _DomElement = _interopRequireDefault(require("../DomElement"));

var Inputs = _interopRequireWildcard(require("../Inputs"));

var Dom = _interopRequireWildcard(require("../DomFunctions"));

var CLASS_PLACEHOLDER = "select__placeholder";
var CLASS_THUMB = "select__thumb";
var CLASS_BUTTON = "select__button";
var CLASS_DROPDOWN = "select__dropdown";
var CLASS_OPEN = "select--open";
var CLASS_CLOSED = "select--closed";
var CLASS_DISABLED = "select--disabled";
var CLASS_FILTERABLE = "select--filterable";
var CLASS_ITEM = "dropdown-item";
var CLASS_ITEM_SELECTED = "dropdown-item--selected";
var CLASS_ITEM_FOCUSED = "dropdown-item--focused";
var CLASS_ITEM_DISABLED = "dropdown-item--disabled";
var CLASS_GROUP_ITEM = "dropdown-group";
var CLASS_GROUP_HEADER = "dropdown-group__item";
var QUERY_MESSAGE = ".message";
var TIMEOUT_CLOSE = 150;
var TIMEOUT_BLUR = 400;
/**
 * The select component API.
 */

var Select =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Select, _super);

  function Select(element) {
    var _this = _super.call(this, element) || this; // Minimum filter length


    _this._minFilterLength = 2; // The options the Select was initially created upon
    // These will be used as a basis for filtering

    _this._initialOptions = Array.prototype.slice.call(_this.element.children);
    _this._openByFocus = false; // Check for multi-selection

    _this._multiselection = _this.element.hasAttribute("multiple") === true; // Setup event context

    _this._clickHandler = _this._handleClick.bind(_this);
    _this._handleDropdownClick = _this._handleClick.bind(_this);
    _this._keydownHandler = _this._handleKeydown.bind(_this);
    _this._focusHandler = _this._handleFocus.bind(_this);
    _this._blurHandler = _this._handleBlur.bind(_this);
    _this._windowClickHandler = _this._handleWindowClick.bind(_this);
    _this._filterKeydownHandler = _this._handleFilterKeydown.bind(_this);
    _this._filterKeyupHandler = _this._handleFilterKeyup.bind(_this);
    _this._filterFocusHandler = _this._handleFilterFocus.bind(_this);

    _this._initialize();

    return _this;
  }
  /**
   * Initializes the select component.
   *
   * This method inspects the select definition and its options and
   * generates new stylable DOM elements around the original select-element
   * definitions.
   * @private
   */


  Select.prototype._initialize = function () {
    var e_1, _a;

    var selectedOption = this.element.querySelector("option[selected]");
    var firstOption = this.element.querySelector("option"); // Per default, set the last selected option to either the option with a "selected" attribute,
    // or, if not found, to the first available option

    this._lastSelectedOption = selectedOption || firstOption;
    this._wrapperElement = new _DomElement["default"](this.element.parentElement).addClass(CLASS_CLOSED);

    try {
      for (var _b = (0, _tslib.__values)(this.classes), _c = _b.next(); !_c.done; _c = _b.next()) {
        var cls = _c.value;

        this._wrapperElement.addClass(cls);
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }

    this._dropdownElement = new _DomElement["default"]("div").addClass(CLASS_DROPDOWN);

    if ((0, _Utils.internetExplorerOrEdgeVersion)() > 0 && (0, _Utils.internetExplorerOrEdgeVersion)() < 12) {
      // This is a workaround for IE browsers 11 and earlier where focusing
      // a scrollable dropdown list will close the dropdown prematurely.
      this._dropdownElement.element.addEventListener("mousedown", function (event) {
        return event.preventDefault();
      });
    }

    this._setupTarget();

    this._setupPlaceholder();

    this._wrapperElement.appendChild(this._dropdownElement);

    this._createOptions(this.element);

    this._updateSize();

    this._updateMessage();

    if (this.element.disabled) {
      this.disable();
    } else {
      this.enable();
    }
  };

  Select.prototype._setupTarget = function () {
    // move the id from the select element to the wrapper
    var id = this.element.getAttribute("id");

    if (id) {
      this.element.removeAttribute("id");

      this._wrapperElement.setAttribute("id", id);
    } // Apply the tab index


    var tabIndex = this.element.getAttribute("tabindex");

    if (tabIndex) {
      this._wrapperElement.setAttribute("tabIndex", tabIndex);
    }
  };

  Select.prototype._setupPlaceholder = function () {
    var _this = this;

    if (!this._selectButtonElement) {
      this._selectButtonElement = new _DomElement["default"]("div").addClass(CLASS_BUTTON);

      this._wrapperElement.appendChild(this._selectButtonElement);
    }

    if (!this._thumbElement) {
      this._thumbElement = new _DomElement["default"]("div").addClass(CLASS_THUMB);
      var thumbIcon = new _DomElement["default"]("div").addClass("thumb-icon");
      var loader = new _DomElement["default"]("div").addClass("loader-spinner").addClass("loader-spinner--small");

      this._thumbElement.appendChild(loader);

      this._thumbElement.appendChild(thumbIcon);

      this._selectButtonElement.appendChild(this._thumbElement);
    }

    var placeholderText = "";
    this._placeholderOption = this.element.querySelector("option[selected][disabled]") || undefined;

    if (this._placeholderOption) {
      placeholderText = Dom.text(this._placeholderOption);

      if (this._multiselection === true) {
        this._placeholderOption.selected = false;
      }
    }

    var selectedOption = this.element.querySelector("option[selected]:not([disabled])");

    if (selectedOption) {
      placeholderText = Dom.text(selectedOption);
    }

    if (!this._placeholderElement) {
      // When the Select is filterable, create an "input" as the placeholder element, otherwise a "span"
      if (this._isFilterable()) {
        this._placeholderElement = new _DomElement["default"]("input");

        this._placeholderElement.addEventListener("keyup", function (e) {
          return _this._handleFilterKeyup(e);
        });

        this._placeholderElement.addEventListener("keydown", function (e) {
          return _this._handleFilterKeydown(e);
        });

        this._placeholderElement.addEventListener("focus", function (e) {
          return _this._handleFilterFocus(e);
        });
      } else {
        this._placeholderElement = new _DomElement["default"]("span");
      }

      this._placeholderElement.addClass(CLASS_PLACEHOLDER);

      this._selectButtonElement.appendChild(this._placeholderElement);
    }

    this._setPlaceholder(placeholderText);

    this._placeholderText = placeholderText;

    if (selectedOption && selectedOption !== this._placeholderOption) {
      this._updatePlaceholder(true);
    }
  };

  Select.prototype._updateMessage = function () {
    var messageNode = this._wrapperElement.element.querySelector(QUERY_MESSAGE);

    if (messageNode !== null) {
      this._wrapperElement.appendChild(new _DomElement["default"](messageNode));
    }
  };

  Select.prototype._isOptGroup = function (element) {
    return element.tagName.toUpperCase() === "OPTGROUP";
  };

  Select.prototype._isOption = function (element) {
    return element.tagName.toUpperCase() === "OPTION";
  };

  Select.prototype._createOptions = function (element) {
    for (var i = 0; i < element.children.length; i++) {
      var child = element.children[i];

      if (this._isOptGroup(child)) {
        this._appendGroup(child);
      }

      if (this._isOption(child)) {
        var option = this._createOption(child);

        if (option) {
          this._dropdownElement.appendChild(option);
        }
      }
    }
  };

  Select.prototype._createOption = function (option) {
    var html = option.innerHTML;

    if (this._activeFilter) {
      var sanitizedActiveFilter = this._activeFilter.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&");

      html = html.replace(new RegExp("(" + sanitizedActiveFilter + ")", "gi"), "<strong>$1</strong>");
    }

    var opt = new _DomElement["default"]("div").addClass(CLASS_ITEM).setHtml(html);

    if (option.selected) {
      opt.addClass(CLASS_ITEM_SELECTED);
    }

    if (option.disabled) {
      opt.addClass(CLASS_ITEM_DISABLED);
    }

    if (!this._isPlaceholder(option)) {
      opt.setAttribute("data-value", option.value);
      return opt;
    }

    return undefined;
  };

  Select.prototype._appendGroup = function (optgroup) {
    var e_2, _a;

    var label = optgroup.getAttribute("label");
    var group = new _DomElement["default"]("div").addClass(CLASS_GROUP_ITEM);
    var groupHeader = new _DomElement["default"]("div").addClass(CLASS_GROUP_HEADER).setHtml(label);
    group.appendChild(groupHeader);
    var options = optgroup.querySelectorAll("option");

    try {
      for (var options_1 = (0, _tslib.__values)(options), options_1_1 = options_1.next(); !options_1_1.done; options_1_1 = options_1.next()) {
        var entry = options_1_1.value;

        var option = this._createOption(entry);

        if (option) {
          group.appendChild(option);
        }
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (options_1_1 && !options_1_1.done && (_a = options_1["return"])) _a.call(options_1);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    this._dropdownElement.appendChild(group);

    return group;
  };

  Select.prototype._updateSize = function () {
    var e_3, _a; // Note: Mirroring the DOM and measuring the items using their clientWidth was very
    // unreliable, therefore measuring was switched to the new HTML5 measureText method
    // margins and paddings arround the text are copied from the original placeholder items
    // dimension


    var placeholderStyle = window.getComputedStyle(this._placeholderElement.element);
    var paddingRight = parseFloat(placeholderStyle.paddingRight);
    var paddingLeft = parseFloat(placeholderStyle.paddingLeft);

    var font = this._placeholderElement.css("font");

    var textWidth = Dom.textWidth(this._placeholderText, font);
    var maxWidth = paddingLeft + paddingRight + textWidth;

    var options = this._wrapperElement.element.querySelectorAll("." + CLASS_ITEM);

    try {
      for (var options_2 = (0, _tslib.__values)(options), options_2_1 = options_2.next(); !options_2_1.done; options_2_1 = options_2.next()) {
        var entry = options_2_1.value;
        var width = Dom.textWidth(Dom.text(entry), font) + paddingLeft + paddingRight;

        if (width > maxWidth) {
          maxWidth = width;
        }
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (options_2_1 && !options_2_1.done && (_a = options_2["return"])) _a.call(options_2);
      } finally {
        if (e_3) throw e_3.error;
      }
    }
  };

  Select.prototype._isButtonTarget = function (target) {
    return target === this._wrapperElement.element || target === this._placeholderElement.element || target === this._selectButtonElement.element || target === this._thumbElement.element;
  };

  Select.prototype._isDropdownTarget = function (target) {
    var current = target;

    while (current !== this._dropdownElement.element && current.parentElement) {
      current = current.parentElement;
    }

    return current === this._dropdownElement.element;
  };
  /**
   * Updates the UI if the selection has changed and makes sure the
   * select control and the generated markup are synchronized.
   * @private
   */


  Select.prototype._selectedItemChanged = function (newItem, autoClose, multiselect) {
    var _this = this;

    if (autoClose === void 0) {
      autoClose = true;
    }

    if (multiselect === void 0) {
      multiselect = false;
    }

    var oldItems = this._dropdownElement.element.querySelectorAll("." + CLASS_ITEM_SELECTED);

    if (!newItem) {
      setTimeout(function () {
        return _this.close();
      }, TIMEOUT_CLOSE);
      return;
    }

    if (Dom.hasClass(newItem, CLASS_ITEM_DISABLED)) {
      return;
    }

    if (oldItems.length === 0 && !newItem) {
      throw new Error("Can not select undefined elements");
    }

    var oldItem = oldItems[0];

    if (multiselect === true) {
      oldItem = (0, _Utils.find)(oldItems, function (x) {
        return x.getAttribute("data-value") === newItem.getAttribute("data-value");
      });
    }

    var isDeselect = false;

    if (newItem && oldItem && oldItem === newItem) {
      // Click on a previously selected element -> deselect
      isDeselect = true;

      if (!this._placeholderOption && !multiselect) {
        // If there is no placeholder option, non multiselect options cannot be deselected
        return;
      }

      delete this._lastSelectedOption;
    }

    if (oldItem) {
      // Remove selection on the element
      var oldValue_1 = oldItem.getAttribute("data-value");
      var optElement = (0, _Utils.find)(this.element.options, function (x) {
        return !x.disabled && x.value === oldValue_1;
      });

      if (!optElement) {
        throw new Error("The option with value " + oldValue_1 + " does not exist");
      } // Unset Select value


      optElement.selected = false;
      Dom.removeClass(oldItem, CLASS_ITEM_SELECTED);
    }

    if (!isDeselect) {
      // Select an option
      // Select a new item
      var newValue_1 = newItem.getAttribute("data-value");
      var optElement = (0, _Utils.find)(this.element.options, function (x) {
        return !x.disabled && x.value === newValue_1;
      });

      if (!optElement) {
        throw new Error("The option with value " + newValue_1 + " does not exist");
      } // Set Select value


      optElement.selected = true;
      Dom.addClass(newItem, CLASS_ITEM_SELECTED); // Preserve selection

      this._lastSelectedOption = optElement;
    } else {
      // Deselect an option
      // Keep track of falling back to the placeholder (if any)
      if (this._placeholderOption) {
        this._lastSelectedOption = this._placeholderOption;
      }
    }

    var hasSelectedItems = true;

    if (this._multiselection === false && isDeselect) {
      // Handle no selection for non-multiselect states
      this._placeholderOption.selected = true;
      hasSelectedItems = false;
    }

    if (this._multiselection === true && this._getSelectedOptions().length === 0) {
      hasSelectedItems = false;
    } // Reset the filter if filterable


    if (this._activeFilter) {
      this._clearFilter();
    }

    this._updatePlaceholder(hasSelectedItems); // Dispatch the changed event


    this.dispatchEvent("change");

    if (autoClose && !multiselect) {
      setTimeout(function () {
        _this.close();
      }, TIMEOUT_CLOSE);
    }
  };

  Select.prototype._updatePlaceholder = function (hasSelectedItems) {
    var e_4, _a;

    var text = this._placeholderOption ? Dom.text(this._placeholderOption) : " ";

    if (hasSelectedItems === true) {
      var selectedItems = this._getSelectedOptions();

      if (selectedItems.length > 0) {
        text = "";

        try {
          for (var selectedItems_1 = (0, _tslib.__values)(selectedItems), selectedItems_1_1 = selectedItems_1.next(); !selectedItems_1_1.done; selectedItems_1_1 = selectedItems_1.next()) {
            var item = selectedItems_1_1.value;
            text += Dom.text(item) + ", ";
          }
        } catch (e_4_1) {
          e_4 = {
            error: e_4_1
          };
        } finally {
          try {
            if (selectedItems_1_1 && !selectedItems_1_1.done && (_a = selectedItems_1["return"])) _a.call(selectedItems_1);
          } finally {
            if (e_4) throw e_4.error;
          }
        }

        text = text.substring(0, text.length - 2);
      }
    }

    this._setPlaceholder(text);
  };

  Select.prototype._getSelectedOptions = function () {
    var selectedOptions = [];

    if (this.element.options) {
      [].forEach.call(this.element.options, function (option) {
        if (option.selected && !option.disabled) {
          selectedOptions.push(option);
        }
      });
    }

    return selectedOptions;
  };
  /**
   * Clone all of the initially set options (and optgroups) and returns them in a new array.
   * This serves as the basis for filtering. If a filter is present, it will be respected.
   */


  Select.prototype.getInitialOptions = function () {
    var filter = this._activeFilter || "";
    var filtered = [];
    var initialOptions = this._initialOptions;

    for (var i = 0; i < initialOptions.length; i++) {
      var child = initialOptions[i];

      if (this._isOptGroup(child)) {
        // handle <optgroup>
        var optGroupClone = child.cloneNode(false);
        var found = false;

        for (var j = 0; j < child.children.length; j++) {
          var optionClone = child.children[j].cloneNode(true); // Append on match

          if (this._containsWord(optionClone.innerHTML, filter)) {
            optGroupClone.appendChild(optionClone);
            found = true;
          }
        } // Push if any matches found


        if (found) {
          filtered.push(optGroupClone);
        }
      } else if (this._isOption(child)) {
        // handle <option>
        var optionClone = child.cloneNode(true); // Push on match

        if (this._containsWord(optionClone.innerHTML, filter)) {
          filtered.push(optionClone);
        }
      }
    }

    return filtered;
  };
  /**
   * Returns true if a text contains a given keyword, e.g. in "ca" in "Car"
   */


  Select.prototype._containsWord = function (text, keyword) {
    return text.toLowerCase().indexOf(keyword.toLowerCase()) > -1;
  };

  Select.prototype._handleFocus = function () {
    var _this = this;

    this.open();
    this._openByFocus = true;
    setTimeout(function () {
      _this._openByFocus = false;
    }, TIMEOUT_BLUR);
  };

  Select.prototype._handleBlur = function () {
    this.close();
  };

  Select.prototype._handleClick = function (event) {
    var handled = false;

    if (this._lastHandledEvent === event) {
      this._lastHandledEvent = undefined;
      return;
    }

    if (this._isButtonTarget(event.target) && this._openByFocus === false) {
      // handle header item clicks and toggle dropdown
      this.toggle();
      handled = true;
    }

    var newItem = event.target;

    if (!handled && Dom.hasClass(newItem, CLASS_ITEM)) {
      // handle clicks on dropdown items
      this._selectedItemChanged(newItem, true, this._multiselection);

      handled = true;
    }

    if (handled) {
      this._lastHandledEvent = event;
      (0, _Utils.preventDefault)(event);
    }
  };

  Select.prototype._handleWindowClick = function (event) {
    if (this._isDropdownTarget(event.target) || this._isButtonTarget(event.target)) {
      return;
    }

    this.close();
  };

  Select.prototype._focusOptionStartingWith = function (keycode, startIndex, options) {
    for (var index = startIndex; index < options.length; index++) {
      var item = new _DomElement["default"](options[index]);
      var value = item.innerText.toLowerCase();

      if (index > options.length) {
        index = 0;
      }

      if (value.startsWith(Inputs.getKeyValue(keycode))) {
        var newOption = new _DomElement["default"](options[index]);

        if (!newOption.hasClass(CLASS_ITEM_DISABLED)) {
          (0, _Utils.scrollIntoView)(options[index]);
          newOption.addClass(CLASS_ITEM_FOCUSED);
          return newOption;
        }
      }
    }

    return undefined;
  };

  Select.prototype._handleKeydown = function (event) {
    var keyboardEvent = event;
    var evt = keyboardEvent || window.event;
    var keycode = keyboardEvent.which || keyboardEvent.keyCode;

    if (keycode === Inputs.KEY_ESCAPE) {
      // handle Escape key (ESC)
      if (this.isOpen()) {
        this.close();
      }

      evt.preventDefault();
      return;
    }

    if (keycode === Inputs.KEY_ARROW_UP || keycode === Inputs.KEY_ARROW_DOWN) {
      // Up and down arrows
      var options = this._wrapperElement.element.querySelectorAll("." + CLASS_ITEM);

      if (options.length > 0) {
        var newIndex = 0;
        var oldOption = void 0;

        var focusedElement = this._wrapperElement.find("." + CLASS_ITEM_FOCUSED);

        var searchFor = focusedElement ? CLASS_ITEM_FOCUSED : CLASS_ITEM_SELECTED;
        var newElement = void 0;

        for (var index = 0; index < options.length; index++) {
          var direction = keycode === Inputs.KEY_ARROW_DOWN ? 1 : -1;
          var item = new _DomElement["default"](options[index]); // search for selected or focusedElement elements

          if (item.hasClass(searchFor)) {
            oldOption = item;
            newIndex = index; // get the next not disabled element in the appropriate direction

            for (var count = 0; count < options.length; count++) {
              newIndex += direction;
              newIndex %= options.length;

              if (newIndex < 0) {
                newIndex = options.length - 1;
              }

              newElement = new _DomElement["default"](options[newIndex]);

              if (!newElement.hasClass(CLASS_ITEM_DISABLED)) {
                break;
              }
            }
          }
        } // set the new element focused


        (0, _Utils.scrollIntoView)(options[newIndex]);
        var newOption = new _DomElement["default"](options[newIndex]);
        newOption.addClass(CLASS_ITEM_FOCUSED);

        if (oldOption) {
          oldOption.removeClass(CLASS_ITEM_FOCUSED);
        }
      }

      evt.preventDefault();
      return;
    }

    if (Inputs.getKeyValue(keycode) && !this._isFilterable()) {
      // Keyboard keys
      var options = this._wrapperElement.element.querySelectorAll("." + CLASS_ITEM);

      if (options.length > 0) {
        var oldFocusIndex = 0;
        var hasFocusedOption = false;

        for (var index = 0; index < options.length; index++) {
          var item = new _DomElement["default"](options[index]);

          if (item.hasClass(CLASS_ITEM_FOCUSED)) {
            item.removeClass(CLASS_ITEM_FOCUSED);
            var value = item.innerText.toLowerCase();

            if (value.startsWith(Inputs.getKeyValue(keycode))) {
              hasFocusedOption = true;
              oldFocusIndex = index;
            }
          }
        }

        var newOption = this._focusOptionStartingWith(keycode, hasFocusedOption ? oldFocusIndex + 1 : 0, options);

        if (newOption === undefined) {
          this._focusOptionStartingWith(keycode, 0, options);
        }
      }

      evt.preventDefault();
      return;
    }

    if (keycode === Inputs.KEY_ENTER || keycode === Inputs.KEY_TAB) {
      // Handle enter and tab key by selecting the currently focused element
      var newItem = this._dropdownElement.element.querySelector("." + CLASS_ITEM_FOCUSED);

      this._selectedItemChanged(newItem, true, this._multiselection);
    }
  };
  /**
   * Fired when the user presses a key in the filter field
   */


  Select.prototype._handleFilterKeydown = function (e) {
    var keyboardEvent = e;
    var keycode = keyboardEvent.which || keyboardEvent.keyCode; // If the user hits the enter key while filtering and there's a single match, select it

    if (keycode === Inputs.KEY_ENTER) {
      var dropdownElements = this._dropdownElement.element.querySelectorAll("." + CLASS_ITEM);

      if (dropdownElements.length === 1) {
        this._selectedItemChanged(dropdownElements[0], true, this._multiselection);

        e.stopPropagation();
      }
    }
  };
  /**
   * Fired when the user releases a key in the filter field
   */


  Select.prototype._handleFilterKeyup = function (e) {
    var target = e.target; // Filter has changed

    if (target.value !== this._activeFilter && target.value !== this._placeholderText && target.value !== this._lastSelectedOption.innerHTML) {
      this._setFilter(target.value);
    }
  };
  /**
   * Fired when the user focusses the filter input field
   */


  Select.prototype._handleFilterFocus = function (e) {
    var target = e.target;
    setTimeout(function () {
      target.select();
    });
  };
  /**
   * Filters the Select by a given filter keyword
   * @param filter Keyword to filter by
   */


  Select.prototype._setFilter = function (filter) {
    if (filter === void 0) {
      filter = "";
    }

    this._activeFilter = filter.length >= this._minFilterLength ? filter : "";
    this.setOptions(this.getInitialOptions());
  };
  /**
   * Resets the filter
   */


  Select.prototype._clearFilter = function () {
    delete this._activeFilter;
    this.setOptions(this.getInitialOptions());
  };
  /**
   * Set new content and reload the Select
   * @param elements Array of new option (or optgroup) elements to display
   */


  Select.prototype.setOptions = function (options) {
    var _this = this;

    this._emptyNode(this.element);

    options.forEach(function (option) {
      _this.element.appendChild(option);
    }); // Preserve selected value if the selected

    this.element.value = this._lastSelectedOption.value;
    this.reload();
  };
  /**
   * Clear all children of a given node
   * @param node Node
   */


  Select.prototype._emptyNode = function (node) {
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
  };
  /**
   * Returns whether an option is a placeholder option
   */


  Select.prototype._isPlaceholder = function (option) {
    return option.hasAttribute("disabled") && option.hasAttribute("selected");
  };
  /**
   * Update placeholder value
   * @param text Content of the placeholder
   */


  Select.prototype._setPlaceholder = function (text) {
    if (this._placeholderElement && text) {
      if (this._isFilterable()) {
        this._placeholderElement.element.value = text;
      } else {
        this._placeholderElement.setHtml(text);
      }
    }
  };

  Object.defineProperty(Select.prototype, "value", {
    /**
     * Gets the value of the currently selected option.
     * If multiple selection is enabled this property returns an array of values.
     */
    get: function get() {
      if (this._multiselection) {
        return this._getSelectedOptions().map(function (x) {
          return x.value;
        });
      }

      if (this.element.value === "") {
        return null;
      }

      return this.element.value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Select.prototype, "disabled", {
    /**
     * Enables or disables the select component depending on the
     * 'value' parameter.
     * @param {value} If true disables the control; false enables it.
     */
    set: function set(value) {
      if (value) {
        this.disable();
      } else {
        this.enable();
      }
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Reloads the dropdown's option data definitions from the DOM and updates
   * the generated dropdown display items.
   */

  Select.prototype.reload = function () {
    // Remove all existing child elements
    this._emptyNode(this._dropdownElement.element);

    if (this._activeFilter === undefined) {
      // If the user is filtering, let the placeholder "input" alive
      this._setupPlaceholder();
    }

    this._createOptions(this.element);

    this._updateSize();

    this._updateMessage();

    if (!this._isFilterable()) {
      this._updatePlaceholder(!!this.value);
    }
  };
  /**
   * Sets the select control to the enabled state.
   */


  Select.prototype.enable = function () {
    this.element.removeAttribute("disabled");

    this._wrapperElement.removeClass(CLASS_DISABLED);

    window.addEventListener("click", this._windowClickHandler);

    this._wrapperElement.element.addEventListener("click", this._clickHandler);

    this._wrapperElement.element.addEventListener("keydown", this._keydownHandler);

    this._wrapperElement.element.addEventListener("focus", this._focusHandler);

    this._wrapperElement.element.addEventListener("blur", this._blurHandler);
  };
  /**
   * Sets the select control to the disabled state.
   */


  Select.prototype.disable = function () {
    this.element.setAttribute("disabled", "");

    this._wrapperElement.addClass(CLASS_DISABLED);

    window.removeEventListener("click", this._windowClickHandler);

    this._wrapperElement.element.removeEventListener("click", this._clickHandler);

    this._wrapperElement.element.removeEventListener("keydown", this._keydownHandler);

    this._wrapperElement.element.removeEventListener("focus", this._focusHandler);

    this._wrapperElement.element.removeEventListener("blur", this._blurHandler);

    this.close();
  };
  /**
   * Toggles the open/closed state of the select dropdown.
   */


  Select.prototype.toggle = function () {
    if (this.isOpen()) {
      this.close();
    } else {
      this.open();
    }
  };
  /**
   * Gets if the select dropdown is open or closed.
   * @return {boolean} True if open; otherwise false.
   */


  Select.prototype.isOpen = function () {
    return this._wrapperElement.hasClass(CLASS_OPEN);
  };
  /**
   * Opens the select dropdown.
   */


  Select.prototype.open = function () {
    if (!this.isOpen()) {
      this._openByFocus = false;

      this._wrapperElement.removeClass(CLASS_CLOSED);

      this._wrapperElement.addClass(CLASS_OPEN);

      this._dropdownElement.element.addEventListener("click", this._handleDropdownClick);

      this._dropdownElement.element.addEventListener("tap", this._handleDropdownClick);
    }
  };
  /**
   * Closes the select dropdown.
   */


  Select.prototype.close = function () {
    if (this.isOpen()) {
      this._openByFocus = false;

      this._wrapperElement.removeClass(CLASS_OPEN);

      this._wrapperElement.addClass(CLASS_CLOSED); // If the Select is filterable and therefore has an input field,
      // reset the value of it to the chosen option


      if (this._isFilterable()) {
        // Unfocus input field
        this._placeholderElement.element.blur();

        if (!this._activeFilter || this._activeFilter === this._lastSelectedOption.innerHTML) {
          this._setPlaceholder(this._lastSelectedOption.innerHTML);
        }
      }

      this._dropdownElement.element.removeEventListener("click", this._handleDropdownClick);

      this._dropdownElement.element.removeEventListener("tap", this._handleDropdownClick);

      var focusedItem = this._wrapperElement.find("." + CLASS_ITEM_FOCUSED);

      if (focusedItem) {
        focusedItem.removeClass(CLASS_ITEM_FOCUSED);
      }
    }
  };
  /**
   * Returns true when the element has the filter modifier class
   */


  Select.prototype._isFilterable = function () {
    return this._wrapperElement.hasClass(CLASS_FILTERABLE);
  };
  /**
   * Destroys the component and clears all references.
   */


  Select.prototype.destroy = function () {
    window.removeEventListener("click", this._windowClickHandler);

    if (this._dropdownElement) {
      this._dropdownElement.element.removeEventListener("click", this._handleDropdownClick);

      this._dropdownElement.element.removeEventListener("tap", this._handleDropdownClick);

      (0, _Utils.remove)(this._dropdownElement.element);
      this._dropdownElement = undefined;
    }

    if (this._placeholderElement) {
      this._placeholderElement.removeEventListener("keydown", this._filterKeydownHandler);

      this._placeholderElement.removeEventListener("keyup", this._filterKeyupHandler);

      this._placeholderElement.removeEventListener("focus", this._filterFocusHandler);
    }

    if (this._wrapperElement) {
      this._wrapperElement.element.removeEventListener("click", this._clickHandler);

      this._wrapperElement.element.removeEventListener("keydown", this._keydownHandler);

      this._wrapperElement.element.removeEventListener("focus", this._focusHandler);

      this._wrapperElement.element.removeEventListener("blur", this._blurHandler);

      this._wrapperElement = undefined;
    }

    if (this._selectButtonElement) {
      (0, _Utils.remove)(this._selectButtonElement.element);
      this._selectButtonElement = undefined;
    }

    this.removeClass(CLASS_CLOSED);
  };

  return Select;
}(_DomElement["default"]);

function init() {
  (0, _Utils.searchAndInitialize)("select", function (e) {
    new Select(e);
  });
}

var _default = Select;
exports["default"] = _default;

},{"../DomElement":4,"../DomFunctions":5,"../Inputs":6,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"@babel/runtime/helpers/interopRequireWildcard":34,"tslib":43}],20:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _Utils = require("../Utils");

var _DomElement = _interopRequireDefault(require("../DomElement"));

var Dom = _interopRequireWildcard(require("../DomFunctions"));

var QUERY_TEXTAREA = "textarea";
var CLASS_HAS_VALUE = "is-fixed";
/**
 * Textarea component
 */

var Textarea =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Textarea, _super);

  function Textarea(element) {
    var _this = _super.call(this, element) || this;

    _this._area = _this.element.querySelector(QUERY_TEXTAREA);
    _this._focusChangedHandler = _this._focusChanged.bind(_this);
    _this._valueChangedHandler = _this._onValueChanged.bind(_this);
    _this._resizeHandler = _this._updateHeight.bind(_this);

    _this._initialize();

    return _this;
  }
  /**
   * Initializes the textarea component.
   * @private
   */


  Textarea.prototype._initialize = function () {
    this._minRows = parseInt(this._area.getAttribute("data-min-rows") || "3", 10);
    this._maxRows = parseInt(this._area.getAttribute("data-max-rows"), 10) || Number.MAX_SAFE_INTEGER; // Make sure min an max are property specified

    this._minRows = Math.min(this._minRows, this._maxRows);
    this._maxRows = Math.max(this._minRows, this._maxRows);
    this._lineHeight = parseInt(Dom.css(this._area, "line-height"), 10);
    this._updateBaseHeight = Dom.isHidden(this._area, true);

    this._calculateBaseHeight(); // add event listeners


    this._area.addEventListener("focus", this._focusChangedHandler);

    this._area.addEventListener("blur", this._focusChangedHandler);

    this._area.addEventListener("input", this._valueChangedHandler);

    window.addEventListener("resize", this._resizeHandler);
    window.addEventListener("orientationchange", this._resizeHandler);

    this._onValueChanged();
  };

  Textarea.prototype._calculateBaseHeight = function () {
    // temporary clear the content to take measurements
    var value = this._area.value;
    this._area.value = "";
    this._baseHeight = this._area.offsetHeight - this._lineHeight;
    this._baseScrollHeight = this._area.scrollHeight - this._lineHeight; // restore initial content

    this._area.value = value;
  };

  Textarea.prototype._focusChanged = function () {
    this._updateHeight();
  };

  Textarea.prototype._updateHeight = function () {
    var hasFocus = this._area === document.activeElement;
    var maxRows,
        rows = 0;

    if (this._updateBaseHeight === true && Dom.isHidden(this._area, true) === false) {
      this._calculateBaseHeight();

      this._updateBaseHeight = false;
    } // Calculate the apropriate size for the control


    if (!this._hasValue()) {
      // Handle empty states
      rows = hasFocus === true ? this._minRows : 1;
      maxRows = rows;
    } else {
      // Reset the height for calculation of the row count
      this._area.style.height = "auto"; // Get the new height

      rows = Math.ceil((this._area.scrollHeight - this._baseScrollHeight) / this._lineHeight) + 1;
      maxRows = Math.max(Math.min(this._maxRows, rows), this._minRows);
    }

    if (rows > this._maxRows) {
      this._area.style.overflow = "auto";
    } else {
      this._area.style.overflow = "hidden";
    }

    var height = (maxRows - 1) * this._lineHeight + this._baseHeight;
    this._area.style.height = height + "px";
  };

  Textarea.prototype._hasValue = function () {
    return this._area.value && this._area.value.length > 0;
  };

  Textarea.prototype._onValueChanged = function () {
    if (this._hasValue()) {
      Dom.addClass(this._area, CLASS_HAS_VALUE);
    } else {
      Dom.removeClass(this._area, CLASS_HAS_VALUE);
      this._area.value = "";
    }

    this._updateHeight();
  };
  /**
   * Destroys the component and clears all references.
   */


  Textarea.prototype.destroy = function () {
    window.removeEventListener("resize", this._resizeHandler);
    window.removeEventListener("orientationchange", this._resizeHandler);

    this._area.removeEventListener("focus", this._focusChangedHandler);

    this._area.removeEventListener("blur", this._focusChangedHandler);

    this._area.removeEventListener("input", this._valueChangedHandler);

    this._focusChangedHandler = null;
    this._valueChangedHander = null;
    this._area = null;
    this._minRows = null;
    this._maxRows = null;
    this._lineHeight = null;
    this._baseHeight = null;
    this._baseScrollHeight = null;
    this.element = null;
  };

  return Textarea;
}(_DomElement["default"]);

function init() {
  (0, _Utils.searchAndInitialize)(".input-multiline, .input-field--multiline", function (e) {
    new Textarea(e);
  });
}

var _default = Textarea;
exports["default"] = _default;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"@babel/runtime/helpers/interopRequireWildcard":34,"tslib":43}],21:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _Utils = require("../Utils");

var _DomElement = _interopRequireDefault(require("../DomElement"));

/**
 * Loader bar component
 */
var LoaderBar =
/** @class */
function (_super) {
  (0, _tslib.__extends)(LoaderBar, _super);
  /**
   * Creates and initializes the LoaderBar component.
   * @param {Element} - The root element of the LoaderBar component.
   */

  function LoaderBar(element) {
    var _this = _super.call(this, element) || this;

    _this._initialize();

    return _this;
  }
  /**
   * Initializes the loader bar component.
   * @private
   */


  LoaderBar.prototype._initialize = function () {
    this.progressElement = this.find(".indicator") || this;
    this.fileNameElement = this.find(".detail > .name");
    this.progressLabelElement = this.find(".progress");
    this.totalProgressElement = this.find(".progress > .file-size");
  };

  Object.defineProperty(LoaderBar.prototype, "progress", {
    /**
     * Gets the current progress value in the range of 0..1.
     */
    get: function get() {
      return this.value;
    },

    /**
     * Sets the current progress.
     * @param {number} - The progress in the range of 0..1.
     */
    set: function set(val) {
      // val = clamp(val, 0, 1)
      var percentage = (val * 100).toFixed(0);
      this.value = val;
      this.element.value = String(val);
      this.progressElement.setAttribute("style", "width: " + val * 100 + "%");

      if (this.progressLabelElement) {
        this.progressLabelElement.element.textContent = percentage + "%";
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LoaderBar.prototype, "filename", {
    /**
     * Gets the filename.
     * @returns {string} - The filename.
     */
    get: function get() {
      if (!this.fileNameElement) {
        return undefined;
      }

      return this.fileNameElement.element.innerHTML;
    },

    /**
     * Sets the filename.
     */
    set: function set(val) {
      if (!this.fileNameElement) {
        throw new Error("Cannot set the filename, missing detail element");
      }

      this.fileNameElement.setHtml(val || "");
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LoaderBar.prototype, "fileSize", {
    /**
     * Sets the file size label.
     */
    set: function set(val) {
      if (!this.totalProgressElement) {
        throw new Error("Cannot set the fileSize, missing detail element");
      }

      this.totalProgressElement.setHtml(val);
    },
    enumerable: false,
    configurable: true
  });
  return LoaderBar;
}(_DomElement["default"]);

function init() {
  (0, _Utils.searchAndInitialize)(".loader-bar", function (e) {
    new LoaderBar(e);
  });
}

var _default = LoaderBar;
exports["default"] = _default;

},{"../DomElement":4,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"tslib":43}],22:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _animejs = _interopRequireDefault(require("animejs"));

var _popper = _interopRequireDefault(require("popper.js"));

var _DomElement = _interopRequireDefault(require("../DomElement"));

var _DomFunctions = require("../DomFunctions");

var CLASS_OPEN = "is-open";
var CLASS_MENU = "js-flyout";
var CLASS_TABS = "tabs";
var ANIMATION_OPEN = 300;
/**
 * A component for the flyout menu.
 */

var MenuFlyout =
/** @class */
function (_super) {
  (0, _tslib.__extends)(MenuFlyout, _super);
  /**
   * Creates and initializes the flyout component.
   * @param element - The root element of the flyout menu component.
   */

  function MenuFlyout(element) {
    var _this = _super.call(this, element) || this;

    _this._animationDuration = ANIMATION_OPEN;
    _this._dynamicPlacement = false;
    _this._clickHandler = _this._handleClick.bind(_this);
    _this._windowClickHandler = _this._handleWindowClick.bind(_this);

    _this._initialize();

    return _this;
  }
  /**
   * Initializes the flyout component.
   * @private
   */


  MenuFlyout.prototype._initialize = function () {
    var dataTarget = this.element.getAttribute("data-target");

    if (dataTarget === null || dataTarget === "") {
      /* tslint:disable:no-console */
      console.error("A flyout menu element requires a 'data-target' that specifies the element to collapse");
      console.info(this.element);
      /* tslint:enable:no-console */

      return;
    }

    if (this._useDynamicPlacement()) {
      this._dynamicPlacement = true;
    }

    var hiddenTarget = this.element.getAttribute("data-hidden");

    if (hiddenTarget !== null && hiddenTarget !== "") {
      this._hiddenIndicator = document.querySelector(hiddenTarget) || undefined;
    }

    this._initFlyoutElement(dataTarget);

    this.element.addEventListener("click", this._clickHandler);
  };

  MenuFlyout.prototype._initFlyoutElement = function (dataTarget) {
    this._flyoutElement = document.querySelector(dataTarget);
    this._flyoutElement.style.opacity = "0";
    this._flyoutElement.style.transform = "translateY(-20px)";
  };

  MenuFlyout.prototype._handleClick = function () {
    this.toggle();
  };

  MenuFlyout.prototype._handleWindowClick = function (event) {
    var target = event.target;

    if ((0, _DomFunctions.parentWithClass)(target, CLASS_MENU) === this._flyoutElement) {
      return false;
    }

    while (target !== this.element && target.parentElement) {
      target = target.parentElement;
    }

    if (target !== this.element) {
      this.close();
      return false;
    }

    return true;
  };

  MenuFlyout.prototype._useDynamicPlacement = function () {
    return (0, _DomFunctions.parentWithClass)(this.element, CLASS_TABS);
  };

  MenuFlyout.prototype._openMenu = function (el) {
    _animejs["default"].remove(el);

    if (this._dynamicPlacement === true) {
      var popperOptions = {
        placement: "bottom",
        modifiers: {
          flip: {
            enabled: false
          }
        },
        eventsEnabled: false
      };
      this._popperInstance = new _popper["default"](this.element, this._flyoutElement, popperOptions);
    }

    (0, _animejs["default"])({
      targets: el,
      duration: this._animationDuration,
      easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
      opacity: 1,
      translateY: "0px",
      begin: function begin() {
        el.style.display = "block";
      },
      complete: function complete() {
        (0, _DomFunctions.addClass)(el, CLASS_OPEN);
      }
    }); // set aria expanded

    el.setAttribute("aria-expanded", "true");
    this.dispatchEvent("opened");
  };

  MenuFlyout.prototype._closeMenu = function (el) {
    _animejs["default"].remove(el);

    if (this._popperInstance) {
      this._popperInstance.destroy();

      this._popperInstance = undefined;
    }

    (0, _animejs["default"])({
      targets: el,
      duration: this._animationDuration,
      easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
      opacity: 0,
      translateY: "-20px",
      complete: function complete() {
        el.style.display = "none";
        (0, _DomFunctions.removeClass)(el, CLASS_OPEN);
      }
    }); // set aria expanded

    el.setAttribute("aria-expanded", "false");
    this.dispatchEvent("closed");
  };

  Object.defineProperty(MenuFlyout.prototype, "animationDuration", {
    /**
     * Sets the opening animation duration.
     * @param {durationInSeconds} - The animation duration in seconds.
     */
    set: function set(durationInSeconds) {
      this._animationDuration = durationInSeconds;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Opens the flyout menu.
   * @fires Modal#opened
   */

  MenuFlyout.prototype.open = function () {
    var _this = this;

    if (this._hiddenIndicator && (0, _DomFunctions.isHidden)(this._hiddenIndicator, false) === true) {
      return;
    }

    if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === true) {
      return;
    }

    (0, _DomFunctions.addClass)(this.element, CLASS_OPEN);

    this._openMenu(this._flyoutElement);

    setTimeout(function () {
      window.addEventListener("click", _this._windowClickHandler);
      window.addEventListener("touchend", _this._windowClickHandler);
    }, 50);
  };
  /**
   * Closes the flyout menu.
   * @fires Modal#closed
   */


  MenuFlyout.prototype.close = function () {
    if (this._hiddenIndicator && (0, _DomFunctions.isHidden)(this._hiddenIndicator, false) === true) {
      return;
    }

    if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
      return;
    }

    (0, _DomFunctions.removeClass)(this.element, CLASS_OPEN);
    window.removeEventListener("click", this._windowClickHandler);
    window.removeEventListener("touchend", this._windowClickHandler);

    this._closeMenu(this._flyoutElement);
  };
  /**
   * Toggles the flyout menu.
   * @fires Modal#opened
   * @fires Modal#closed
   */


  MenuFlyout.prototype.toggle = function () {
    if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
      this.open();
    } else {
      this.close();
    }
  };
  /**
   * Removes all event handlers and clears references.
   */


  MenuFlyout.prototype.destroy = function () {
    this._flyoutElement = null;
    window.removeEventListener("click", this._windowClickHandler);
    window.removeEventListener("touchend", this._windowClickHandler);

    if (this._clickHandler) {
      this.element.removeEventListener("click", this._clickHandler);
    }

    if (this._popperInstance) {
      this._popperInstance.destroy();

      this._popperInstance = undefined;
    }

    this._clickHandler = null;
    this._windowClickHandler = null;
    this.element = null;
  };

  return MenuFlyout;
}(_DomElement["default"]);

function init() {
  var e_1, _a;

  var elements = document.querySelectorAll("[data-toggle='flyout']");

  try {
    for (var elements_1 = (0, _tslib.__values)(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
      var e = elements_1_1.value;

      if (e.getAttribute("data-init") === "auto") {
        new MenuFlyout(e);
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (elements_1_1 && !elements_1_1.done && (_a = elements_1["return"])) _a.call(elements_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
}

var _default = MenuFlyout;
exports["default"] = _default;

},{"../DomElement":4,"../DomFunctions":5,"@babel/runtime/helpers/interopRequireDefault":33,"animejs":36,"popper.js":42,"tslib":43}],23:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _bodyScrollLock = require("body-scroll-lock");

var _Utils = require("../Utils");

var Inputs = _interopRequireWildcard(require("../Inputs"));

var _DomElement = _interopRequireDefault(require("../DomElement"));

var _DomFunctions = require("../DomFunctions");

var CLASS_BACKDROP = "backdrop";
var CLASS_BACKDROP_OPEN = "backdrop--open";
var CLASS_OPEN = "modal--open";
var CLASS_TRIGGER = "modal-trigger";
var CLASS_BODY = "modal__body";
var CLASS_BUTTONS_OKAY = ".modal-close";
var CLASS_BUTTONS_CLOSE = ".modal-cancel";
/**
 * A component to open and close modal dialogs. It also handles cancellation and makes
 * sure that the modal background is present in the DOM.
 */

var Modal =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Modal, _super);

  function Modal(element) {
    var _this = _super.call(this, element) || this;

    _this._okayHandler = _this.close.bind(_this);
    _this._cancelHandler = _this._handleClick.bind(_this);
    _this._keydownHandler = _this._handleKeydown.bind(_this);

    _this._initialize();

    return _this;
  }
  /**
   * Initializes the range modal component.
   * @private
   */


  Modal.prototype._initialize = function () {
    // Create the backdrop
    this._backdrop = new _DomElement["default"]("div").addClass(CLASS_BACKDROP);
    this._backdropParent = (0, _DomFunctions.getRootElement)();

    this._subscribeToTrigger();
  };

  Modal.prototype._subscribeToTrigger = function () {
    var e_1, _a;

    var triggerId = this.element.id;

    if (!triggerId) {
      return;
    }

    this._triggerClickHandler = this.open.bind(this);
    var triggerElements = document.querySelectorAll("." + CLASS_TRIGGER + "[href=" + triggerId + "]");

    try {
      for (var triggerElements_1 = (0, _tslib.__values)(triggerElements), triggerElements_1_1 = triggerElements_1.next(); !triggerElements_1_1.done; triggerElements_1_1 = triggerElements_1.next()) {
        var triggerElement = triggerElements_1_1.value;
        triggerElement.addEventListener("click", this._triggerClickHandler);
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (triggerElements_1_1 && !triggerElements_1_1.done && (_a = triggerElements_1["return"])) _a.call(triggerElements_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  };

  Modal.prototype._unsubscribeFromTrigger = function () {
    var e_2, _a;

    var triggerId = this.element.id;

    if (!triggerId) {
      return;
    }

    var triggerElements = document.querySelectorAll("." + CLASS_TRIGGER + "[href=" + triggerId + "]");

    try {
      for (var triggerElements_2 = (0, _tslib.__values)(triggerElements), triggerElements_2_1 = triggerElements_2.next(); !triggerElements_2_1.done; triggerElements_2_1 = triggerElements_2.next()) {
        var triggerElement = triggerElements_2_1.value;
        triggerElement.removeEventListener("click", this._windowClickHandler);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (triggerElements_2_1 && !triggerElements_2_1.done && (_a = triggerElements_2["return"])) _a.call(triggerElements_2);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    this._triggerClickHandler = undefined;
  };

  Modal.prototype._handleKeydown = function (event) {
    var keyboardEvent = event;
    var keycode = keyboardEvent.which || keyboardEvent.keyCode;

    if (keycode === Inputs.KEY_ESCAPE) {
      // handle Escape key (ESC)
      this.cancel();
      return;
    }
  };

  Modal.prototype._handleClick = function (event) {
    (0, _Utils.preventDefault)(event);
    this.cancel();
  };

  Modal.prototype._close = function () {
    var e_3, _a, e_4, _b;

    var _this = this;

    (0, _bodyScrollLock.enableBodyScroll)(this.element);
    document.removeEventListener("keydown", this._keydownHandler);

    this._backdrop.element.removeEventListener("click", this._cancelHandler);

    this._backdrop.removeClass(CLASS_BACKDROP_OPEN);

    this.removeClass(CLASS_OPEN);

    try {
      for (var _c = (0, _tslib.__values)(this.element.querySelectorAll(CLASS_BUTTONS_CLOSE)), _d = _c.next(); !_d.done; _d = _c.next()) {
        var closeButton = _d.value;
        closeButton.removeEventListener("click", this._cancelHandler);
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_d && !_d.done && (_a = _c["return"])) _a.call(_c);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    try {
      for (var _e = (0, _tslib.__values)(this.element.querySelectorAll(CLASS_BUTTONS_OKAY)), _f = _e.next(); !_f.done; _f = _e.next()) {
        var okayButton = _f.value;
        okayButton.removeEventListener("click", this._okayHandler);
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (_f && !_f.done && (_b = _e["return"])) _b.call(_e);
      } finally {
        if (e_4) throw e_4.error;
      }
    }

    setTimeout(function () {
      // remove the backdrop from the body
      _this._backdropParent.removeChild(_this._backdrop.element);
    }, 300);
  };
  /**
   * Opens the modal dialog.
   * @fires Modal#opened
   */


  Modal.prototype.open = function () {
    var _this = this;

    (0, _bodyScrollLock.disableBodyScroll)(this.element, {
      allowTouchMove: function allowTouchMove(el) {
        var currentEl = el;

        while (currentEl && currentEl !== document.body) {
          // Check if the user is scrolling the modal body
          if (currentEl.classList.contains(CLASS_BODY)) {
            // Check if the element overflows
            if (currentEl.scrollHeight > currentEl.clientHeight) {
              return true;
            }
          }

          currentEl = currentEl.parentNode;
        }

        return false;
      }
    }); // add the backdrop to the body

    this._backdropParent.appendChild(this._backdrop.element); // set the element to flex as it is initially hidden


    this.element.style.display = "flex"; // remove the style after the animation completes

    setTimeout(function () {
      _this.element.style.display = "";
    }, 800); // wait a bit to allow the browser to catch up and show the animation

    setTimeout(function () {
      var e_5, _a, e_6, _b;

      _this.addClass(CLASS_OPEN);

      _this._backdrop.addClass(CLASS_BACKDROP_OPEN);

      document.addEventListener("keydown", _this._keydownHandler);

      _this._backdrop.element.addEventListener("click", _this._cancelHandler);

      try {
        for (var _c = (0, _tslib.__values)(_this.element.querySelectorAll(CLASS_BUTTONS_CLOSE)), _d = _c.next(); !_d.done; _d = _c.next()) {
          var closeButton = _d.value;
          closeButton.addEventListener("click", _this._cancelHandler);
        }
      } catch (e_5_1) {
        e_5 = {
          error: e_5_1
        };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c["return"])) _a.call(_c);
        } finally {
          if (e_5) throw e_5.error;
        }
      }

      try {
        for (var _e = (0, _tslib.__values)(_this.element.querySelectorAll(CLASS_BUTTONS_OKAY)), _f = _e.next(); !_f.done; _f = _e.next()) {
          var okayButton = _f.value;
          okayButton.addEventListener("click", _this._okayHandler);
        }
      } catch (e_6_1) {
        e_6 = {
          error: e_6_1
        };
      } finally {
        try {
          if (_f && !_f.done && (_b = _e["return"])) _b.call(_e);
        } finally {
          if (e_6) throw e_6.error;
        }
      }

      _this.element.addEventListener("click", function (e) {
        return e.stopPropagation();
      });

      _this.dispatchEvent("opened");
    }, 50);
  };
  /**
   * Cancels (and closes) the modal dialog.
   * @fires Modal#cancelled
   * @fires Modal#closed
   */


  Modal.prototype.cancel = function () {
    this.dispatchEvent("cancelled");

    this._close();
  };
  /**
   * Closes the modal dialog.
   * @fires Modal#closed
   */


  Modal.prototype.close = function () {
    this._close();

    this.dispatchEvent("closed");
  };
  /**
   * Destroys the component and frees all references.
   */


  Modal.prototype.destroy = function () {
    this.cancel();

    this._unsubscribeFromTrigger();
  };

  return Modal;
}(_DomElement["default"]);

function init() {
  (0, _Utils.searchAndInitialize)(".modal", function (e) {
    new Modal(e);
  });
}

var _default = Modal;
exports["default"] = _default;

},{"../DomElement":4,"../DomFunctions":5,"../Inputs":6,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"@babel/runtime/helpers/interopRequireWildcard":34,"body-scroll-lock":37,"tslib":43}],24:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _animejs = _interopRequireDefault(require("animejs"));

var _Utils = require("../Utils");

var _DomElement = _interopRequireDefault(require("../DomElement"));

var Dom = _interopRequireWildcard(require("../DomFunctions"));

var _SearchInput = _interopRequireDefault(require("../search/SearchInput"));

var CLASS_OPEN = "is-open";
var CLASS_ACTIVE = "is-active";
var QUERY_NAV_HAMBURGER = ".nav-hamburger";
var QUERY_NAV_HB_BODY = ".nav__primary";
var CLASS_NAV_LINK = "nav-link--header";
var QUERY_NAV_LINK_ACTIVE = ".nav-link--header.is-active";
var QUERY_NAV_MOBILE = ".nav__level1 .nav__mainnav .nav__primary";
var QUERY_NAV_LEVEL0 = ".nav__level0";
var QUERY_NAV_LEVEL0_CONTAINER = ".nav__level0 .nav__subnav";
var QUERY_SECTION_OPEN = ".nav-section.is-open";
var QUERY_NAV_LEVEL1 = ".nav__level1 .nav__mainnav";
var QUERY_NAV_LEVEL0_LINK = ".nav-link.nav-link--header";
var QUERY_NAV_LEVEL1_LINK = ".nav-link--header";
var QUERY_NAV_COLUMN = ".nav-col";
var QUERY_NAV_COLUMN_ACTIVE = ".nav-col.is-active";
var QUERY_NAV_BODY = ".nav-body";
var QUERY_NAV_FOOTER = ".nav-footer";
var QUERY_SEARCH_ICON = ".nav-search";
var QUERY_SEARCH_FIELD = ".search__input";
var CLASS_SEARCH_DESKTOP = "search--desktop";
var ANIMATION_START_DELAY = 200;
var ANIMATION_OFFSET = 50;
var ANIMATION_BODY_DURATION = 300;
var ANIMATION_FOOTER_DURATION = 100;
/**
 * The navigation component definition.
 */

var Navigation =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Navigation, _super);

  function Navigation(element) {
    var _this = _super.call(this, element) || this;

    _this.animation = _animejs["default"].timeline();
    _this._navLevel0 = _this.element.querySelector(QUERY_NAV_LEVEL0) || document.createElement("div");
    _this._navLevel0Body = _this.element.querySelector(QUERY_NAV_LEVEL0_CONTAINER) || document.createElement("div");
    _this._navLevel1 = _this.element.querySelector(QUERY_NAV_LEVEL1) || document.createElement("div");
    _this._navMobile = _this.element.querySelector(QUERY_NAV_MOBILE) || document.createElement("div");

    if (!_this._navMobile.parentElement) {
      var dummyParent = document.createElement("div");
      dummyParent.appendChild(_this._navMobile);
    }

    _this._hamburgerElement = _this.element.querySelector(QUERY_NAV_HAMBURGER) || document.createElement("div");
    _this._searchComponents = [];
    _this._level0ClickHandler = _this._handleLevel0Click.bind(_this);
    _this._level1ClickHandler = _this._handleLevel1Click.bind(_this);
    _this._windowClickHandler = _this._handleWindowClick.bind(_this);
    _this._searchClickHandler = _this._handleSearchClick.bind(_this);

    _this._initialize();

    return _this;
  }

  Navigation.prototype._resetMainTimeline = function () {
    var e_1, _a;

    var elements = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      elements[_i] = arguments[_i];
    }

    this.animation.pause();

    try {
      for (var elements_1 = (0, _tslib.__values)(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
        var el = elements_1_1.value;

        _animejs["default"].remove(el);
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (elements_1_1 && !elements_1_1.done && (_a = elements_1["return"])) _a.call(elements_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }

    this.animation = _animejs["default"].timeline();
  };

  Navigation.prototype._isMobile = function () {
    return Dom.isHidden(this._hamburgerElement, true) === false;
  };

  Navigation.prototype._handleLevel0Click = function (event) {
    var isDesktop = !this._isMobile();

    if (isDesktop) {
      var navItems = new NavigationItems(this).fromLevel0(event.target);

      if (!navItems.section) {
        return;
      }

      var previousNavLink = this._navLevel0.querySelector(QUERY_NAV_LINK_ACTIVE);

      var previousNavSection = this._navLevel0.querySelector(QUERY_SECTION_OPEN);

      this._toggleContainer(navItems.link, this._navLevel0Body, navItems.section, undefined, previousNavLink, this._navLevel0Body, previousNavSection, undefined, true);
    }
  };

  Navigation.prototype._handleLevel1Click = function (event) {
    var navItems = new NavigationItems(this).fromLevel1(event.target);
    var prevItems = navItems.previousLevel1();

    this._toggleContainer(navItems.link, navItems.container, navItems.section, navItems.footer, prevItems.link, prevItems.container, prevItems.section, prevItems.footer, false);

    return false;
  };

  Navigation.prototype._toggleContainer = function (navLink, navContainer, navSection, navFooter, previousNavLink, previousNavContainer, previousNavSection, previousNavFooter, animateContainer) {
    if (animateContainer === void 0) {
      animateContainer = false;
    }

    var isDesktop = !this._isMobile();

    if (previousNavLink && previousNavLink !== navLink && navLink !== this._hamburgerElement) {
      Dom.removeClass(previousNavLink, CLASS_ACTIVE);
    }

    this._resetMainTimeline(navContainer, navSection, navFooter, previousNavContainer, previousNavSection, previousNavFooter);

    if (Dom.hasClass(navLink, CLASS_ACTIVE)) {
      Dom.removeClass(navLink, CLASS_ACTIVE);

      if (isDesktop) {
        this._onNavigationClosed();

        this._closeSection(navContainer, navSection, navFooter, true, animateContainer);
      } else if (navLink === this._hamburgerElement) {
        // Close mobile navigation
        this._onNavigationClosed();

        this._closeSection(navContainer, navSection, undefined, false, false);
      } else if (!isDesktop) {
        // Close the section
        this._closeSection(navContainer, navSection, navFooter, true, animateContainer);
      }
    } else {
      Dom.addClass(navLink, CLASS_ACTIVE);

      if (isDesktop) {
        Dom.addClass(this._navMobile, CLASS_OPEN);

        this._onNavigationOpened();

        if (previousNavContainer && previousNavSection) {
          this._closeSection(previousNavContainer, previousNavSection, previousNavFooter, true, animateContainer);
        }

        this._openSection(navContainer, navSection, navFooter, true, animateContainer);
      } else if (navLink === this._hamburgerElement) {
        // Open mobile navigation
        this._onNavigationOpened();

        this._openSection(navContainer, navSection, undefined, false, false);
      } else if (!isDesktop) {
        // Open section
        if (previousNavContainer && previousNavSection) {
          this._closeSection(previousNavContainer, previousNavSection, previousNavFooter, true, animateContainer);

          this.animation = _animejs["default"].timeline();
        }

        this._openSection(navContainer, navSection, navFooter, true, animateContainer);
      }
    }
  };

  Navigation.prototype._onNavigationOpened = function () {
    Dom.addClass(this._navMobile, CLASS_OPEN);
    Dom.addClass(this._navMobile.parentElement, CLASS_OPEN);
    Dom.addClass(this._hamburgerElement, CLASS_ACTIVE);
    window.addEventListener("click", this._windowClickHandler);
    window.addEventListener("touchend", this._windowClickHandler);
  };

  Navigation.prototype._onNavigationClosed = function () {
    Dom.removeClass(this._navMobile, CLASS_OPEN);
    Dom.removeClass(this._navMobile.parentElement, CLASS_OPEN);
    Dom.removeClass(this._hamburgerElement, CLASS_ACTIVE);
    window.removeEventListener("click", this._windowClickHandler);
    window.removeEventListener("touchend", this._windowClickHandler);
  };

  Navigation.prototype._handleWindowClick = function (event) {
    var target = event.target;

    while (target !== this.element && target.parentElement) {
      target = target.parentElement;
    }

    if (target !== this.element) {
      this.close();
      return false;
    }

    return true;
  };

  Navigation.prototype._openSection = function (navContainer, navSection, navFooter, animateColumns, animateContainer) {
    var e_2, _a, e_3, _b;

    if (animateColumns === void 0) {
      animateColumns = true;
    }

    if (animateContainer === void 0) {
      animateContainer = false;
    }

    if (!navSection || !navContainer) {
      return;
    }

    var activeItems = navSection.querySelectorAll(QUERY_NAV_COLUMN);

    if (animateContainer === true) {
      var container = navContainer;
      navContainer = navSection;
      navSection = container;
    }

    Dom.addClass(navContainer, CLASS_OPEN);
    navSection.style.display = "block";
    this.animation.add({
      targets: navSection,
      duration: ANIMATION_BODY_DURATION,
      easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
      height: animateContainer ? navContainer.scrollHeight : navSection.scrollHeight,
      complete: function complete() {
        Dom.addClass(navSection, CLASS_OPEN);
        new _DomElement["default"](navSection).setAttribute("style", "");
      }
    });

    if (navFooter) {
      var navItems = navFooter.querySelectorAll(QUERY_NAV_COLUMN);

      try {
        for (var navItems_1 = (0, _tslib.__values)(navItems), navItems_1_1 = navItems_1.next(); !navItems_1_1.done; navItems_1_1 = navItems_1.next()) {
          var item = navItems_1_1.value;
          Dom.addClass(item, CLASS_ACTIVE);
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (navItems_1_1 && !navItems_1_1.done && (_a = navItems_1["return"])) _a.call(navItems_1);
        } finally {
          if (e_2) throw e_2.error;
        }
      }

      navFooter.style.display = "block";
      this.animation.add({
        targets: navFooter,
        duration: ANIMATION_FOOTER_DURATION,
        easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
        height: navFooter.scrollHeight,
        offset: "-=" + ANIMATION_FOOTER_DURATION,
        complete: function complete() {
          Dom.addClass(navFooter, CLASS_OPEN);
          new _DomElement["default"](navFooter).setAttribute("style", "");
        }
      });
    }

    if (animateColumns === true) {
      var delay = ANIMATION_START_DELAY;

      var _loop_1 = function _loop_1(item) {
        this_1.animation.add({
          targets: item,
          duration: 0,
          offset: delay,
          complete: function complete() {
            Dom.addClass(item, CLASS_ACTIVE);
          }
        });
        delay += ANIMATION_OFFSET;
      };

      var this_1 = this;

      try {
        for (var activeItems_1 = (0, _tslib.__values)(activeItems), activeItems_1_1 = activeItems_1.next(); !activeItems_1_1.done; activeItems_1_1 = activeItems_1.next()) {
          var item = activeItems_1_1.value;

          _loop_1(item);
        }
      } catch (e_3_1) {
        e_3 = {
          error: e_3_1
        };
      } finally {
        try {
          if (activeItems_1_1 && !activeItems_1_1.done && (_b = activeItems_1["return"])) _b.call(activeItems_1);
        } finally {
          if (e_3) throw e_3.error;
        }
      }
    }
  };

  Navigation.prototype._closeSection = function (navContainer, navSection, navFooter, animateColumns, animateContainer) {
    var e_4, _a, e_5, _b;

    if (animateColumns === void 0) {
      animateColumns = true;
    }

    if (animateContainer === void 0) {
      animateContainer = false;
    }

    if (!navSection || !navContainer) {
      return;
    }

    var activeItems = navSection.querySelectorAll(QUERY_NAV_COLUMN_ACTIVE);

    if (animateContainer === true) {
      var container = navContainer;
      navContainer = navSection;
      navSection = container;
    }

    if (animateColumns === true) {
      try {
        for (var activeItems_2 = (0, _tslib.__values)(activeItems), activeItems_2_1 = activeItems_2.next(); !activeItems_2_1.done; activeItems_2_1 = activeItems_2.next()) {
          var active = activeItems_2_1.value;
          Dom.removeClass(active, CLASS_ACTIVE);
        }
      } catch (e_4_1) {
        e_4 = {
          error: e_4_1
        };
      } finally {
        try {
          if (activeItems_2_1 && !activeItems_2_1.done && (_a = activeItems_2["return"])) _a.call(activeItems_2);
        } finally {
          if (e_4) throw e_4.error;
        }
      }
    }

    this.animation.add({
      targets: navSection,
      duration: ANIMATION_BODY_DURATION,
      easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
      height: 0,
      offset: 0,
      complete: function complete() {
        Dom.removeClass(navContainer, CLASS_OPEN);
        Dom.removeClass(navSection, CLASS_OPEN);
        navSection.style.height = "";
      }
    });

    if (navFooter) {
      try {
        for (var _c = (0, _tslib.__values)(navFooter.querySelectorAll(QUERY_NAV_COLUMN_ACTIVE)), _d = _c.next(); !_d.done; _d = _c.next()) {
          var active = _d.value;
          Dom.removeClass(active, CLASS_ACTIVE);
        }
      } catch (e_5_1) {
        e_5 = {
          error: e_5_1
        };
      } finally {
        try {
          if (_d && !_d.done && (_b = _c["return"])) _b.call(_c);
        } finally {
          if (e_5) throw e_5.error;
        }
      }

      this.animation.add({
        targets: navFooter,
        duration: ANIMATION_FOOTER_DURATION,
        easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
        height: 0,
        offset: 0,
        complete: function complete() {
          Dom.removeClass(navFooter, CLASS_OPEN);
          navFooter.style.height = "";
        }
      });
    }
  };

  Navigation.prototype._handleSearchClick = function () {
    if (this._searchDesktop) {
      this._searchDesktop.open();
    }
  };
  /**
   * Initializes the navigation component.
   * @private
   */


  Navigation.prototype._initialize = function () {
    var e_6, _a, e_7, _b, e_8, _c;

    try {
      for (var _d = (0, _tslib.__values)(this._navLevel0.querySelectorAll(QUERY_NAV_LEVEL0_LINK)), _e = _d.next(); !_e.done; _e = _d.next()) {
        var navLink = _e.value;
        navLink.addEventListener("click", this._level0ClickHandler);
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (_e && !_e.done && (_a = _d["return"])) _a.call(_d);
      } finally {
        if (e_6) throw e_6.error;
      }
    }

    try {
      for (var _f = (0, _tslib.__values)(this._navLevel1.querySelectorAll(QUERY_NAV_LEVEL1_LINK)), _g = _f.next(); !_g.done; _g = _f.next()) {
        var navLink = _g.value;
        navLink.addEventListener("click", this._level1ClickHandler);
      }
    } catch (e_7_1) {
      e_7 = {
        error: e_7_1
      };
    } finally {
      try {
        if (_g && !_g.done && (_b = _f["return"])) _b.call(_f);
      } finally {
        if (e_7) throw e_7.error;
      }
    }

    this._hamburgerElement.addEventListener("click", this._level1ClickHandler); // Desktop search icon


    var searchIcon = this.element.querySelector(QUERY_SEARCH_ICON);

    if (searchIcon) {
      searchIcon.addEventListener("click", this._searchClickHandler);
    }

    try {
      for (var _h = (0, _tslib.__values)(this.element.querySelectorAll(QUERY_SEARCH_FIELD)), _j = _h.next(); !_j.done; _j = _h.next()) {
        var search = _j.value;
        var searchComponent = new _SearchInput["default"](search);

        if (Dom.hasClass(search, CLASS_SEARCH_DESKTOP) || Dom.hasClass(search.parentElement, CLASS_SEARCH_DESKTOP)) {
          this._searchDesktop = searchComponent;
        }

        this._searchComponents.push(searchComponent);
      }
    } catch (e_8_1) {
      e_8 = {
        error: e_8_1
      };
    } finally {
      try {
        if (_j && !_j.done && (_c = _h["return"])) _c.call(_h);
      } finally {
        if (e_8) throw e_8.error;
      }
    }
  };
  /**
   * Closes the navigation.
   */


  Navigation.prototype.close = function () {
    var isMoble = this._isMobile();

    var level1 = this._navLevel1.querySelector(QUERY_NAV_LINK_ACTIVE);

    var level0 = this._navLevel0.querySelector(QUERY_NAV_LINK_ACTIVE);

    if (!level1 && isMoble && Dom.hasClass(this._hamburgerElement, CLASS_ACTIVE)) {
      level1 = this._hamburgerElement;
    }

    var navItems;

    if (level1) {
      navItems = new NavigationItems(this).fromLevel1(level1);
    } else if (level0) {
      navItems = new NavigationItems(this).fromLevel0(level0);
    }

    if (navItems) {
      this._resetMainTimeline(navItems.container, navItems.section, navItems.footer);

      Dom.removeClass(navItems.link, CLASS_ACTIVE);

      this._onNavigationClosed();

      this._closeSection(navItems.container, navItems.section, navItems.footer, !isMoble, false);
    }
  };

  return Navigation;
}(_DomElement["default"]);

var NavigationItems =
/** @class */
function () {
  function NavigationItems(nav) {
    this._navigation = nav;
  }

  Object.defineProperty(NavigationItems.prototype, "link", {
    get: function get() {
      return this._link;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NavigationItems.prototype, "container", {
    get: function get() {
      return this._container;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NavigationItems.prototype, "section", {
    get: function get() {
      return this._section;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NavigationItems.prototype, "footer", {
    get: function get() {
      return this._footer;
    },
    enumerable: false,
    configurable: true
  });

  NavigationItems.prototype.fromLevel0 = function (navLink) {
    while (!Dom.hasClass(navLink, CLASS_NAV_LINK) && navLink.parentElement) {
      navLink = navLink.parentElement;
    }

    this._link = navLink;
    var toggleId = navLink.getAttribute("data-toggle");
    this._container = this._navigation._navLevel0Body;
    this._section = this._navigation._navLevel0.querySelector("#" + toggleId);
    return this;
  };

  NavigationItems.prototype.fromLevel1 = function (navLink) {
    while (navLink.parentElement) {
      if (navLink === this._navigation._hamburgerElement || Dom.hasClass(navLink, CLASS_NAV_LINK)) {
        break;
      }

      navLink = navLink.parentElement;
    }

    this._link = navLink;
    this._container = navLink.parentElement;
    this._section = this._container.querySelector(QUERY_NAV_BODY);
    this._footer = this._container.querySelector(QUERY_NAV_FOOTER);

    if (navLink === this._navigation._hamburgerElement) {
      this._container = this._navigation._navLevel1;
      this._section = this._container.querySelector(QUERY_NAV_HB_BODY);
    }

    return this;
  };

  NavigationItems.prototype.previousLevel1 = function () {
    var prev = new NavigationItems(this._navigation);
    prev._link = this._navigation._navLevel1.querySelector(QUERY_NAV_LINK_ACTIVE);
    prev._container = prev._link ? prev._link.parentElement : undefined;
    prev._section = prev._container ? prev._container.querySelector(QUERY_NAV_BODY) : undefined;
    prev._footer = prev._container ? prev._container.querySelector(QUERY_NAV_FOOTER) : undefined;
    return prev;
  };

  NavigationItems.prototype.isHamburger = function () {
    return this._link === this._navigation._hamburgerElement;
  };

  return NavigationItems;
}();

function init() {
  (0, _Utils.searchAndInitialize)(".nav", function (e) {
    new Navigation(e);
  });
}

var _default = Navigation;
exports["default"] = _default;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"../search/SearchInput":30,"@babel/runtime/helpers/interopRequireDefault":33,"@babel/runtime/helpers/interopRequireWildcard":34,"animejs":36,"tslib":43}],25:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _Utils = require("../Utils");

var _animejs = _interopRequireDefault(require("animejs"));

var _DomFunctions = require("../DomFunctions");

var _DomElement = _interopRequireDefault(require("../DomElement"));

var CLASS_OPEN = "is-open";
var CLASS_ACTIVE = "is-active";
var QUERY_SITE_WRAPPER = ".js-site-wrapper";
var QUERY_NAV_HAMBURGER = ".js-site-wrapper .js-hamburger";
var QUERY_NAV_ITEM = ".js-nav-item";
var NAV_LINK_INITIAL_SCALE = 0.9;
var ANIMATION_DURATION_LINKS = 100;
var ANIMATION_DURATION_NAV = 300;
var ANIMATION_STAGGER_DELAY = 50;
/**
 * The navigation side component definition.
 */

var NavigationSide =
/** @class */
function (_super) {
  (0, _tslib.__extends)(NavigationSide, _super);

  function NavigationSide(element) {
    var _this = _super.call(this, element) || this;

    _this._clickHandler = _this._handleClick.bind(_this);
    _this._windowClickHandler = _this._handleWindowClick.bind(_this);
    _this._siteWrapper = document.querySelector(QUERY_SITE_WRAPPER);
    _this._hamburgerElement = document.querySelector(QUERY_NAV_HAMBURGER) || document.createElement("div");
    _this._navItems = _this.element.querySelectorAll(QUERY_NAV_ITEM);

    _this._initialize();

    return _this;
  }

  NavigationSide.prototype._initialize = function () {
    this._hamburgerElement.addEventListener("click", this._clickHandler);

    this._hamburgerElement.addEventListener("touchend", this._clickHandler);
  };

  NavigationSide.prototype._handleClick = function (event) {
    (0, _Utils.preventDefault)(event);
    this.toggle();
  };

  NavigationSide.prototype._handleWindowClick = function (event) {
    var target = event.target;

    while (target !== this.element && target.parentElement) {
      target = target.parentElement;
    }

    if (target !== this.element) {
      this.close();
      return false;
    }

    return true;
  };
  /**
   * Toggles the side navigation.
   */


  NavigationSide.prototype.toggle = function () {
    if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
      this.open();
    } else {
      this.close();
    }
  };
  /**
   * Opens the slide navigation.
   */


  NavigationSide.prototype.open = function () {
    var _this = this;

    setTimeout(function () {
      window.addEventListener("click", _this._windowClickHandler);
      window.addEventListener("touchend", _this._windowClickHandler);
    }, 50);
    (0, _DomFunctions.addClass)(this._hamburgerElement, CLASS_ACTIVE);
    (0, _DomFunctions.addClass)(this.element, CLASS_OPEN);
    (0, _DomFunctions.addClass)(this._siteWrapper, CLASS_OPEN);

    var x = _animejs["default"].timeline();

    var off = ANIMATION_DURATION_NAV;

    this._navItems.forEach(function (element) {
      var el = element;
      el.style.opacity = "0";
      el.style.transform = "scale(" + NAV_LINK_INITIAL_SCALE + ")";
      x.add({
        targets: el,
        duration: ANIMATION_DURATION_LINKS,
        opacity: 1,
        scale: 1,
        easing: "linear",
        offset: off
      });
      off += ANIMATION_STAGGER_DELAY;
    });
  };
  /**
   * Closes the side navigation.
   */


  NavigationSide.prototype.close = function () {
    window.removeEventListener("click", this._windowClickHandler);
    window.removeEventListener("touchend", this._windowClickHandler);
    (0, _DomFunctions.removeClass)(this._hamburgerElement, CLASS_ACTIVE);
    (0, _DomFunctions.removeClass)(this.element, CLASS_OPEN);
    (0, _DomFunctions.removeClass)(this._siteWrapper, CLASS_OPEN);
  };
  /**
   * Destroys the component and removes all event
   * subscriptions and references.
   */


  NavigationSide.prototype.destroy = function () {
    window.removeEventListener("click", this._windowClickHandler);
    window.removeEventListener("touchend", this._windowClickHandler);
    this._windowClickHandler = null;
    this._clickHandler = null;
    this._siteWrapper = null;
    this._hamburgerElement = null;
    this._navItems = null;
  };

  return NavigationSide;
}(_DomElement["default"]);

function init() {
  (0, _Utils.searchAndInitialize)(".nav-side", function (e) {
    new NavigationSide(e);
  });
}

var _default = NavigationSide;
exports["default"] = _default;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"animejs":36,"tslib":43}],26:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.showOnHeader = showOnHeader;
exports.NotificationHeader = void 0;

var _tslib = require("tslib");

var _Utils = require("../Utils");

var _DomElement = _interopRequireDefault(require("../DomElement"));

var CLASS_NOTIFICATION = "notification-header";
var CLASS_OPEN = "notification--open";
var CLASS_BUTTON_CLOSE = "notification__close";
/**
 * Creates and shows a notification with the specified message.
 * @memberof Notification
 * @param {String} containerId - The id of the container on where to show the notification.
 * @param {String} message - The message to show.
 * @param {Notification~Click} messageClickCallback - The callback that gets called when the user clicks on the notification message text.
 * @param {Notification~Cancel} cancelCallback - The callback that gets called when the user cancels the notification by closing it.
 * @param {String} modifierClass - The css modifier class for the notification; this is an optional parameter
 * @returns {NotificationHeader} The notification header item instance.
 */

function showOnHeader(containerId, message, messageClickCallback, cancelCallback, modifierClass) {
  var containerE = document.querySelector("#" + containerId);

  if (!containerE) {
    throw new Error("Could not find the container with id " + containerId);
  }

  var containerElement = new _DomElement["default"](containerE);
  var notificationElement = new NotificationHeader();

  if (modifierClass) {
    notificationElement.addClass(modifierClass);
  }

  notificationElement.message = message;
  notificationElement.messageClickCallback = messageClickCallback;
  notificationElement.cancelCallback = cancelCallback;
  containerElement.appendChild(notificationElement);

  notificationElement._open();

  return notificationElement;
}
/**
 * A component for displaying notifications on the page-header.
 * @inner
 * @memberof Notification
 */


var NotificationHeader =
/** @class */
function (_super) {
  (0, _tslib.__extends)(NotificationHeader, _super);

  function NotificationHeader() {
    var _this = _super.call(this, "div") || this;

    _this._closeHandler = _this._handleClose.bind(_this);
    _this._clickHandler = _this._handleClick.bind(_this);

    _this._initialize();

    return _this;
  }
  /**
   * Initializes the range modal component.
   * @private
   */


  NotificationHeader.prototype._initialize = function () {
    this.addClass(CLASS_NOTIFICATION);
    this.addClass(CLASS_OPEN);
    var notificationContent = new _DomElement["default"]("div").addClass("notification__content");
    this.appendChild(notificationContent);
    this._notificationBody = new _DomElement["default"]("div").addClass("notification__body");
    notificationContent.appendChild(this._notificationBody);
    this._closeButton = new _DomElement["default"]("button").addClass(CLASS_BUTTON_CLOSE).addClass("notification-cancel").setAttribute("aria-label", "Close");
    var closeIcon = new _DomElement["default"]("i").addClass("icon").addClass("icon-022-close").setAttribute("aria-hidden", "true");

    this._closeButton.appendChild(closeIcon);

    notificationContent.appendChild(this._closeButton);
    this.element.addEventListener("click", this._clickHandler);
  };

  NotificationHeader.prototype._handleClick = function (event) {
    (0, _Utils.preventDefault)(event);
    var closeNotification = true;

    if (this._callback) {
      if (this._callback(this) === false) {
        closeNotification = false;
      }
    }

    if (closeNotification === true) {
      this.close();
    }
  };

  NotificationHeader.prototype._handleClose = function (event) {
    (0, _Utils.preventDefault)(event);
    event.stopPropagation();

    if (this._cancelCallback) {
      this._cancelCallback(this);
    }

    this.close();
  };

  NotificationHeader.prototype._close = function () {
    this.removeClass(CLASS_OPEN);

    this._closeButton.element.removeEventListener("click", this._closeHandler);

    var el = this.element;
    setTimeout(function () {
      // remove the element from the dom
      if (el && el.parentElement) {
        el.parentElement.removeChild(el);
      }
    }, 300);
  }; // called by showOnHeader


  NotificationHeader.prototype._open = function () {
    this.addClass(CLASS_OPEN);

    this._closeButton.element.addEventListener("click", this._closeHandler);

    this.dispatchEvent("opened");
  };

  Object.defineProperty(NotificationHeader.prototype, "messageClickCallback", {
    set: function set(callback) {
      this._callback = callback;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NotificationHeader.prototype, "cancelCallback", {
    /**
     * Sets the cancel callback function.
     * @param {function} - The callback function to call.
     */
    set: function set(callback) {
      this._cancelCallback = callback;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NotificationHeader.prototype, "message", {
    /**
     * Sets the notification message.
     * @param {String} - The message to set.
     */
    set: function set(value) {
      this._notificationBody.setHtml(value);
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Closes the notification.
   */

  NotificationHeader.prototype.close = function () {
    this._close();

    this.dispatchEvent("closed");
  };

  return NotificationHeader;
}(_DomElement["default"]);

exports.NotificationHeader = NotificationHeader;

},{"../DomElement":4,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"tslib":43}],27:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _animejs = _interopRequireDefault(require("animejs"));

var _Utils = require("../Utils");

var Inputs = _interopRequireWildcard(require("../Inputs"));

var _DomElement = _interopRequireDefault(require("../DomElement"));

var CLASS_HEADER = ".progress-full__bar";
var CLASS_SECTIONS = ".progress-full__sections > span";
var CLASS_SECTION_ACTIVE = "section--active";
var CLASS_INDICATOR = "indicator";
var CLASS_INDICATOR_CURRENT = "indicator--current";
var CLASS_INDICATOR_COMPLETED = "indicator--completed";
/**
 * Full progress bar component
 */

var ProgressFull =
/** @class */
function (_super) {
  (0, _tslib.__extends)(ProgressFull, _super);
  /**
   * Creates and initializes the ProgressFull component.
   * @param {DomElement} - The root element of the ProgressFull component.
   */

  function ProgressFull(element) {
    var _this = _super.call(this, element) || this;

    _this._initialize();

    return _this;
  }
  /**
   * Initializes the loader bar component.
   * @private
   */


  ProgressFull.prototype._initialize = function () {
    this._buttonClickHandler = this._handleButtonClick.bind(this);
    this._keydownHandler = this._handleKeydown.bind(this);
    this._headerElement = this.find(CLASS_HEADER);
    this._pages = this.element.querySelectorAll(CLASS_SECTIONS);
    this._minValue = 1;
    this._value = 1;
    this._total = this._pages.length;

    for (var index = 0; index < this._pages.length; index++) {
      if (this._pages[index].classList.contains(CLASS_SECTION_ACTIVE)) {
        this._value = index + 1;
      }
    }

    this._addIncicators();

    this._update(-1, this._value, false); // Apply the tab index


    var tabIndex = this.getAttribute("tabindex");

    if (tabIndex) {
      this.setAttribute("tabindex", "");

      this._headerElement.setAttribute("tabindex", tabIndex);
    }

    this._headerElement.element.addEventListener("click", this._buttonClickHandler);

    this._headerElement.element.addEventListener("keydown", this._keydownHandler);
  };

  ProgressFull.prototype._addIncicators = function () {
    for (var i = this._pages.length - 1; i >= 0; i--) {
      var indicatorElement = new _DomElement["default"]("button").addClass(CLASS_INDICATOR).setAttribute("data-value", "" + (i + 1)).setHtml((i + 1).toString());

      this._headerElement.prependChild(indicatorElement);
    }
  };

  ProgressFull.prototype._update = function (oldValue, newValue, animate) {
    if (animate === void 0) {
      animate = true;
    }

    var indicators = this._headerElement.element.childNodes;

    for (var index = 0; index < indicators.length; index++) {
      var indicatorElement = new _DomElement["default"](indicators[index]);

      if (index + 1 < this._value) {
        indicatorElement.removeClass(CLASS_INDICATOR_CURRENT).addClass(CLASS_INDICATOR_COMPLETED);
      }

      if (index + 1 === this._value) {
        indicatorElement.removeClass(CLASS_INDICATOR_COMPLETED).addClass(CLASS_INDICATOR_CURRENT);
      }

      if (index + 1 > this._value) {
        indicatorElement.removeClass(CLASS_INDICATOR_COMPLETED).removeClass(CLASS_INDICATOR_CURRENT);
      }
    }

    if (oldValue !== newValue) {
      var direction = Math.sign(oldValue - newValue);

      if (oldValue > 0 && oldValue !== newValue) {
        var oldSection_1 = new _DomElement["default"](this._pages[oldValue - 1]);

        if (animate) {
          (0, _animejs["default"])({
            targets: oldSection_1.element,
            duration: 300,
            left: 100 * direction,
            opacity: 0,
            easing: "easeInOutQuint",
            complete: function complete() {
              oldSection_1.removeClass(CLASS_SECTION_ACTIVE);
              oldSection_1.setAttribute("style", "");
            }
          });
        } else {
          oldSection_1.removeClass(CLASS_SECTION_ACTIVE);
          oldSection_1.setAttribute("style", "");
        }
      }

      var newSection_1 = new _DomElement["default"](this._pages[newValue - 1]);

      if (animate) {
        var el = newSection_1.element;
        el.style.left = -100 * direction + "px";
        el.style.opacity = "0";
        newSection_1.addClass(CLASS_SECTION_ACTIVE);
        (0, _animejs["default"])({
          targets: newSection_1.element,
          duration: 300,
          left: 0,
          opacity: 1,
          easing: "easeInOutQuint",
          complete: function complete() {
            newSection_1.setAttribute("style", "");
          }
        });
      } else {
        newSection_1.addClass(CLASS_SECTION_ACTIVE);
        newSection_1.setAttribute("style", "");
      }
    }
  };

  ProgressFull.prototype._handleButtonClick = function (event) {
    var element = new _DomElement["default"](event.target);

    if (!element.hasClass(CLASS_INDICATOR)) {
      return;
    }

    var value = element.getAttribute("data-value");
    this.value = parseFloat(value);
  };

  ProgressFull.prototype._handleKeydown = function (event) {
    var keyboardEvent = event;
    var keycode = keyboardEvent.which || keyboardEvent.keyCode;

    if (keycode === Inputs.KEY_ARROW_RIGHT) {
      this.value++;
      (0, _Utils.preventDefault)(keyboardEvent);
      return;
    }

    if (keycode === Inputs.KEY_ARROW_LEFT) {
      this.value--;
      (0, _Utils.preventDefault)(keyboardEvent);
      return;
    }

    if (keycode >= Inputs.KEY_NR_0 && keycode <= Inputs.KEY_NR_9) {
      this.value = keycode - Inputs.KEY_NR_0;
      (0, _Utils.preventDefault)(keyboardEvent);
      return;
    }
  };

  Object.defineProperty(ProgressFull.prototype, "value", {
    /**
     * Gets the current progress value in the range of 1..total.
     */
    get: function get() {
      return this._value;
    },

    /**
     * Sets the current progress.
     * @param {number} - The progress in the range of 1..total.
     */
    set: function set(val) {
      var oldValue = this._value;
      this._value = (0, _Utils.clamp)(val, this._minValue, this._total);

      this._update(oldValue, this._value, true);

      this.dispatchEvent("changed");
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ProgressFull.prototype, "total", {
    /**
     * Gets the total progress value.
     */
    get: function get() {
      return this._total;
    },
    enumerable: false,
    configurable: true
  });
  return ProgressFull;
}(_DomElement["default"]);

function init() {
  (0, _Utils.searchAndInitialize)(".progress-full", function (e) {
    new ProgressFull(e);
  });
}

var _default = ProgressFull;
exports["default"] = _default;

},{"../DomElement":4,"../Inputs":6,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"@babel/runtime/helpers/interopRequireWildcard":34,"animejs":36,"tslib":43}],28:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _animejs = _interopRequireDefault(require("animejs"));

var _Utils = require("../Utils");

var _DomElement = _interopRequireDefault(require("../DomElement"));

var CLASS_BAR = ".progress-light__bar";
var CLASS_PROGRESS = ".bar__progress";
var CLASS_PROGRESS_COMPLETED = "bar__progress--complete";
var CLASS_TICK = "bar__tick";
var CLASS_PAGE_CURRENT = ".detail__currentpage";
var CLASS_PAGE_TOTAL = ".detail__totalpage";
var CLASS_DISABLED = "arrow--disabled";
var CLASS_BUTTON_LEFT = ".arrow--left";
var CLASS_BUTTON_RIGHT = ".arrow--right";
/**
 * Light progress bar component
 */

var ProgressLight =
/** @class */
function (_super) {
  (0, _tslib.__extends)(ProgressLight, _super);
  /**
   * Creates and initializes the ProgressLight component.
   * @param {DomElement} - The root element of the ProgressLight component.
   */

  function ProgressLight(element) {
    var _this = _super.call(this, element) || this;

    _this._initialize();

    return _this;
  }
  /**
   * Initializes the loader bar component.
   * @private
   */


  ProgressLight.prototype._initialize = function () {
    this._buttonClickHandler = this._handleButtonClick.bind(this);
    this._animationCompletedHandler = this._handleAnimationCompleted.bind(this);
    this._barElement = this.find(CLASS_BAR);
    this._progressElement = this.find(CLASS_PROGRESS);
    this._pageCurrentElement = this.find(CLASS_PAGE_CURRENT);
    this._pageTotalElement = this.find(CLASS_PAGE_TOTAL);
    this._buttonLeft = this.find(CLASS_BUTTON_LEFT);
    this._buttonRight = this.find(CLASS_BUTTON_RIGHT);
    this._minValue = 1;
    this._total = Math.max(parseInt(this.getAttribute("total") || "100", 10), this._minValue);
    this._value = (0, _Utils.clamp)(parseInt(this.getAttribute("value") || "1", 10), this._minValue, this._total);

    this._layout();

    this._addTicks();

    this._update(false);

    this.enable();
  };

  ProgressLight.prototype._addTicks = function () {
    for (var i = 1; i < this._total; i++) {
      var position = this._itemWidth * i;
      var tickElement = new _DomElement["default"]("div").addClass(CLASS_TICK).setAttribute("style", "left: " + position + "%");

      this._barElement.prependChild(tickElement);
    }
  };

  ProgressLight.prototype._update = function (animate) {
    var _this = this;

    if (animate === void 0) {
      animate = true;
    }

    this._pageCurrentElement.setHtml(this._value.toString());

    this._pageTotalElement.setHtml(this._total.toString());

    var position = this._value * this._itemWidth; // Add additional width to the last element to make sure
    // the rounded border on the left is filled as well

    if (this._value === this._total) {
      position += 5;
    }

    if (this._value >= this._total) {
      this._buttonRight.addClass(CLASS_DISABLED);
    } else {
      this._buttonRight.removeClass(CLASS_DISABLED);
    }

    if (this._value <= this._minValue) {
      this._buttonLeft.addClass(CLASS_DISABLED);
    } else {
      this._buttonLeft.removeClass(CLASS_DISABLED);
    }

    var el = this._progressElement.element;

    if (animate) {
      (0, _animejs["default"])({
        targets: this._progressElement.element,
        duration: 200,
        easing: "easeInOutQuint",
        width: this._barElement.element.clientWidth * position / 100,
        complete: function complete() {
          el.style.width = position + "%";

          _this._animationCompletedHandler({});
        }
      });
    } else {
      el.style.width = position + "%";

      this._animationCompletedHandler({});
    }
  };

  ProgressLight.prototype._layout = function () {
    this._itemWidth = Math.floor(100 / this._total);
  };

  ProgressLight.prototype._handleButtonClick = function (event) {
    if (event.target === this._buttonLeft.element) {
      this.value = this._value - 1;
    } else if (event.target === this._buttonRight.element) {
      this.value = this._value + 1;
    }
  };

  ProgressLight.prototype._handleAnimationCompleted = function () {
    if (this._value === this._total) {
      this._progressElement.addClass(CLASS_PROGRESS_COMPLETED);
    } else {
      this._progressElement.removeClass(CLASS_PROGRESS_COMPLETED);
    }
  };

  Object.defineProperty(ProgressLight.prototype, "value", {
    /**
     * Gets the current progress value in the range of 1..total.
     */
    get: function get() {
      return this._value;
    },

    /**
     * Sets the current progress.
     * @param {number} - The progress in the range of 1..total.
     */
    set: function set(val) {
      this._value = (0, _Utils.clamp)(val, this._minValue, this._total);

      this._update(true);

      this.dispatchEvent("changed");
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ProgressLight.prototype, "total", {
    /**
     * Gets the total progress value.
     */
    get: function get() {
      return this._total;
    },

    /**
     * Sets the total progress value and updates the UI accordingly.
     * @param {number} - The total progress positive integer value.
     */
    set: function set(value) {
      var e_1, _a;

      if (this._total === value) {
        return;
      }

      this._total = Math.max(value, this._minValue);
      this._value = (0, _Utils.clamp)(this._value, this._minValue, this._total);

      try {
        // Clear the ticks
        for (var _b = (0, _tslib.__values)(this.element.querySelectorAll("." + CLASS_TICK)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var tick = _c.value;

          this._barElement.element.removeChild(tick);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }

      this._layout();

      this._addTicks();

      this._update(false);

      this.dispatchEvent("totalchanged");
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Enables the component.
   */

  ProgressLight.prototype.enable = function () {
    this._buttonLeft.element.addEventListener("click", this._buttonClickHandler);

    this._buttonRight.element.addEventListener("click", this._buttonClickHandler);
  };
  /**
   * Disables the component.
   */


  ProgressLight.prototype.disable = function () {
    this._buttonLeft.element.removeEventListener("click", this._buttonClickHandler);

    this._buttonRight.element.removeEventListener("click", this._buttonClickHandler);
  };

  return ProgressLight;
}(_DomElement["default"]);

function init() {
  (0, _Utils.searchAndInitialize)(".progress-light", function (e) {
    new ProgressLight(e);
  });
}

var _default = ProgressLight;
exports["default"] = _default;

},{"../DomElement":4,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"animejs":36,"tslib":43}],29:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "LoaderBar", {
  enumerable: true,
  get: function get() {
    return _LoaderBar["default"];
  }
});
Object.defineProperty(exports, "initLoaderBar", {
  enumerable: true,
  get: function get() {
    return _LoaderBar.init;
  }
});
Object.defineProperty(exports, "InputField", {
  enumerable: true,
  get: function get() {
    return _InputField["default"];
  }
});
Object.defineProperty(exports, "initInputField", {
  enumerable: true,
  get: function get() {
    return _InputField.init;
  }
});
Object.defineProperty(exports, "Textarea", {
  enumerable: true,
  get: function get() {
    return _Textarea["default"];
  }
});
Object.defineProperty(exports, "initTextarea", {
  enumerable: true,
  get: function get() {
    return _Textarea.init;
  }
});
Object.defineProperty(exports, "Select", {
  enumerable: true,
  get: function get() {
    return _Select["default"];
  }
});
Object.defineProperty(exports, "initSelect", {
  enumerable: true,
  get: function get() {
    return _Select.init;
  }
});
Object.defineProperty(exports, "Range", {
  enumerable: true,
  get: function get() {
    return _Range["default"];
  }
});
Object.defineProperty(exports, "initRange", {
  enumerable: true,
  get: function get() {
    return _Range.init;
  }
});
Object.defineProperty(exports, "Autocomplete", {
  enumerable: true,
  get: function get() {
    return _Autocomplete["default"];
  }
});
Object.defineProperty(exports, "initAutocomplete", {
  enumerable: true,
  get: function get() {
    return _Autocomplete.init;
  }
});
Object.defineProperty(exports, "ProgressLight", {
  enumerable: true,
  get: function get() {
    return _ProgressLight["default"];
  }
});
Object.defineProperty(exports, "initProgressLight", {
  enumerable: true,
  get: function get() {
    return _ProgressLight.init;
  }
});
Object.defineProperty(exports, "ProgressFull", {
  enumerable: true,
  get: function get() {
    return _ProgressFull["default"];
  }
});
Object.defineProperty(exports, "initProgressFull", {
  enumerable: true,
  get: function get() {
    return _ProgressFull.init;
  }
});
Object.defineProperty(exports, "Modal", {
  enumerable: true,
  get: function get() {
    return _Modal["default"];
  }
});
Object.defineProperty(exports, "initModal", {
  enumerable: true,
  get: function get() {
    return _Modal.init;
  }
});
Object.defineProperty(exports, "Toolbar", {
  enumerable: true,
  get: function get() {
    return _Toolbar["default"];
  }
});
Object.defineProperty(exports, "Collapse", {
  enumerable: true,
  get: function get() {
    return _Collapse["default"];
  }
});
Object.defineProperty(exports, "initCollapse", {
  enumerable: true,
  get: function get() {
    return _Collapse.init;
  }
});
Object.defineProperty(exports, "Accordion", {
  enumerable: true,
  get: function get() {
    return _Accordion["default"];
  }
});
Object.defineProperty(exports, "initAccordion", {
  enumerable: true,
  get: function get() {
    return _Accordion.init;
  }
});
Object.defineProperty(exports, "MenuFlyout", {
  enumerable: true,
  get: function get() {
    return _MenuFlyout["default"];
  }
});
Object.defineProperty(exports, "initMenuFlyout", {
  enumerable: true,
  get: function get() {
    return _MenuFlyout.init;
  }
});
Object.defineProperty(exports, "Navigation", {
  enumerable: true,
  get: function get() {
    return _Navigation["default"];
  }
});
Object.defineProperty(exports, "initNavigation", {
  enumerable: true,
  get: function get() {
    return _Navigation.init;
  }
});
Object.defineProperty(exports, "NavigationSide", {
  enumerable: true,
  get: function get() {
    return _NavigationSide["default"];
  }
});
Object.defineProperty(exports, "initNavigationSide", {
  enumerable: true,
  get: function get() {
    return _NavigationSide.init;
  }
});
Object.defineProperty(exports, "SearchInput", {
  enumerable: true,
  get: function get() {
    return _SearchInput["default"];
  }
});
Object.defineProperty(exports, "initSearchInput", {
  enumerable: true,
  get: function get() {
    return _SearchInput.init;
  }
});
Object.defineProperty(exports, "EmptyState", {
  enumerable: true,
  get: function get() {
    return _EmptyState["default"];
  }
});
Object.defineProperty(exports, "initEmptyState", {
  enumerable: true,
  get: function get() {
    return _EmptyState.init;
  }
});
Object.defineProperty(exports, "Carousel", {
  enumerable: true,
  get: function get() {
    return _Carousel["default"];
  }
});
Object.defineProperty(exports, "initCarousel", {
  enumerable: true,
  get: function get() {
    return _Carousel.init;
  }
});
Object.defineProperty(exports, "Table", {
  enumerable: true,
  get: function get() {
    return _Table["default"];
  }
});
Object.defineProperty(exports, "initTable", {
  enumerable: true,
  get: function get() {
    return _Table.init;
  }
});
Object.defineProperty(exports, "PieChart", {
  enumerable: true,
  get: function get() {
    return _PieChart["default"];
  }
});
Object.defineProperty(exports, "initPieChart", {
  enumerable: true,
  get: function get() {
    return _PieChart.init;
  }
});
Object.defineProperty(exports, "BarChartHorizontal", {
  enumerable: true,
  get: function get() {
    return _BarChartHorizontal["default"];
  }
});
Object.defineProperty(exports, "initBarChartHorizontal", {
  enumerable: true,
  get: function get() {
    return _BarChartHorizontal.init;
  }
});
Object.defineProperty(exports, "BarChartVertical", {
  enumerable: true,
  get: function get() {
    return _BarChartVertical["default"];
  }
});
Object.defineProperty(exports, "initBarChartVertical", {
  enumerable: true,
  get: function get() {
    return _BarChartVertical.init;
  }
});
exports.Notification = exports.utils = void 0;

var utils = _interopRequireWildcard(require("./Utils"));

exports.utils = utils;

var _LoaderBar = _interopRequireWildcard(require("./loader/LoaderBar"));

var _InputField = _interopRequireWildcard(require("./form/InputField"));

var _Textarea = _interopRequireWildcard(require("./form/Textarea"));

var _Select = _interopRequireWildcard(require("./form/Select"));

var _Range = _interopRequireWildcard(require("./form/Range"));

var _Autocomplete = _interopRequireWildcard(require("./form/Autocomplete"));

var _ProgressLight = _interopRequireWildcard(require("./progress/ProgressLight"));

var _ProgressFull = _interopRequireWildcard(require("./progress/ProgressFull"));

var _Modal = _interopRequireWildcard(require("./modal/Modal"));

var _Toolbar = _interopRequireDefault(require("./toolbar/Toolbar"));

var Notification = _interopRequireWildcard(require("./notification/Notification"));

exports.Notification = Notification;

var _Collapse = _interopRequireWildcard(require("./collapse/Collapse"));

var _Accordion = _interopRequireWildcard(require("./accordion/Accordion"));

var _MenuFlyout = _interopRequireWildcard(require("./menu/MenuFlyout"));

var _Navigation = _interopRequireWildcard(require("./navigation/Navigation"));

var _NavigationSide = _interopRequireWildcard(require("./navigation/NavigationSide"));

var _SearchInput = _interopRequireWildcard(require("./search/SearchInput"));

var _EmptyState = _interopRequireWildcard(require("./empty-states/EmptyState"));

var _Carousel = _interopRequireWildcard(require("./carousel/Carousel"));

var _Table = _interopRequireWildcard(require("./table/Table"));

var _PieChart = _interopRequireWildcard(require("./charts/PieChart"));

var _BarChartHorizontal = _interopRequireWildcard(require("./charts/BarChartHorizontal"));

var _BarChartVertical = _interopRequireWildcard(require("./charts/BarChartVertical"));

},{"./Utils":7,"./accordion/Accordion":8,"./carousel/Carousel":9,"./charts/BarChartHorizontal":10,"./charts/BarChartVertical":11,"./charts/PieChart":13,"./collapse/Collapse":14,"./empty-states/EmptyState":15,"./form/Autocomplete":16,"./form/InputField":17,"./form/Range":18,"./form/Select":19,"./form/Textarea":20,"./loader/LoaderBar":21,"./menu/MenuFlyout":22,"./modal/Modal":23,"./navigation/Navigation":24,"./navigation/NavigationSide":25,"./notification/Notification":26,"./progress/ProgressFull":27,"./progress/ProgressLight":28,"./search/SearchInput":30,"./table/Table":31,"./toolbar/Toolbar":32,"@babel/runtime/helpers/interopRequireDefault":33,"@babel/runtime/helpers/interopRequireWildcard":34}],30:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _animejs = _interopRequireDefault(require("animejs"));

var _DomElement = _interopRequireDefault(require("../DomElement"));

var Inputs = _interopRequireWildcard(require("../Inputs"));

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

var QUERY_SEARCH_INPUT = "input.search__field";
var QUERY_BTN_CLOSE = ".search__icon-close";
var QUERY_LIVE_SUGESTIONS = ".js-suggestions";
var QUERY_LIVE_FOOTER = ".js-footer";
var CLASS_ACTIVE = "is-active";
var CLASS_OPEN = "is-open";
var CLASS_SEARCH = "search";
var ANIMATION_SUGGESTIONS_DURATION = 300;
var ANIMATION_FOOTER_DURATION = 100;
var ANIMATION_FOOTER_DELAY = ANIMATION_SUGGESTIONS_DURATION - ANIMATION_FOOTER_DURATION;
/**
 * The search input component definition.
 */

var SearchInput =
/** @class */
function (_super) {
  (0, _tslib.__extends)(SearchInput, _super);

  function SearchInput(element) {
    var _this = _super.call(this, element) || this;

    _this._isOpen = false;
    _this._input = _this.element.querySelector(QUERY_SEARCH_INPUT);
    _this._form = _this.element.querySelector("form");
    _this._btnClose = _this.element.querySelector(QUERY_BTN_CLOSE);
    var liveSearch = (0, _DomFunctions.getAttributeReference)(_this.element, "data-live");

    if (liveSearch) {
      _this._liveSuggestions = liveSearch.querySelector(QUERY_LIVE_SUGESTIONS) || undefined;
      _this._liveFooter = liveSearch.querySelector(QUERY_LIVE_FOOTER) || undefined;

      if (_this._liveSuggestions) {
        _this._liveContainer = _this._liveSuggestions.parentNode || undefined;
      }
    }

    _this._focusHandler = _this._handleInputFocus.bind(_this);
    _this._blurHandler = _this._handleInputBlur.bind(_this);
    _this._closeHandler = _this.close.bind(_this);
    _this._windowClickHandler = _this._handleWindowClick.bind(_this);
    _this._keydownHandler = _this._handleKeydown.bind(_this);
    _this._resizeHandler = _this._handleResize.bind(_this);

    _this._initialize();

    return _this;
  }

  SearchInput.prototype._initialize = function () {
    this._input.addEventListener("focus", this._focusHandler);

    this._input.addEventListener("blur", this._blurHandler);

    if ((0, _Utils.internetExplorerOrEdgeVersion)() > 0) {
      // This is a workaround for IE browsers where a focused
      // input's cursor bleeds trough even if hidden
      window.addEventListener("resize", this._resizeHandler);
      window.addEventListener("orientationchange", this._resizeHandler);
    }

    if (this._btnClose) {
      this._btnClose.addEventListener("click", this._closeHandler);
    }
  };

  SearchInput.prototype._handleInputFocus = function () {
    this.addClass(CLASS_ACTIVE);
  };

  SearchInput.prototype._handleInputBlur = function () {
    this.removeClass(CLASS_ACTIVE);
  };

  SearchInput.prototype._handleWindowClick = function (event) {
    var target = event.target;

    if (!(0, _DomFunctions.parentWithClass)(target, CLASS_SEARCH)) {
      this.close();
      return false;
    }

    return true;
  };

  SearchInput.prototype._handleKeydown = function (event) {
    var keycode = event.which || event.keyCode;

    if (keycode === Inputs.KEY_ESCAPE) {
      this.close();
      (0, _Utils.preventDefault)(event);
    }
  };

  SearchInput.prototype._handleResize = function () {
    var style = window.getComputedStyle(this.element);

    if (style.display === "none") {
      this._input.blur();
    }
  };

  SearchInput.prototype._resetMainTimeline = function () {
    if (this.animation) {
      this.animation.pause();
    }

    _animejs["default"].remove(this._liveSuggestions);

    _animejs["default"].remove(this._liveFooter);

    this.animation = _animejs["default"].timeline();
  };

  Object.defineProperty(SearchInput.prototype, "value", {
    /**
     * Gets the search input text content.
     * @returns {String} The input text.
     */
    get: function get() {
      return this._input.value;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Opens/activates the search input.
   */

  SearchInput.prototype.open = function () {
    var _this = this;

    this.addClass(CLASS_OPEN);

    this._input.focus();

    setTimeout(function () {
      window.addEventListener("click", _this._windowClickHandler);
      window.addEventListener("touchend", _this._windowClickHandler);
      window.addEventListener("keydown", _this._keydownHandler);
    }, 50);
  };
  /**
   * Closes/deactivates the search input.
   */


  SearchInput.prototype.close = function () {
    this._form.reset();

    this.removeClass(CLASS_OPEN);
    this.closeLiveSearch();
    window.removeEventListener("click", this._windowClickHandler);
    window.removeEventListener("touchend", this._windowClickHandler);
    window.removeEventListener("keydown", this._keydownHandler);
  };
  /**
   * Opens the live search suggestions.
   */


  SearchInput.prototype.openLiveSearch = function () {
    var _this = this;

    if (!this._liveSuggestions || this._isOpen) {
      return;
    }

    this._isOpen = true;
    (0, _DomFunctions.addClass)(this._liveContainer, CLASS_OPEN);

    this._resetMainTimeline();

    this._liveSuggestions.style.display = "block";
    this.animation.add({
      targets: this._liveSuggestions,
      duration: ANIMATION_SUGGESTIONS_DURATION,
      height: this._liveSuggestions.scrollHeight + "px",
      easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
      complete: function complete() {
        var domEl = new _DomElement["default"](_this._liveSuggestions);
        domEl.addClass(CLASS_OPEN);
        domEl.setAttribute("style", "");
      }
    });

    if (this._liveFooter) {
      this._liveFooter.style.display = "block";
      this.animation.add({
        targets: this._liveFooter,
        duration: ANIMATION_FOOTER_DURATION,
        height: this._liveFooter.scrollHeight + "px",
        easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
        offset: ANIMATION_FOOTER_DELAY,
        complete: function complete() {
          var domEl = new _DomElement["default"](_this._liveFooter);
          domEl.addClass(CLASS_OPEN);
          domEl.setAttribute("style", "");
        }
      });
    }
  };
  /**
   * Closes the live search suggestions.
   */


  SearchInput.prototype.closeLiveSearch = function () {
    var _this = this;

    if (!this._liveSuggestions || !this.isOpen) {
      return;
    }

    this._isOpen = false;

    this._resetMainTimeline();

    this._liveSuggestions.style.display = "block";
    this.animation.add({
      targets: this._liveSuggestions,
      duration: ANIMATION_SUGGESTIONS_DURATION,
      height: 0,
      easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
      complete: function complete() {
        var domEl = new _DomElement["default"](_this._liveSuggestions);
        domEl.removeClass(CLASS_OPEN);
        domEl.setAttribute("style", "");
        (0, _DomFunctions.removeClass)(_this._liveContainer, CLASS_OPEN);
      }
    });

    if (this._liveFooter) {
      this._liveFooter.style.display = "block";
      this.animation.add({
        targets: this._liveFooter,
        duration: ANIMATION_FOOTER_DURATION,
        height: 0,
        easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
        offset: 0,
        complete: function complete() {
          var domEl = new _DomElement["default"](_this._liveFooter);
          domEl.removeClass(CLASS_OPEN);
          domEl.setAttribute("style", "");
        }
      });
    }
  };
  /**
   * Destroys the component and clears all references.
   */


  SearchInput.prototype.destroy = function () {
    window.removeEventListener("click", this._windowClickHandler);
    window.removeEventListener("touchend", this._windowClickHandler);
    window.removeEventListener("keydown", this._keydownHandler);

    this._input.removeEventListener("focus", this._focusHandler);

    this._input.removeEventListener("blur", this._blurHandler);

    window.removeEventListener("resize", this._resizeHandler);
    window.removeEventListener("orientationchange", this._resizeHandler);

    if (this._btnClose) {
      this._btnClose.removeEventListener("click", this._closeHandler);
    }

    this._input = null;
    this._form = null;
    this._btnClose = null;
    this._focusHandler = null;
    this._blurHandler = null;
    this._closeHandler = null;
    this._windowClickHandler = null;
    this._keydownHandler = null;
    this._liveSuggestions = null;
    this._liveFooter = null;
  };
  /**
   * Determines if the SearchInput is open/visible.
   * @return {Boolean} - True if open; otherwise false.
   */


  SearchInput.prototype.isOpen = function () {
    return this.hasClass(CLASS_OPEN);
  };

  return SearchInput;
}(_DomElement["default"]);

function init() {
  (0, _Utils.searchAndInitialize)(".search.search__input", function (e) {
    new SearchInput(e);
  });
}

var _default = SearchInput;
exports["default"] = _default;

},{"../DomElement":4,"../DomFunctions":5,"../Inputs":6,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"@babel/runtime/helpers/interopRequireWildcard":34,"animejs":36,"tslib":43}],31:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports["default"] = void 0;

var _tslib = require("tslib");

var _Utils = require("../Utils");

var _DomElement = _interopRequireDefault(require("../DomElement"));

var Dom = _interopRequireWildcard(require("../DomFunctions"));

var QUERY_HEADER = "thead th";
var CLASS_SORTED_ASCENDING = "js-ascending";
var CLASS_SORTED_DESCENDING = "js-descending";
var CLASS_ARROW = "arrow-icon";
/**
 * The Table component. Adds additional capabilities to standard HTML 5 tables.
 */

var Table =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Table, _super);
  /**
   * Creates a new instance of the table component.
   */

  function Table(element) {
    var _this = _super.call(this, element) || this;

    _this._headerClickHandler = _this._handleHeaderClick.bind(_this);
    _this._body = _this.element.querySelector("tbody");
    _this._rows = _this._body.getElementsByTagName("tr");

    _this._initialize();

    return _this;
  }

  Table.prototype._initialize = function () {
    var e_1, _a;

    try {
      for (var _b = (0, _tslib.__values)(this.element.querySelectorAll(QUERY_HEADER)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var header = _c.value;

        if (header.getAttribute("data-type")) {
          header.addEventListener("click", this._headerClickHandler);
          var arrowElement = new _DomElement["default"]("div").addClass(CLASS_ARROW).element;
          header.appendChild(arrowElement);
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  };

  Table.prototype._handleHeaderClick = function (e) {
    var th = e.target;
    this.sort(th);
  };
  /**
   * Sorts the table according to the specified table header element.
   * The column is sorted ascending by default if no direction is specified and no
   * existing sort order class is found in the markup.
   *
   * If the displayed data is not suitable for sorting `<td/>` elements can define a `data-value` attribute
   * which is then used for the data-source.
   *
   * @param {TableHeader} tableHeader The header element of the row to sort by.
   * @param {Number} direction The direction to sort, `1` for ascending, `-1` for descending order. This parameter is optional.
   * @param {function} equalityComparer The equiality comparer function to compare individual cell values.
   */


  Table.prototype.sort = function (tableHeader, direction, equalityComparer) {
    var e_2, _a;

    if (!tableHeader || tableHeader.tagName !== "TH") {
      throw new Error("The parameter 'tableHeader' must be a valid column header node");
    }

    if (direction !== 1 && direction !== -1 && direction) {
      throw new Error("Parameter out of range, parameter 'direction' with value '" + direction + "' must be either -1, 1 or undefined");
    }

    var columnIndex = tableHeader.cellIndex;

    if (!equalityComparer) {
      var dataType = tableHeader.getAttribute("data-type");
      equalityComparer = this._getComparer(dataType);
    }

    if (columnIndex >= this.element.querySelectorAll(QUERY_HEADER).length) {
      throw new Error("Column out of range");
    }

    try {
      for (var _b = (0, _tslib.__values)(this.element.querySelectorAll(QUERY_HEADER)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var header = _c.value;

        if (header !== tableHeader) {
          Dom.removeClass(header, CLASS_SORTED_ASCENDING);
          Dom.removeClass(header, CLASS_SORTED_DESCENDING);
        }
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    if (Dom.hasClass(tableHeader, CLASS_SORTED_ASCENDING)) {
      Dom.removeClass(tableHeader, CLASS_SORTED_ASCENDING);
      Dom.addClass(tableHeader, CLASS_SORTED_DESCENDING);
      direction = direction || -1;
    } else {
      Dom.removeClass(tableHeader, CLASS_SORTED_DESCENDING);
      Dom.addClass(tableHeader, CLASS_SORTED_ASCENDING);
      direction = direction || 1;
    }

    this._quicksort(columnIndex, 0, this._rows.length - 1, direction, equalityComparer);
  };

  Table.prototype._getCell = function (column, row) {
    return this._rows[row].cells[column];
  };

  Table.prototype._getRow = function (row) {
    return this._rows[row];
  };

  Table.prototype._getComparer = function (dataType) {
    switch (dataType) {
      case "number":
        {
          // parse the string as a number
          return function (a, b) {
            return parseFloat(a) - parseFloat(b);
          };
        }

      default:
        {
          // compare strings
          return function (a, b) {
            if (a < b) {
              return -1;
            }

            if (a > b) {
              return 1;
            }

            return 0;
          };
        }
    }
  };

  Table.prototype._quicksort = function (column, left, right, direction, equalityComparer) {
    if (direction === void 0) {
      direction = 1;
    }

    if (right - left > 0) {
      var partition = this._partition(column, left, right, direction, equalityComparer);

      if (left < partition - 1) {
        this._quicksort(column, left, partition - 1, direction, equalityComparer);
      }

      if (partition < right) {
        this._quicksort(column, partition, right, direction, equalityComparer);
      }
    }
  };

  Table.prototype._partition = function (column, left, right, direction, equalityComparer) {
    if (direction === void 0) {
      direction = 1;
    }

    var pivot = this._getCell(column, Math.floor((right + left) / 2));

    var i = left;
    var j = right;

    while (i <= j) {
      while (this._equals(this._getCell(column, i), pivot, equalityComparer) * direction < 0) {
        i++;
      }

      while (this._equals(this._getCell(column, j), pivot, equalityComparer) * direction > 0) {
        j--;
      }

      if (i <= j) {
        this._swap(i, j);

        i++;
        j--;
      }
    }

    return i;
  };

  Table.prototype._equals = function (a, b, equalityComparer) {
    var dataA = a.getAttribute("data-value");
    var dataB = b.getAttribute("data-value");
    dataA = dataA || a.textContent || a.innerText;
    dataB = dataB || b.textContent || b.innerText;
    return equalityComparer(dataA, dataB);
  };

  Table.prototype._swap = function (i, j) {
    var tmpNode = this._body.replaceChild(this._getRow(i), this._getRow(j));

    var referenceRow = this._getRow(i);

    if (!referenceRow) {
      this._body.appendChild(tmpNode);
    } else {
      this._body.insertBefore(tmpNode, referenceRow);
    }
  };
  /**
   * Destroys the component and clears all references.
   */


  Table.prototype.destroy = function () {
    var e_3, _a;

    try {
      for (var _b = (0, _tslib.__values)(this.element.querySelectorAll(QUERY_HEADER)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var header = _c.value;
        header.removeEventListener("click", this._headerClickHandler);
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    this._headerClickHandler = null;
    this._body = null;
    this._rows = null;
  };

  return Table;
}(_DomElement["default"]);

function init() {
  (0, _Utils.searchAndInitialize)("table", function (e) {
    new Table(e);
  });
}

var _default = Table;
exports["default"] = _default;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"@babel/runtime/helpers/interopRequireDefault":33,"@babel/runtime/helpers/interopRequireWildcard":34,"tslib":43}],32:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _tslib = require("tslib");

var _animejs = _interopRequireDefault(require("animejs"));

var _DomElement = _interopRequireDefault(require("../DomElement"));

var CLASS_ITEMS = ".toolbar__item";
var CLASS_SHOW = "item--show";
var ANIMATION_START_DELAY = 100;
var ANIMATION_OFFSET = 50;
/**
 * Toolbar component. Use this component to show and hide the
 * individual toolbar items.
 */

var Toolbar =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Toolbar, _super);

  function Toolbar() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * Makes the toolbar items visible.
   */


  Toolbar.prototype.show = function () {
    var delay = ANIMATION_START_DELAY;
    var items = this.element.querySelectorAll(CLASS_ITEMS);

    var timeline = _animejs["default"].timeline();

    var _loop_1 = function _loop_1(index) {
      timeline.add({
        targets: items[index],
        duration: 0,
        offset: delay,
        complete: function complete() {
          items[index].classList.add(CLASS_SHOW);
        }
      });
      delay += ANIMATION_OFFSET;
    };

    for (var index = 0; index < items.length; index++) {
      _loop_1(index);
    }
  };
  /**
   * Hides the toolbar items.
   */


  Toolbar.prototype.hide = function () {
    var delay = ANIMATION_START_DELAY;
    var items = this.element.querySelectorAll(CLASS_ITEMS);

    var timeline = _animejs["default"].timeline();

    var _loop_2 = function _loop_2(index) {
      timeline.add({
        targets: items[index],
        duration: 0,
        offset: delay,
        complete: function complete() {
          items[index].classList.remove(CLASS_SHOW);
        }
      });
      delay += ANIMATION_OFFSET;
    };

    for (var index = items.length - 1; index >= 0; index--) {
      _loop_2(index);
    }
  };
  /**
   * Toggles the toolbar items visibility.
   */


  Toolbar.prototype.toggle = function () {
    if (this.element.querySelectorAll("." + CLASS_SHOW).length === 0) {
      this.show();
    } else {
      this.hide();
    }
  };

  return Toolbar;
}(_DomElement["default"]);

var _default = Toolbar;
exports["default"] = _default;

},{"../DomElement":4,"@babel/runtime/helpers/interopRequireDefault":33,"animejs":36,"tslib":43}],33:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
},{}],34:[function(require,module,exports){
var _typeof = require("../helpers/typeof");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;
},{"../helpers/typeof":35}],35:[function(require,module,exports){
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
},{}],36:[function(require,module,exports){
/*
 * anime.js v3.1.0
 * (c) 2019 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */

'use strict';

// Defaults

var defaultInstanceSettings = {
  update: null,
  begin: null,
  loopBegin: null,
  changeBegin: null,
  change: null,
  changeComplete: null,
  loopComplete: null,
  complete: null,
  loop: 1,
  direction: 'normal',
  autoplay: true,
  timelineOffset: 0
};

var defaultTweenSettings = {
  duration: 1000,
  delay: 0,
  endDelay: 0,
  easing: 'easeOutElastic(1, .5)',
  round: 0
};

var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective'];

// Caching

var cache = {
  CSS: {},
  springs: {}
};

// Utils

function minMax(val, min, max) {
  return Math.min(Math.max(val, min), max);
}

function stringContains(str, text) {
  return str.indexOf(text) > -1;
}

function applyArguments(func, args) {
  return func.apply(null, args);
}

var is = {
  arr: function (a) { return Array.isArray(a); },
  obj: function (a) { return stringContains(Object.prototype.toString.call(a), 'Object'); },
  pth: function (a) { return is.obj(a) && a.hasOwnProperty('totalLength'); },
  svg: function (a) { return a instanceof SVGElement; },
  inp: function (a) { return a instanceof HTMLInputElement; },
  dom: function (a) { return a.nodeType || is.svg(a); },
  str: function (a) { return typeof a === 'string'; },
  fnc: function (a) { return typeof a === 'function'; },
  und: function (a) { return typeof a === 'undefined'; },
  hex: function (a) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a); },
  rgb: function (a) { return /^rgb/.test(a); },
  hsl: function (a) { return /^hsl/.test(a); },
  col: function (a) { return (is.hex(a) || is.rgb(a) || is.hsl(a)); },
  key: function (a) { return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes'; }
};

// Easings

function parseEasingParameters(string) {
  var match = /\(([^)]+)\)/.exec(string);
  return match ? match[1].split(',').map(function (p) { return parseFloat(p); }) : [];
}

// Spring solver inspired by Webkit Copyright © 2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js

function spring(string, duration) {

  var params = parseEasingParameters(string);
  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
  var velocity =  minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

  function solver(t) {
    var progress = duration ? (duration * t) / 1000 : t;
    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a + b * progress) * Math.exp(-progress * w0);
    }
    if (t === 0 || t === 1) { return t; }
    return 1 - progress;
  }

  function getDuration() {
    var cached = cache.springs[string];
    if (cached) { return cached; }
    var frame = 1/6;
    var elapsed = 0;
    var rest = 0;
    while(true) {
      elapsed += frame;
      if (solver(elapsed) === 1) {
        rest++;
        if (rest >= 16) { break; }
      } else {
        rest = 0;
      }
    }
    var duration = elapsed * frame * 1000;
    cache.springs[string] = duration;
    return duration;
  }

  return duration ? solver : getDuration;

}

// Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function

function steps(steps) {
  if ( steps === void 0 ) steps = 10;

  return function (t) { return Math.round(t * steps) * (1 / steps); };
}

// BezierEasing https://github.com/gre/bezier-easing

var bezier = (function () {

  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1 }
  function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1 }
  function C(aA1)      { return 3.0 * aA1 }

  function calcBezier(aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT }
  function getSlope(aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1) }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX, currentT, i = 0;
    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) { aB = currentT; } else { aA = currentT; }
    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);
    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < 4; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0.0) { return aGuessT; }
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }

  function bezier(mX1, mY1, mX2, mY2) {

    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) { return; }
    var sampleValues = new Float32Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {

      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;

      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= 0.001) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }

    }

    return function (x) {
      if (mX1 === mY1 && mX2 === mY2) { return x; }
      if (x === 0 || x === 1) { return x; }
      return calcBezier(getTForX(x), mY1, mY2);
    }

  }

  return bezier;

})();

var penner = (function () {

  // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)

  var eases = { linear: function () { return function (t) { return t; }; } };

  var functionEasings = {
    Sine: function () { return function (t) { return 1 - Math.cos(t * Math.PI / 2); }; },
    Circ: function () { return function (t) { return 1 - Math.sqrt(1 - t * t); }; },
    Back: function () { return function (t) { return t * t * (3 * t - 2); }; },
    Bounce: function () { return function (t) {
      var pow2, b = 4;
      while (t < (( pow2 = Math.pow(2, --b)) - 1) / 11) {}
      return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow(( pow2 * 3 - 2 ) / 22 - t, 2)
    }; },
    Elastic: function (amplitude, period) {
      if ( amplitude === void 0 ) amplitude = 1;
      if ( period === void 0 ) period = .5;

      var a = minMax(amplitude, 1, 10);
      var p = minMax(period, .1, 2);
      return function (t) {
        return (t === 0 || t === 1) ? t : 
          -a * Math.pow(2, 10 * (t - 1)) * Math.sin((((t - 1) - (p / (Math.PI * 2) * Math.asin(1 / a))) * (Math.PI * 2)) / p);
      }
    }
  };

  var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];

  baseEasings.forEach(function (name, i) {
    functionEasings[name] = function () { return function (t) { return Math.pow(t, i + 2); }; };
  });

  Object.keys(functionEasings).forEach(function (name) {
    var easeIn = functionEasings[name];
    eases['easeIn' + name] = easeIn;
    eases['easeOut' + name] = function (a, b) { return function (t) { return 1 - easeIn(a, b)(1 - t); }; };
    eases['easeInOut' + name] = function (a, b) { return function (t) { return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 
      1 - easeIn(a, b)(t * -2 + 2) / 2; }; };
  });

  return eases;

})();

function parseEasings(easing, duration) {
  if (is.fnc(easing)) { return easing; }
  var name = easing.split('(')[0];
  var ease = penner[name];
  var args = parseEasingParameters(easing);
  switch (name) {
    case 'spring' : return spring(easing, duration);
    case 'cubicBezier' : return applyArguments(bezier, args);
    case 'steps' : return applyArguments(steps, args);
    default : return applyArguments(ease, args);
  }
}

// Strings

function selectString(str) {
  try {
    var nodes = document.querySelectorAll(str);
    return nodes;
  } catch(e) {
    return;
  }
}

// Arrays

function filterArray(arr, callback) {
  var len = arr.length;
  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
  var result = [];
  for (var i = 0; i < len; i++) {
    if (i in arr) {
      var val = arr[i];
      if (callback.call(thisArg, val, i, arr)) {
        result.push(val);
      }
    }
  }
  return result;
}

function flattenArray(arr) {
  return arr.reduce(function (a, b) { return a.concat(is.arr(b) ? flattenArray(b) : b); }, []);
}

function toArray(o) {
  if (is.arr(o)) { return o; }
  if (is.str(o)) { o = selectString(o) || o; }
  if (o instanceof NodeList || o instanceof HTMLCollection) { return [].slice.call(o); }
  return [o];
}

function arrayContains(arr, val) {
  return arr.some(function (a) { return a === val; });
}

// Objects

function cloneObject(o) {
  var clone = {};
  for (var p in o) { clone[p] = o[p]; }
  return clone;
}

function replaceObjectProps(o1, o2) {
  var o = cloneObject(o1);
  for (var p in o1) { o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p]; }
  return o;
}

function mergeObjects(o1, o2) {
  var o = cloneObject(o1);
  for (var p in o2) { o[p] = is.und(o1[p]) ? o2[p] : o1[p]; }
  return o;
}

// Colors

function rgbToRgba(rgbValue) {
  var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
  return rgb ? ("rgba(" + (rgb[1]) + ",1)") : rgbValue;
}

function hexToRgba(hexValue) {
  var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  var hex = hexValue.replace(rgx, function (m, r, g, b) { return r + r + g + g + b + b; } );
  var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  var r = parseInt(rgb[1], 16);
  var g = parseInt(rgb[2], 16);
  var b = parseInt(rgb[3], 16);
  return ("rgba(" + r + "," + g + "," + b + ",1)");
}

function hslToRgba(hslValue) {
  var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
  var h = parseInt(hsl[1], 10) / 360;
  var s = parseInt(hsl[2], 10) / 100;
  var l = parseInt(hsl[3], 10) / 100;
  var a = hsl[4] || 1;
  function hue2rgb(p, q, t) {
    if (t < 0) { t += 1; }
    if (t > 1) { t -= 1; }
    if (t < 1/6) { return p + (q - p) * 6 * t; }
    if (t < 1/2) { return q; }
    if (t < 2/3) { return p + (q - p) * (2/3 - t) * 6; }
    return p;
  }
  var r, g, b;
  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return ("rgba(" + (r * 255) + "," + (g * 255) + "," + (b * 255) + "," + a + ")");
}

function colorToRgb(val) {
  if (is.rgb(val)) { return rgbToRgba(val); }
  if (is.hex(val)) { return hexToRgba(val); }
  if (is.hsl(val)) { return hslToRgba(val); }
}

// Units

function getUnit(val) {
  var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
  if (split) { return split[1]; }
}

function getTransformUnit(propName) {
  if (stringContains(propName, 'translate') || propName === 'perspective') { return 'px'; }
  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) { return 'deg'; }
}

// Values

function getFunctionValue(val, animatable) {
  if (!is.fnc(val)) { return val; }
  return val(animatable.target, animatable.id, animatable.total);
}

function getAttribute(el, prop) {
  return el.getAttribute(prop);
}

function convertPxToUnit(el, value, unit) {
  var valueUnit = getUnit(value);
  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) { return value; }
  var cached = cache.CSS[value + unit];
  if (!is.und(cached)) { return cached; }
  var baseline = 100;
  var tempEl = document.createElement(el.tagName);
  var parentEl = (el.parentNode && (el.parentNode !== document)) ? el.parentNode : document.body;
  parentEl.appendChild(tempEl);
  tempEl.style.position = 'absolute';
  tempEl.style.width = baseline + unit;
  var factor = baseline / tempEl.offsetWidth;
  parentEl.removeChild(tempEl);
  var convertedUnit = factor * parseFloat(value);
  cache.CSS[value + unit] = convertedUnit;
  return convertedUnit;
}

function getCSSValue(el, prop, unit) {
  if (prop in el.style) {
    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
    return unit ? convertPxToUnit(el, value, unit) : value;
  }
}

function getAnimationType(el, prop) {
  if (is.dom(el) && !is.inp(el) && (getAttribute(el, prop) || (is.svg(el) && el[prop]))) { return 'attribute'; }
  if (is.dom(el) && arrayContains(validTransforms, prop)) { return 'transform'; }
  if (is.dom(el) && (prop !== 'transform' && getCSSValue(el, prop))) { return 'css'; }
  if (el[prop] != null) { return 'object'; }
}

function getElementTransforms(el) {
  if (!is.dom(el)) { return; }
  var str = el.style.transform || '';
  var reg  = /(\w+)\(([^)]*)\)/g;
  var transforms = new Map();
  var m; while (m = reg.exec(str)) { transforms.set(m[1], m[2]); }
  return transforms;
}

function getTransformValue(el, propName, animatable, unit) {
  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
  var value = getElementTransforms(el).get(propName) || defaultVal;
  if (animatable) {
    animatable.transforms.list.set(propName, value);
    animatable.transforms['last'] = propName;
  }
  return unit ? convertPxToUnit(el, value, unit) : value;
}

function getOriginalTargetValue(target, propName, unit, animatable) {
  switch (getAnimationType(target, propName)) {
    case 'transform': return getTransformValue(target, propName, animatable, unit);
    case 'css': return getCSSValue(target, propName, unit);
    case 'attribute': return getAttribute(target, propName);
    default: return target[propName] || 0;
  }
}

function getRelativeValue(to, from) {
  var operator = /^(\*=|\+=|-=)/.exec(to);
  if (!operator) { return to; }
  var u = getUnit(to) || 0;
  var x = parseFloat(from);
  var y = parseFloat(to.replace(operator[0], ''));
  switch (operator[0][0]) {
    case '+': return x + y + u;
    case '-': return x - y + u;
    case '*': return x * y + u;
  }
}

function validateValue(val, unit) {
  if (is.col(val)) { return colorToRgb(val); }
  if (/\s/g.test(val)) { return val; }
  var originalUnit = getUnit(val);
  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;
  if (unit) { return unitLess + unit; }
  return unitLess;
}

// getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744

function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function getCircleLength(el) {
  return Math.PI * 2 * getAttribute(el, 'r');
}

function getRectLength(el) {
  return (getAttribute(el, 'width') * 2) + (getAttribute(el, 'height') * 2);
}

function getLineLength(el) {
  return getDistance(
    {x: getAttribute(el, 'x1'), y: getAttribute(el, 'y1')}, 
    {x: getAttribute(el, 'x2'), y: getAttribute(el, 'y2')}
  );
}

function getPolylineLength(el) {
  var points = el.points;
  var totalLength = 0;
  var previousPos;
  for (var i = 0 ; i < points.numberOfItems; i++) {
    var currentPos = points.getItem(i);
    if (i > 0) { totalLength += getDistance(previousPos, currentPos); }
    previousPos = currentPos;
  }
  return totalLength;
}

function getPolygonLength(el) {
  var points = el.points;
  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
}

// Path animation

function getTotalLength(el) {
  if (el.getTotalLength) { return el.getTotalLength(); }
  switch(el.tagName.toLowerCase()) {
    case 'circle': return getCircleLength(el);
    case 'rect': return getRectLength(el);
    case 'line': return getLineLength(el);
    case 'polyline': return getPolylineLength(el);
    case 'polygon': return getPolygonLength(el);
  }
}

function setDashoffset(el) {
  var pathLength = getTotalLength(el);
  el.setAttribute('stroke-dasharray', pathLength);
  return pathLength;
}

// Motion path

function getParentSvgEl(el) {
  var parentEl = el.parentNode;
  while (is.svg(parentEl)) {
    if (!is.svg(parentEl.parentNode)) { break; }
    parentEl = parentEl.parentNode;
  }
  return parentEl;
}

function getParentSvg(pathEl, svgData) {
  var svg = svgData || {};
  var parentSvgEl = svg.el || getParentSvgEl(pathEl);
  var rect = parentSvgEl.getBoundingClientRect();
  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
  var width = rect.width;
  var height = rect.height;
  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
  return {
    el: parentSvgEl,
    viewBox: viewBox,
    x: viewBox[0] / 1,
    y: viewBox[1] / 1,
    w: width / viewBox[2],
    h: height / viewBox[3]
  }
}

function getPath(path, percent) {
  var pathEl = is.str(path) ? selectString(path)[0] : path;
  var p = percent || 100;
  return function(property) {
    return {
      property: property,
      el: pathEl,
      svg: getParentSvg(pathEl),
      totalLength: getTotalLength(pathEl) * (p / 100)
    }
  }
}

function getPathProgress(path, progress) {
  function point(offset) {
    if ( offset === void 0 ) offset = 0;

    var l = progress + offset >= 1 ? progress + offset : 0;
    return path.el.getPointAtLength(l);
  }
  var svg = getParentSvg(path.el, path.svg);
  var p = point();
  var p0 = point(-1);
  var p1 = point(+1);
  switch (path.property) {
    case 'x': return (p.x - svg.x) * svg.w;
    case 'y': return (p.y - svg.y) * svg.h;
    case 'angle': return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
  }
}

// Decompose value

function decomposeValue(val, unit) {
  // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
  // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var value = validateValue((is.pth(val) ? val.totalLength : val), unit) + '';
  return {
    original: value,
    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
    strings: (is.str(val) || unit) ? value.split(rgx) : []
  }
}

// Animatables

function parseTargets(targets) {
  var targetsArray = targets ? (flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets))) : [];
  return filterArray(targetsArray, function (item, pos, self) { return self.indexOf(item) === pos; });
}

function getAnimatables(targets) {
  var parsed = parseTargets(targets);
  return parsed.map(function (t, i) {
    return {target: t, id: i, total: parsed.length, transforms: { list: getElementTransforms(t) } };
  });
}

// Properties

function normalizePropertyTweens(prop, tweenSettings) {
  var settings = cloneObject(tweenSettings);
  // Override duration if easing is a spring
  if (/^spring/.test(settings.easing)) { settings.duration = spring(settings.easing); }
  if (is.arr(prop)) {
    var l = prop.length;
    var isFromTo = (l === 2 && !is.obj(prop[0]));
    if (!isFromTo) {
      // Duration divided by the number of tweens
      if (!is.fnc(tweenSettings.duration)) { settings.duration = tweenSettings.duration / l; }
    } else {
      // Transform [from, to] values shorthand to a valid tween value
      prop = {value: prop};
    }
  }
  var propArray = is.arr(prop) ? prop : [prop];
  return propArray.map(function (v, i) {
    var obj = (is.obj(v) && !is.pth(v)) ? v : {value: v};
    // Default delay value should only be applied to the first tween
    if (is.und(obj.delay)) { obj.delay = !i ? tweenSettings.delay : 0; }
    // Default endDelay value should only be applied to the last tween
    if (is.und(obj.endDelay)) { obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0; }
    return obj;
  }).map(function (k) { return mergeObjects(k, settings); });
}


function flattenKeyframes(keyframes) {
  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) { return Object.keys(key); })), function (p) { return is.key(p); })
  .reduce(function (a,b) { if (a.indexOf(b) < 0) { a.push(b); } return a; }, []);
  var properties = {};
  var loop = function ( i ) {
    var propName = propertyNames[i];
    properties[propName] = keyframes.map(function (key) {
      var newKey = {};
      for (var p in key) {
        if (is.key(p)) {
          if (p == propName) { newKey.value = key[p]; }
        } else {
          newKey[p] = key[p];
        }
      }
      return newKey;
    });
  };

  for (var i = 0; i < propertyNames.length; i++) loop( i );
  return properties;
}

function getProperties(tweenSettings, params) {
  var properties = [];
  var keyframes = params.keyframes;
  if (keyframes) { params = mergeObjects(flattenKeyframes(keyframes), params); }
  for (var p in params) {
    if (is.key(p)) {
      properties.push({
        name: p,
        tweens: normalizePropertyTweens(params[p], tweenSettings)
      });
    }
  }
  return properties;
}

// Tweens

function normalizeTweenValues(tween, animatable) {
  var t = {};
  for (var p in tween) {
    var value = getFunctionValue(tween[p], animatable);
    if (is.arr(value)) {
      value = value.map(function (v) { return getFunctionValue(v, animatable); });
      if (value.length === 1) { value = value[0]; }
    }
    t[p] = value;
  }
  t.duration = parseFloat(t.duration);
  t.delay = parseFloat(t.delay);
  return t;
}

function normalizeTweens(prop, animatable) {
  var previousTween;
  return prop.tweens.map(function (t) {
    var tween = normalizeTweenValues(t, animatable);
    var tweenValue = tween.value;
    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
    var toUnit = getUnit(to);
    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
    var previousValue = previousTween ? previousTween.to.original : originalValue;
    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
    var fromUnit = getUnit(from) || getUnit(originalValue);
    var unit = toUnit || fromUnit;
    if (is.und(to)) { to = previousValue; }
    tween.from = decomposeValue(from, unit);
    tween.to = decomposeValue(getRelativeValue(to, from), unit);
    tween.start = previousTween ? previousTween.end : 0;
    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
    tween.easing = parseEasings(tween.easing, tween.duration);
    tween.isPath = is.pth(tweenValue);
    tween.isColor = is.col(tween.from.original);
    if (tween.isColor) { tween.round = 1; }
    previousTween = tween;
    return tween;
  });
}

// Tween progress

var setProgressValue = {
  css: function (t, p, v) { return t.style[p] = v; },
  attribute: function (t, p, v) { return t.setAttribute(p, v); },
  object: function (t, p, v) { return t[p] = v; },
  transform: function (t, p, v, transforms, manual) {
    transforms.list.set(p, v);
    if (p === transforms.last || manual) {
      var str = '';
      transforms.list.forEach(function (value, prop) { str += prop + "(" + value + ") "; });
      t.style.transform = str;
    }
  }
};

// Set Value helper

function setTargetsValue(targets, properties) {
  var animatables = getAnimatables(targets);
  animatables.forEach(function (animatable) {
    for (var property in properties) {
      var value = getFunctionValue(properties[property], animatable);
      var target = animatable.target;
      var valueUnit = getUnit(value);
      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
      var unit = valueUnit || getUnit(originalValue);
      var to = getRelativeValue(validateValue(value, unit), originalValue);
      var animType = getAnimationType(target, property);
      setProgressValue[animType](target, property, to, animatable.transforms, true);
    }
  });
}

// Animations

function createAnimation(animatable, prop) {
  var animType = getAnimationType(animatable.target, prop.name);
  if (animType) {
    var tweens = normalizeTweens(prop, animatable);
    var lastTween = tweens[tweens.length - 1];
    return {
      type: animType,
      property: prop.name,
      animatable: animatable,
      tweens: tweens,
      duration: lastTween.end,
      delay: tweens[0].delay,
      endDelay: lastTween.endDelay
    }
  }
}

function getAnimations(animatables, properties) {
  return filterArray(flattenArray(animatables.map(function (animatable) {
    return properties.map(function (prop) {
      return createAnimation(animatable, prop);
    });
  })), function (a) { return !is.und(a); });
}

// Create Instance

function getInstanceTimings(animations, tweenSettings) {
  var animLength = animations.length;
  var getTlOffset = function (anim) { return anim.timelineOffset ? anim.timelineOffset : 0; };
  var timings = {};
  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration; })) : tweenSettings.duration;
  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.delay; })) : tweenSettings.delay;
  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration - anim.endDelay; })) : tweenSettings.endDelay;
  return timings;
}

var instanceID = 0;

function createNewInstance(params) {
  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
  var properties = getProperties(tweenSettings, params);
  var animatables = getAnimatables(params.targets);
  var animations = getAnimations(animatables, properties);
  var timings = getInstanceTimings(animations, tweenSettings);
  var id = instanceID;
  instanceID++;
  return mergeObjects(instanceSettings, {
    id: id,
    children: [],
    animatables: animatables,
    animations: animations,
    duration: timings.duration,
    delay: timings.delay,
    endDelay: timings.endDelay
  });
}

// Core

var activeInstances = [];
var pausedInstances = [];
var raf;

var engine = (function () {
  function play() { 
    raf = requestAnimationFrame(step);
  }
  function step(t) {
    var activeInstancesLength = activeInstances.length;
    if (activeInstancesLength) {
      var i = 0;
      while (i < activeInstancesLength) {
        var activeInstance = activeInstances[i];
        if (!activeInstance.paused) {
          activeInstance.tick(t);
        } else {
          var instanceIndex = activeInstances.indexOf(activeInstance);
          if (instanceIndex > -1) {
            activeInstances.splice(instanceIndex, 1);
            activeInstancesLength = activeInstances.length;
          }
        }
        i++;
      }
      play();
    } else {
      raf = cancelAnimationFrame(raf);
    }
  }
  return play;
})();

function handleVisibilityChange() {
  if (document.hidden) {
    activeInstances.forEach(function (ins) { return ins.pause(); });
    pausedInstances = activeInstances.slice(0);
    anime.running = activeInstances = [];
  } else {
    pausedInstances.forEach(function (ins) { return ins.play(); });
  }
}

if (typeof document !== 'undefined') {
  document.addEventListener('visibilitychange', handleVisibilityChange);
}

// Public Instance

function anime(params) {
  if ( params === void 0 ) params = {};


  var startTime = 0, lastTime = 0, now = 0;
  var children, childrenLength = 0;
  var resolve = null;

  function makePromise(instance) {
    var promise = window.Promise && new Promise(function (_resolve) { return resolve = _resolve; });
    instance.finished = promise;
    return promise;
  }

  var instance = createNewInstance(params);
  var promise = makePromise(instance);

  function toggleInstanceDirection() {
    var direction = instance.direction;
    if (direction !== 'alternate') {
      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
    }
    instance.reversed = !instance.reversed;
    children.forEach(function (child) { return child.reversed = instance.reversed; });
  }

  function adjustTime(time) {
    return instance.reversed ? instance.duration - time : time;
  }

  function resetTime() {
    startTime = 0;
    lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
  }

  function seekChild(time, child) {
    if (child) { child.seek(time - child.timelineOffset); }
  }

  function syncInstanceChildren(time) {
    if (!instance.reversePlayback) {
      for (var i = 0; i < childrenLength; i++) { seekChild(time, children[i]); }
    } else {
      for (var i$1 = childrenLength; i$1--;) { seekChild(time, children[i$1]); }
    }
  }

  function setAnimationsProgress(insTime) {
    var i = 0;
    var animations = instance.animations;
    var animationsLength = animations.length;
    while (i < animationsLength) {
      var anim = animations[i];
      var animatable = anim.animatable;
      var tweens = anim.tweens;
      var tweenLength = tweens.length - 1;
      var tween = tweens[tweenLength];
      // Only check for keyframes if there is more than one tween
      if (tweenLength) { tween = filterArray(tweens, function (t) { return (insTime < t.end); })[0] || tween; }
      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
      var strings = tween.to.strings;
      var round = tween.round;
      var numbers = [];
      var toNumbersLength = tween.to.numbers.length;
      var progress = (void 0);
      for (var n = 0; n < toNumbersLength; n++) {
        var value = (void 0);
        var toNumber = tween.to.numbers[n];
        var fromNumber = tween.from.numbers[n] || 0;
        if (!tween.isPath) {
          value = fromNumber + (eased * (toNumber - fromNumber));
        } else {
          value = getPathProgress(tween.value, eased * toNumber);
        }
        if (round) {
          if (!(tween.isColor && n > 2)) {
            value = Math.round(value * round) / round;
          }
        }
        numbers.push(value);
      }
      // Manual Array.reduce for better performances
      var stringsLength = strings.length;
      if (!stringsLength) {
        progress = numbers[0];
      } else {
        progress = strings[0];
        for (var s = 0; s < stringsLength; s++) {
          var a = strings[s];
          var b = strings[s + 1];
          var n$1 = numbers[s];
          if (!isNaN(n$1)) {
            if (!b) {
              progress += n$1 + ' ';
            } else {
              progress += n$1 + b;
            }
          }
        }
      }
      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
      anim.currentValue = progress;
      i++;
    }
  }

  function setCallback(cb) {
    if (instance[cb] && !instance.passThrough) { instance[cb](instance); }
  }

  function countIteration() {
    if (instance.remaining && instance.remaining !== true) {
      instance.remaining--;
    }
  }

  function setInstanceProgress(engineTime) {
    var insDuration = instance.duration;
    var insDelay = instance.delay;
    var insEndDelay = insDuration - instance.endDelay;
    var insTime = adjustTime(engineTime);
    instance.progress = minMax((insTime / insDuration) * 100, 0, 100);
    instance.reversePlayback = insTime < instance.currentTime;
    if (children) { syncInstanceChildren(insTime); }
    if (!instance.began && instance.currentTime > 0) {
      instance.began = true;
      setCallback('begin');
    }
    if (!instance.loopBegan && instance.currentTime > 0) {
      instance.loopBegan = true;
      setCallback('loopBegin');
    }
    if (insTime <= insDelay && instance.currentTime !== 0) {
      setAnimationsProgress(0);
    }
    if ((insTime >= insEndDelay && instance.currentTime !== insDuration) || !insDuration) {
      setAnimationsProgress(insDuration);
    }
    if (insTime > insDelay && insTime < insEndDelay) {
      if (!instance.changeBegan) {
        instance.changeBegan = true;
        instance.changeCompleted = false;
        setCallback('changeBegin');
      }
      setCallback('change');
      setAnimationsProgress(insTime);
    } else {
      if (instance.changeBegan) {
        instance.changeCompleted = true;
        instance.changeBegan = false;
        setCallback('changeComplete');
      }
    }
    instance.currentTime = minMax(insTime, 0, insDuration);
    if (instance.began) { setCallback('update'); }
    if (engineTime >= insDuration) {
      lastTime = 0;
      countIteration();
      if (!instance.remaining) {
        instance.paused = true;
        if (!instance.completed) {
          instance.completed = true;
          setCallback('loopComplete');
          setCallback('complete');
          if (!instance.passThrough && 'Promise' in window) {
            resolve();
            promise = makePromise(instance);
          }
        }
      } else {
        startTime = now;
        setCallback('loopComplete');
        instance.loopBegan = false;
        if (instance.direction === 'alternate') {
          toggleInstanceDirection();
        }
      }
    }
  }

  instance.reset = function() {
    var direction = instance.direction;
    instance.passThrough = false;
    instance.currentTime = 0;
    instance.progress = 0;
    instance.paused = true;
    instance.began = false;
    instance.loopBegan = false;
    instance.changeBegan = false;
    instance.completed = false;
    instance.changeCompleted = false;
    instance.reversePlayback = false;
    instance.reversed = direction === 'reverse';
    instance.remaining = instance.loop;
    children = instance.children;
    childrenLength = children.length;
    for (var i = childrenLength; i--;) { instance.children[i].reset(); }
    if (instance.reversed && instance.loop !== true || (direction === 'alternate' && instance.loop === 1)) { instance.remaining++; }
    setAnimationsProgress(instance.reversed ? instance.duration : 0);
  };

  // Set Value helper

  instance.set = function(targets, properties) {
    setTargetsValue(targets, properties);
    return instance;
  };

  instance.tick = function(t) {
    now = t;
    if (!startTime) { startTime = now; }
    setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
  };

  instance.seek = function(time) {
    setInstanceProgress(adjustTime(time));
  };

  instance.pause = function() {
    instance.paused = true;
    resetTime();
  };

  instance.play = function() {
    if (!instance.paused) { return; }
    if (instance.completed) { instance.reset(); }
    instance.paused = false;
    activeInstances.push(instance);
    resetTime();
    if (!raf) { engine(); }
  };

  instance.reverse = function() {
    toggleInstanceDirection();
    resetTime();
  };

  instance.restart = function() {
    instance.reset();
    instance.play();
  };

  instance.reset();

  if (instance.autoplay) { instance.play(); }

  return instance;

}

// Remove targets from animation

function removeTargetsFromAnimations(targetsArray, animations) {
  for (var a = animations.length; a--;) {
    if (arrayContains(targetsArray, animations[a].animatable.target)) {
      animations.splice(a, 1);
    }
  }
}

function removeTargets(targets) {
  var targetsArray = parseTargets(targets);
  for (var i = activeInstances.length; i--;) {
    var instance = activeInstances[i];
    var animations = instance.animations;
    var children = instance.children;
    removeTargetsFromAnimations(targetsArray, animations);
    for (var c = children.length; c--;) {
      var child = children[c];
      var childAnimations = child.animations;
      removeTargetsFromAnimations(targetsArray, childAnimations);
      if (!childAnimations.length && !child.children.length) { children.splice(c, 1); }
    }
    if (!animations.length && !children.length) { instance.pause(); }
  }
}

// Stagger helpers

function stagger(val, params) {
  if ( params === void 0 ) params = {};

  var direction = params.direction || 'normal';
  var easing = params.easing ? parseEasings(params.easing) : null;
  var grid = params.grid;
  var axis = params.axis;
  var fromIndex = params.from || 0;
  var fromFirst = fromIndex === 'first';
  var fromCenter = fromIndex === 'center';
  var fromLast = fromIndex === 'last';
  var isRange = is.arr(val);
  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
  var val2 = isRange ? parseFloat(val[1]) : 0;
  var unit = getUnit(isRange ? val[1] : val) || 0;
  var start = params.start || 0 + (isRange ? val1 : 0);
  var values = [];
  var maxValue = 0;
  return function (el, i, t) {
    if (fromFirst) { fromIndex = 0; }
    if (fromCenter) { fromIndex = (t - 1) / 2; }
    if (fromLast) { fromIndex = t - 1; }
    if (!values.length) {
      for (var index = 0; index < t; index++) {
        if (!grid) {
          values.push(Math.abs(fromIndex - index));
        } else {
          var fromX = !fromCenter ? fromIndex%grid[0] : (grid[0]-1)/2;
          var fromY = !fromCenter ? Math.floor(fromIndex/grid[0]) : (grid[1]-1)/2;
          var toX = index%grid[0];
          var toY = Math.floor(index/grid[0]);
          var distanceX = fromX - toX;
          var distanceY = fromY - toY;
          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
          if (axis === 'x') { value = -distanceX; }
          if (axis === 'y') { value = -distanceY; }
          values.push(value);
        }
        maxValue = Math.max.apply(Math, values);
      }
      if (easing) { values = values.map(function (val) { return easing(val / maxValue) * maxValue; }); }
      if (direction === 'reverse') { values = values.map(function (val) { return axis ? (val < 0) ? val * -1 : -val : Math.abs(maxValue - val); }); }
    }
    var spacing = isRange ? (val2 - val1) / maxValue : val1;
    return start + (spacing * (Math.round(values[i] * 100) / 100)) + unit;
  }
}

// Timeline

function timeline(params) {
  if ( params === void 0 ) params = {};

  var tl = anime(params);
  tl.duration = 0;
  tl.add = function(instanceParams, timelineOffset) {
    var tlIndex = activeInstances.indexOf(tl);
    var children = tl.children;
    if (tlIndex > -1) { activeInstances.splice(tlIndex, 1); }
    function passThrough(ins) { ins.passThrough = true; }
    for (var i = 0; i < children.length; i++) { passThrough(children[i]); }
    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
    insParams.targets = insParams.targets || params.targets;
    var tlDuration = tl.duration;
    insParams.autoplay = false;
    insParams.direction = tl.direction;
    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
    passThrough(tl);
    tl.seek(insParams.timelineOffset);
    var ins = anime(insParams);
    passThrough(ins);
    children.push(ins);
    var timings = getInstanceTimings(children, params);
    tl.delay = timings.delay;
    tl.endDelay = timings.endDelay;
    tl.duration = timings.duration;
    tl.seek(0);
    tl.reset();
    if (tl.autoplay) { tl.play(); }
    return tl;
  };
  return tl;
}

anime.version = '3.1.0';
anime.speed = 1;
anime.running = activeInstances;
anime.remove = removeTargets;
anime.get = getOriginalTargetValue;
anime.set = setTargetsValue;
anime.convertPx = convertPxToUnit;
anime.path = getPath;
anime.setDashoffset = setDashoffset;
anime.stagger = stagger;
anime.timeline = timeline;
anime.easing = parseEasings;
anime.penner = penner;
anime.random = function (min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; };

module.exports = anime;

},{}],37:[function(require,module,exports){
!function(e,t){if("function"==typeof define&&define.amd)define(["exports"],t);else if("undefined"!=typeof exports)t(exports);else{var o={};t(o),e.bodyScrollLock=o}}(this,function(exports){"use strict";function r(e){if(Array.isArray(e)){for(var t=0,o=Array(e.length);t<e.length;t++)o[t]=e[t];return o}return Array.from(e)}Object.defineProperty(exports,"__esModule",{value:!0});var l=!1;if("undefined"!=typeof window){var e={get passive(){l=!0}};window.addEventListener("testPassive",null,e),window.removeEventListener("testPassive",null,e)}var d="undefined"!=typeof window&&window.navigator&&window.navigator.platform&&/iP(ad|hone|od)/.test(window.navigator.platform),c=[],u=!1,a=-1,s=void 0,v=void 0,f=function(t){return c.some(function(e){return!(!e.options.allowTouchMove||!e.options.allowTouchMove(t))})},m=function(e){var t=e||window.event;return!!f(t.target)||(1<t.touches.length||(t.preventDefault&&t.preventDefault(),!1))},o=function(){setTimeout(function(){void 0!==v&&(document.body.style.paddingRight=v,v=void 0),void 0!==s&&(document.body.style.overflow=s,s=void 0)})};exports.disableBodyScroll=function(i,e){if(d){if(!i)return void console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");if(i&&!c.some(function(e){return e.targetElement===i})){var t={targetElement:i,options:e||{}};c=[].concat(r(c),[t]),i.ontouchstart=function(e){1===e.targetTouches.length&&(a=e.targetTouches[0].clientY)},i.ontouchmove=function(e){var t,o,n,r;1===e.targetTouches.length&&(o=i,r=(t=e).targetTouches[0].clientY-a,!f(t.target)&&(o&&0===o.scrollTop&&0<r?m(t):(n=o)&&n.scrollHeight-n.scrollTop<=n.clientHeight&&r<0?m(t):t.stopPropagation()))},u||(document.addEventListener("touchmove",m,l?{passive:!1}:void 0),u=!0)}}else{n=e,setTimeout(function(){if(void 0===v){var e=!!n&&!0===n.reserveScrollBarGap,t=window.innerWidth-document.documentElement.clientWidth;e&&0<t&&(v=document.body.style.paddingRight,document.body.style.paddingRight=t+"px")}void 0===s&&(s=document.body.style.overflow,document.body.style.overflow="hidden")});var o={targetElement:i,options:e||{}};c=[].concat(r(c),[o])}var n},exports.clearAllBodyScrollLocks=function(){d?(c.forEach(function(e){e.targetElement.ontouchstart=null,e.targetElement.ontouchmove=null}),u&&(document.removeEventListener("touchmove",m,l?{passive:!1}:void 0),u=!1),c=[],a=-1):(o(),c=[])},exports.enableBodyScroll=function(t){if(d){if(!t)return void console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.");t.ontouchstart=null,t.ontouchmove=null,c=c.filter(function(e){return e.targetElement!==t}),u&&0===c.length&&(document.removeEventListener("touchmove",m,l?{passive:!1}:void 0),u=!1)}else(c=c.filter(function(e){return e.targetElement!==t})).length||o()}});

},{}],38:[function(require,module,exports){
/* flatpickr v4.5.7, @license MIT */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.flatpickr = factory());
}(this, function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    var HOOKS = [
        "onChange",
        "onClose",
        "onDayCreate",
        "onDestroy",
        "onKeyDown",
        "onMonthChange",
        "onOpen",
        "onParseConfig",
        "onReady",
        "onValueUpdate",
        "onYearChange",
        "onPreCalendarPosition",
    ];
    var defaults = {
        _disable: [],
        _enable: [],
        allowInput: false,
        altFormat: "F j, Y",
        altInput: false,
        altInputClass: "form-control input",
        animate: typeof window === "object" &&
            window.navigator.userAgent.indexOf("MSIE") === -1,
        ariaDateFormat: "F j, Y",
        clickOpens: true,
        closeOnSelect: true,
        conjunction: ", ",
        dateFormat: "Y-m-d",
        defaultHour: 12,
        defaultMinute: 0,
        defaultSeconds: 0,
        disable: [],
        disableMobile: false,
        enable: [],
        enableSeconds: false,
        enableTime: false,
        errorHandler: function (err) {
            return typeof console !== "undefined" && console.warn(err);
        },
        getWeek: function (givenDate) {
            var date = new Date(givenDate.getTime());
            date.setHours(0, 0, 0, 0);
            // Thursday in current week decides the year.
            date.setDate(date.getDate() + 3 - ((date.getDay() + 6) % 7));
            // January 4 is always in week 1.
            var week1 = new Date(date.getFullYear(), 0, 4);
            // Adjust to Thursday in week 1 and count number of weeks from date to week1.
            return (1 +
                Math.round(((date.getTime() - week1.getTime()) / 86400000 -
                    3 +
                    ((week1.getDay() + 6) % 7)) /
                    7));
        },
        hourIncrement: 1,
        ignoredFocusElements: [],
        inline: false,
        locale: "default",
        minuteIncrement: 5,
        mode: "single",
        nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
        noCalendar: false,
        now: new Date(),
        onChange: [],
        onClose: [],
        onDayCreate: [],
        onDestroy: [],
        onKeyDown: [],
        onMonthChange: [],
        onOpen: [],
        onParseConfig: [],
        onReady: [],
        onValueUpdate: [],
        onYearChange: [],
        onPreCalendarPosition: [],
        plugins: [],
        position: "auto",
        positionElement: undefined,
        prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
        shorthandCurrentMonth: false,
        showMonths: 1,
        static: false,
        time_24hr: false,
        weekNumbers: false,
        wrap: false
    };

    var english = {
        weekdays: {
            shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            longhand: [
                "Sunday",
                "Monday",
                "Tuesday",
                "Wednesday",
                "Thursday",
                "Friday",
                "Saturday",
            ]
        },
        months: {
            shorthand: [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec",
            ],
            longhand: [
                "January",
                "February",
                "March",
                "April",
                "May",
                "June",
                "July",
                "August",
                "September",
                "October",
                "November",
                "December",
            ]
        },
        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        firstDayOfWeek: 0,
        ordinal: function (nth) {
            var s = nth % 100;
            if (s > 3 && s < 21)
                return "th";
            switch (s % 10) {
                case 1:
                    return "st";
                case 2:
                    return "nd";
                case 3:
                    return "rd";
                default:
                    return "th";
            }
        },
        rangeSeparator: " to ",
        weekAbbreviation: "Wk",
        scrollTitle: "Scroll to increment",
        toggleTitle: "Click to toggle",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Year"
    };

    var pad = function (number) { return ("0" + number).slice(-2); };
    var int = function (bool) { return (bool === true ? 1 : 0); };
    /* istanbul ignore next */
    function debounce(func, wait, immediate) {
        if (immediate === void 0) { immediate = false; }
        var timeout;
        return function () {
            var context = this, args = arguments;
            timeout !== null && clearTimeout(timeout);
            timeout = window.setTimeout(function () {
                timeout = null;
                if (!immediate)
                    func.apply(context, args);
            }, wait);
            if (immediate && !timeout)
                func.apply(context, args);
        };
    }
    var arrayify = function (obj) {
        return obj instanceof Array ? obj : [obj];
    };

    function toggleClass(elem, className, bool) {
        if (bool === true)
            return elem.classList.add(className);
        elem.classList.remove(className);
    }
    function createElement(tag, className, content) {
        var e = window.document.createElement(tag);
        className = className || "";
        content = content || "";
        e.className = className;
        if (content !== undefined)
            e.textContent = content;
        return e;
    }
    function clearNode(node) {
        while (node.firstChild)
            node.removeChild(node.firstChild);
    }
    function findParent(node, condition) {
        if (condition(node))
            return node;
        else if (node.parentNode)
            return findParent(node.parentNode, condition);
        return undefined; // nothing found
    }
    function createNumberInput(inputClassName, opts) {
        var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
        if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
            numInput.type = "number";
        }
        else {
            numInput.type = "text";
            numInput.pattern = "\\d*";
        }
        if (opts !== undefined)
            for (var key in opts)
                numInput.setAttribute(key, opts[key]);
        wrapper.appendChild(numInput);
        wrapper.appendChild(arrowUp);
        wrapper.appendChild(arrowDown);
        return wrapper;
    }
    function getEventTarget(event) {
        if (typeof event.composedPath === "function") {
            var path = event.composedPath();
            return path[0];
        }
        return event.target;
    }

    var do_nothing = function () { return undefined; };
    var monthToStr = function (monthNumber, shorthand, locale) { return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber]; };
    var revFormat = {
        D: do_nothing,
        F: function (dateObj, monthName, locale) {
            dateObj.setMonth(locale.months.longhand.indexOf(monthName));
        },
        G: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        H: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        J: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        K: function (dateObj, amPM, locale) {
            dateObj.setHours((dateObj.getHours() % 12) +
                12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
        },
        M: function (dateObj, shortMonth, locale) {
            dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
        },
        S: function (dateObj, seconds) {
            dateObj.setSeconds(parseFloat(seconds));
        },
        U: function (_, unixSeconds) { return new Date(parseFloat(unixSeconds) * 1000); },
        W: function (dateObj, weekNum) {
            var weekNumber = parseInt(weekNum);
            return new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
        },
        Y: function (dateObj, year) {
            dateObj.setFullYear(parseFloat(year));
        },
        Z: function (_, ISODate) { return new Date(ISODate); },
        d: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        h: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        i: function (dateObj, minutes) {
            dateObj.setMinutes(parseFloat(minutes));
        },
        j: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        l: do_nothing,
        m: function (dateObj, month) {
            dateObj.setMonth(parseFloat(month) - 1);
        },
        n: function (dateObj, month) {
            dateObj.setMonth(parseFloat(month) - 1);
        },
        s: function (dateObj, seconds) {
            dateObj.setSeconds(parseFloat(seconds));
        },
        u: function (_, unixMillSeconds) {
            return new Date(parseFloat(unixMillSeconds));
        },
        w: do_nothing,
        y: function (dateObj, year) {
            dateObj.setFullYear(2000 + parseFloat(year));
        }
    };
    var tokenRegex = {
        D: "(\\w+)",
        F: "(\\w+)",
        G: "(\\d\\d|\\d)",
        H: "(\\d\\d|\\d)",
        J: "(\\d\\d|\\d)\\w+",
        K: "",
        M: "(\\w+)",
        S: "(\\d\\d|\\d)",
        U: "(.+)",
        W: "(\\d\\d|\\d)",
        Y: "(\\d{4})",
        Z: "(.+)",
        d: "(\\d\\d|\\d)",
        h: "(\\d\\d|\\d)",
        i: "(\\d\\d|\\d)",
        j: "(\\d\\d|\\d)",
        l: "(\\w+)",
        m: "(\\d\\d|\\d)",
        n: "(\\d\\d|\\d)",
        s: "(\\d\\d|\\d)",
        u: "(.+)",
        w: "(\\d\\d|\\d)",
        y: "(\\d{2})"
    };
    var formats = {
        // get the date in UTC
        Z: function (date) { return date.toISOString(); },
        // weekday name, short, e.g. Thu
        D: function (date, locale, options) {
            return locale.weekdays.shorthand[formats.w(date, locale, options)];
        },
        // full month name e.g. January
        F: function (date, locale, options) {
            return monthToStr(formats.n(date, locale, options) - 1, false, locale);
        },
        // padded hour 1-12
        G: function (date, locale, options) {
            return pad(formats.h(date, locale, options));
        },
        // hours with leading zero e.g. 03
        H: function (date) { return pad(date.getHours()); },
        // day (1-30) with ordinal suffix e.g. 1st, 2nd
        J: function (date, locale) {
            return locale.ordinal !== undefined
                ? date.getDate() + locale.ordinal(date.getDate())
                : date.getDate();
        },
        // AM/PM
        K: function (date, locale) { return locale.amPM[int(date.getHours() > 11)]; },
        // shorthand month e.g. Jan, Sep, Oct, etc
        M: function (date, locale) {
            return monthToStr(date.getMonth(), true, locale);
        },
        // seconds 00-59
        S: function (date) { return pad(date.getSeconds()); },
        // unix timestamp
        U: function (date) { return date.getTime() / 1000; },
        W: function (date, _, options) {
            return options.getWeek(date);
        },
        // full year e.g. 2016
        Y: function (date) { return date.getFullYear(); },
        // day in month, padded (01-30)
        d: function (date) { return pad(date.getDate()); },
        // hour from 1-12 (am/pm)
        h: function (date) { return (date.getHours() % 12 ? date.getHours() % 12 : 12); },
        // minutes, padded with leading zero e.g. 09
        i: function (date) { return pad(date.getMinutes()); },
        // day in month (1-30)
        j: function (date) { return date.getDate(); },
        // weekday name, full, e.g. Thursday
        l: function (date, locale) {
            return locale.weekdays.longhand[date.getDay()];
        },
        // padded month number (01-12)
        m: function (date) { return pad(date.getMonth() + 1); },
        // the month number (1-12)
        n: function (date) { return date.getMonth() + 1; },
        // seconds 0-59
        s: function (date) { return date.getSeconds(); },
        // Unix Milliseconds
        u: function (date) { return date.getTime(); },
        // number of the day of the week
        w: function (date) { return date.getDay(); },
        // last two digits of year e.g. 16 for 2016
        y: function (date) { return String(date.getFullYear()).substring(2); }
    };

    var createDateFormatter = function (_a) {
        var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
        return function (dateObj, frmt, overrideLocale) {
            var locale = overrideLocale || l10n;
            if (config.formatDate !== undefined) {
                return config.formatDate(dateObj, frmt, locale);
            }
            return frmt
                .split("")
                .map(function (c, i, arr) {
                return formats[c] && arr[i - 1] !== "\\"
                    ? formats[c](dateObj, locale, config)
                    : c !== "\\"
                        ? c
                        : "";
            })
                .join("");
        };
    };
    var createDateParser = function (_a) {
        var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
        return function (date, givenFormat, timeless, customLocale) {
            if (date !== 0 && !date)
                return undefined;
            var locale = customLocale || l10n;
            var parsedDate;
            var date_orig = date;
            if (date instanceof Date)
                parsedDate = new Date(date.getTime());
            else if (typeof date !== "string" &&
                date.toFixed !== undefined // timestamp
            )
                // create a copy
                parsedDate = new Date(date);
            else if (typeof date === "string") {
                // date string
                var format = givenFormat || (config || defaults).dateFormat;
                var datestr = String(date).trim();
                if (datestr === "today") {
                    parsedDate = new Date();
                    timeless = true;
                }
                else if (/Z$/.test(datestr) ||
                    /GMT$/.test(datestr) // datestrings w/ timezone
                )
                    parsedDate = new Date(date);
                else if (config && config.parseDate)
                    parsedDate = config.parseDate(date, format);
                else {
                    parsedDate =
                        !config || !config.noCalendar
                            ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0)
                            : new Date(new Date().setHours(0, 0, 0, 0));
                    var matched = void 0, ops = [];
                    for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
                        var token_1 = format[i];
                        var isBackSlash = token_1 === "\\";
                        var escaped = format[i - 1] === "\\" || isBackSlash;
                        if (tokenRegex[token_1] && !escaped) {
                            regexStr += tokenRegex[token_1];
                            var match = new RegExp(regexStr).exec(date);
                            if (match && (matched = true)) {
                                ops[token_1 !== "Y" ? "push" : "unshift"]({
                                    fn: revFormat[token_1],
                                    val: match[++matchIndex]
                                });
                            }
                        }
                        else if (!isBackSlash)
                            regexStr += "."; // don't really care
                        ops.forEach(function (_a) {
                            var fn = _a.fn, val = _a.val;
                            return (parsedDate = fn(parsedDate, val, locale) || parsedDate);
                        });
                    }
                    parsedDate = matched ? parsedDate : undefined;
                }
            }
            /* istanbul ignore next */
            if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
                config.errorHandler(new Error("Invalid date provided: " + date_orig));
                return undefined;
            }
            if (timeless === true)
                parsedDate.setHours(0, 0, 0, 0);
            return parsedDate;
        };
    };
    /**
     * Compute the difference in dates, measured in ms
     */
    function compareDates(date1, date2, timeless) {
        if (timeless === void 0) { timeless = true; }
        if (timeless !== false) {
            return (new Date(date1.getTime()).setHours(0, 0, 0, 0) -
                new Date(date2.getTime()).setHours(0, 0, 0, 0));
        }
        return date1.getTime() - date2.getTime();
    }
    var isBetween = function (ts, ts1, ts2) {
        return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
    };
    var duration = {
        DAY: 86400000
    };

    if (typeof Object.assign !== "function") {
        Object.assign = function (target) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (!target) {
                throw TypeError("Cannot convert undefined or null to object");
            }
            var _loop_1 = function (source) {
                if (source) {
                    Object.keys(source).forEach(function (key) { return (target[key] = source[key]); });
                }
            };
            for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
                var source = args_1[_a];
                _loop_1(source);
            }
            return target;
        };
    }

    var DEBOUNCED_CHANGE_MS = 300;
    function FlatpickrInstance(element, instanceConfig) {
        var self = {
            config: __assign({}, flatpickr.defaultConfig),
            l10n: english
        };
        self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
        self._handlers = [];
        self._bind = bind;
        self._setHoursFromDate = setHoursFromDate;
        self._positionCalendar = positionCalendar;
        self.changeMonth = changeMonth;
        self.changeYear = changeYear;
        self.clear = clear;
        self.close = close;
        self._createElement = createElement;
        self.destroy = destroy;
        self.isEnabled = isEnabled;
        self.jumpToDate = jumpToDate;
        self.open = open;
        self.redraw = redraw;
        self.set = set;
        self.setDate = setDate;
        self.toggle = toggle;
        function setupHelperFunctions() {
            self.utils = {
                getDaysInMonth: function (month, yr) {
                    if (month === void 0) { month = self.currentMonth; }
                    if (yr === void 0) { yr = self.currentYear; }
                    if (month === 1 && ((yr % 4 === 0 && yr % 100 !== 0) || yr % 400 === 0))
                        return 29;
                    return self.l10n.daysInMonth[month];
                }
            };
        }
        function init() {
            self.element = self.input = element;
            self.isOpen = false;
            parseConfig();
            setupLocale();
            setupInputs();
            setupDates();
            setupHelperFunctions();
            if (!self.isMobile)
                build();
            bindEvents();
            if (self.selectedDates.length || self.config.noCalendar) {
                if (self.config.enableTime) {
                    setHoursFromDate(self.config.noCalendar
                        ? self.latestSelectedDateObj || self.config.minDate
                        : undefined);
                }
                updateValue(false);
            }
            setCalendarWidth();
            self.showTimeInput =
                self.selectedDates.length > 0 || self.config.noCalendar;
            var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            /* TODO: investigate this further
        
              Currently, there is weird positioning behavior in safari causing pages
              to scroll up. https://github.com/chmln/flatpickr/issues/563
        
              However, most browsers are not Safari and positioning is expensive when used
              in scale. https://github.com/chmln/flatpickr/issues/1096
            */
            if (!self.isMobile && isSafari) {
                positionCalendar();
            }
            triggerEvent("onReady");
        }
        function bindToInstance(fn) {
            return fn.bind(self);
        }
        function setCalendarWidth() {
            var config = self.config;
            if (config.weekNumbers === false && config.showMonths === 1)
                return;
            else if (config.noCalendar !== true) {
                window.requestAnimationFrame(function () {
                    if (self.calendarContainer !== undefined) {
                        self.calendarContainer.style.visibility = "hidden";
                        self.calendarContainer.style.display = "block";
                    }
                    if (self.daysContainer !== undefined) {
                        var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
                        self.daysContainer.style.width = daysWidth + "px";
                        self.calendarContainer.style.width =
                            daysWidth +
                                (self.weekWrapper !== undefined
                                    ? self.weekWrapper.offsetWidth
                                    : 0) +
                                "px";
                        self.calendarContainer.style.removeProperty("visibility");
                        self.calendarContainer.style.removeProperty("display");
                    }
                });
            }
        }
        /**
         * The handler for all events targeting the time inputs
         */
        function updateTime(e) {
            if (self.selectedDates.length === 0) {
                setDefaultTime();
            }
            if (e !== undefined && e.type !== "blur") {
                timeWrapper(e);
            }
            var prevValue = self._input.value;
            setHoursFromInputs();
            updateValue();
            if (self._input.value !== prevValue) {
                self._debouncedChange();
            }
        }
        function ampm2military(hour, amPM) {
            return (hour % 12) + 12 * int(amPM === self.l10n.amPM[1]);
        }
        function military2ampm(hour) {
            switch (hour % 24) {
                case 0:
                case 12:
                    return 12;
                default:
                    return hour % 12;
            }
        }
        /**
         * Syncs the selected date object time with user's time input
         */
        function setHoursFromInputs() {
            if (self.hourElement === undefined || self.minuteElement === undefined)
                return;
            var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== undefined
                ? (parseInt(self.secondElement.value, 10) || 0) % 60
                : 0;
            if (self.amPM !== undefined) {
                hours = ampm2military(hours, self.amPM.textContent);
            }
            var limitMinHours = self.config.minTime !== undefined ||
                (self.config.minDate &&
                    self.minDateHasTime &&
                    self.latestSelectedDateObj &&
                    compareDates(self.latestSelectedDateObj, self.config.minDate, true) ===
                        0);
            var limitMaxHours = self.config.maxTime !== undefined ||
                (self.config.maxDate &&
                    self.maxDateHasTime &&
                    self.latestSelectedDateObj &&
                    compareDates(self.latestSelectedDateObj, self.config.maxDate, true) ===
                        0);
            if (limitMaxHours) {
                var maxTime = self.config.maxTime !== undefined
                    ? self.config.maxTime
                    : self.config.maxDate;
                hours = Math.min(hours, maxTime.getHours());
                if (hours === maxTime.getHours())
                    minutes = Math.min(minutes, maxTime.getMinutes());
                if (minutes === maxTime.getMinutes())
                    seconds = Math.min(seconds, maxTime.getSeconds());
            }
            if (limitMinHours) {
                var minTime = self.config.minTime !== undefined
                    ? self.config.minTime
                    : self.config.minDate;
                hours = Math.max(hours, minTime.getHours());
                if (hours === minTime.getHours())
                    minutes = Math.max(minutes, minTime.getMinutes());
                if (minutes === minTime.getMinutes())
                    seconds = Math.max(seconds, minTime.getSeconds());
            }
            setHours(hours, minutes, seconds);
        }
        /**
         * Syncs time input values with a date
         */
        function setHoursFromDate(dateObj) {
            var date = dateObj || self.latestSelectedDateObj;
            if (date)
                setHours(date.getHours(), date.getMinutes(), date.getSeconds());
        }
        function setDefaultHours() {
            var hours = self.config.defaultHour;
            var minutes = self.config.defaultMinute;
            var seconds = self.config.defaultSeconds;
            if (self.config.minDate !== undefined) {
                var min_hr = self.config.minDate.getHours();
                var min_minutes = self.config.minDate.getMinutes();
                hours = Math.max(hours, min_hr);
                if (hours === min_hr)
                    minutes = Math.max(min_minutes, minutes);
                if (hours === min_hr && minutes === min_minutes)
                    seconds = self.config.minDate.getSeconds();
            }
            if (self.config.maxDate !== undefined) {
                var max_hr = self.config.maxDate.getHours();
                var max_minutes = self.config.maxDate.getMinutes();
                hours = Math.min(hours, max_hr);
                if (hours === max_hr)
                    minutes = Math.min(max_minutes, minutes);
                if (hours === max_hr && minutes === max_minutes)
                    seconds = self.config.maxDate.getSeconds();
            }
            setHours(hours, minutes, seconds);
        }
        /**
         * Sets the hours, minutes, and optionally seconds
         * of the latest selected date object and the
         * corresponding time inputs
         * @param {Number} hours the hour. whether its military
         *                 or am-pm gets inferred from config
         * @param {Number} minutes the minutes
         * @param {Number} seconds the seconds (optional)
         */
        function setHours(hours, minutes, seconds) {
            if (self.latestSelectedDateObj !== undefined) {
                self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
            }
            if (!self.hourElement || !self.minuteElement || self.isMobile)
                return;
            self.hourElement.value = pad(!self.config.time_24hr
                ? ((12 + hours) % 12) + 12 * int(hours % 12 === 0)
                : hours);
            self.minuteElement.value = pad(minutes);
            if (self.amPM !== undefined)
                self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
            if (self.secondElement !== undefined)
                self.secondElement.value = pad(seconds);
        }
        /**
         * Handles the year input and incrementing events
         * @param {Event} event the keyup or increment event
         */
        function onYearInput(event) {
            var year = parseInt(event.target.value) + (event.delta || 0);
            if (year / 1000 > 1 ||
                (event.key === "Enter" && !/[^\d]/.test(year.toString()))) {
                changeYear(year);
            }
        }
        /**
         * Essentially addEventListener + tracking
         * @param {Element} element the element to addEventListener to
         * @param {String} event the event name
         * @param {Function} handler the event handler
         */
        function bind(element, event, handler, options) {
            if (event instanceof Array)
                return event.forEach(function (ev) { return bind(element, ev, handler, options); });
            if (element instanceof Array)
                return element.forEach(function (el) { return bind(el, event, handler, options); });
            element.addEventListener(event, handler, options);
            self._handlers.push({
                element: element,
                event: event,
                handler: handler,
                options: options
            });
        }
        /**
         * A mousedown handler which mimics click.
         * Minimizes latency, since we don't need to wait for mouseup in most cases.
         * Also, avoids handling right clicks.
         *
         * @param {Function} handler the event handler
         */
        function onClick(handler) {
            return function (evt) {
                evt.which === 1 && handler(evt);
            };
        }
        function triggerChange() {
            triggerEvent("onChange");
        }
        /**
         * Adds all the necessary event listeners
         */
        function bindEvents() {
            if (self.config.wrap) {
                ["open", "close", "toggle", "clear"].forEach(function (evt) {
                    Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
                        return bind(el, "click", self[evt]);
                    });
                });
            }
            if (self.isMobile) {
                setupMobile();
                return;
            }
            var debouncedResize = debounce(onResize, 50);
            self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
            if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
                bind(self.daysContainer, "mouseover", function (e) {
                    if (self.config.mode === "range")
                        onMouseOver(e.target);
                });
            bind(window.document.body, "keydown", onKeyDown);
            if (!self.config.static)
                bind(self._input, "keydown", onKeyDown);
            if (!self.config.inline && !self.config.static)
                bind(window, "resize", debouncedResize);
            if (window.ontouchstart !== undefined)
                bind(window.document, "click", documentClick);
            else
                bind(window.document, "mousedown", onClick(documentClick));
            bind(window.document, "focus", documentClick, { capture: true });
            if (self.config.clickOpens === true) {
                bind(self._input, "focus", self.open);
                bind(self._input, "mousedown", onClick(self.open));
            }
            if (self.daysContainer !== undefined) {
                bind(self.monthNav, "mousedown", onClick(onMonthNavClick));
                bind(self.monthNav, ["keyup", "increment"], onYearInput);
                bind(self.daysContainer, "mousedown", onClick(selectDate));
            }
            if (self.timeContainer !== undefined &&
                self.minuteElement !== undefined &&
                self.hourElement !== undefined) {
                var selText = function (e) {
                    return e.target.select();
                };
                bind(self.timeContainer, ["increment"], updateTime);
                bind(self.timeContainer, "blur", updateTime, { capture: true });
                bind(self.timeContainer, "mousedown", onClick(timeIncrement));
                bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
                if (self.secondElement !== undefined)
                    bind(self.secondElement, "focus", function () { return self.secondElement && self.secondElement.select(); });
                if (self.amPM !== undefined) {
                    bind(self.amPM, "mousedown", onClick(function (e) {
                        updateTime(e);
                        triggerChange();
                    }));
                }
            }
        }
        /**
         * Set the calendar view to a particular date.
         * @param {Date} jumpDate the date to set the view to
         */
        function jumpToDate(jumpDate) {
            var jumpTo = jumpDate !== undefined
                ? self.parseDate(jumpDate)
                : self.latestSelectedDateObj ||
                    (self.config.minDate && self.config.minDate > self.now
                        ? self.config.minDate
                        : self.config.maxDate && self.config.maxDate < self.now
                            ? self.config.maxDate
                            : self.now);
            try {
                if (jumpTo !== undefined) {
                    self.currentYear = jumpTo.getFullYear();
                    self.currentMonth = jumpTo.getMonth();
                }
            }
            catch (e) {
                /* istanbul ignore next */
                e.message = "Invalid date supplied: " + jumpTo;
                self.config.errorHandler(e);
            }
            self.redraw();
        }
        /**
         * The up/down arrow handler for time inputs
         * @param {Event} e the click event
         */
        function timeIncrement(e) {
            if (~e.target.className.indexOf("arrow"))
                incrementNumInput(e, e.target.classList.contains("arrowUp") ? 1 : -1);
        }
        /**
         * Increments/decrements the value of input associ-
         * ated with the up/down arrow by dispatching an
         * "increment" event on the input.
         *
         * @param {Event} e the click event
         * @param {Number} delta the diff (usually 1 or -1)
         * @param {Element} inputElem the input element
         */
        function incrementNumInput(e, delta, inputElem) {
            var target = e && e.target;
            var input = inputElem ||
                (target && target.parentNode && target.parentNode.firstChild);
            var event = createEvent("increment");
            event.delta = delta;
            input && input.dispatchEvent(event);
        }
        function build() {
            var fragment = window.document.createDocumentFragment();
            self.calendarContainer = createElement("div", "flatpickr-calendar");
            self.calendarContainer.tabIndex = -1;
            if (!self.config.noCalendar) {
                fragment.appendChild(buildMonthNav());
                self.innerContainer = createElement("div", "flatpickr-innerContainer");
                if (self.config.weekNumbers) {
                    var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
                    self.innerContainer.appendChild(weekWrapper);
                    self.weekNumbers = weekNumbers;
                    self.weekWrapper = weekWrapper;
                }
                self.rContainer = createElement("div", "flatpickr-rContainer");
                self.rContainer.appendChild(buildWeekdays());
                if (!self.daysContainer) {
                    self.daysContainer = createElement("div", "flatpickr-days");
                    self.daysContainer.tabIndex = -1;
                }
                buildDays();
                self.rContainer.appendChild(self.daysContainer);
                self.innerContainer.appendChild(self.rContainer);
                fragment.appendChild(self.innerContainer);
            }
            if (self.config.enableTime) {
                fragment.appendChild(buildTime());
            }
            toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
            toggleClass(self.calendarContainer, "animate", self.config.animate === true);
            toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
            self.calendarContainer.appendChild(fragment);
            var customAppend = self.config.appendTo !== undefined &&
                self.config.appendTo.nodeType !== undefined;
            if (self.config.inline || self.config.static) {
                self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
                if (self.config.inline) {
                    if (!customAppend && self.element.parentNode)
                        self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
                    else if (self.config.appendTo !== undefined)
                        self.config.appendTo.appendChild(self.calendarContainer);
                }
                if (self.config.static) {
                    var wrapper = createElement("div", "flatpickr-wrapper");
                    if (self.element.parentNode)
                        self.element.parentNode.insertBefore(wrapper, self.element);
                    wrapper.appendChild(self.element);
                    if (self.altInput)
                        wrapper.appendChild(self.altInput);
                    wrapper.appendChild(self.calendarContainer);
                }
            }
            if (!self.config.static && !self.config.inline)
                (self.config.appendTo !== undefined
                    ? self.config.appendTo
                    : window.document.body).appendChild(self.calendarContainer);
        }
        function createDay(className, date, dayNumber, i) {
            var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
            dayElement.dateObj = date;
            dayElement.$i = i;
            dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
            if (className.indexOf("hidden") === -1 &&
                compareDates(date, self.now) === 0) {
                self.todayDateElem = dayElement;
                dayElement.classList.add("today");
                dayElement.setAttribute("aria-current", "date");
            }
            if (dateIsEnabled) {
                dayElement.tabIndex = -1;
                if (isDateSelected(date)) {
                    dayElement.classList.add("selected");
                    self.selectedDateElem = dayElement;
                    if (self.config.mode === "range") {
                        toggleClass(dayElement, "startRange", self.selectedDates[0] &&
                            compareDates(date, self.selectedDates[0], true) === 0);
                        toggleClass(dayElement, "endRange", self.selectedDates[1] &&
                            compareDates(date, self.selectedDates[1], true) === 0);
                        if (className === "nextMonthDay")
                            dayElement.classList.add("inRange");
                    }
                }
            }
            else {
                dayElement.classList.add("disabled");
            }
            if (self.config.mode === "range") {
                if (isDateInRange(date) && !isDateSelected(date))
                    dayElement.classList.add("inRange");
            }
            if (self.weekNumbers &&
                self.config.showMonths === 1 &&
                className !== "prevMonthDay" &&
                dayNumber % 7 === 1) {
                self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
            }
            triggerEvent("onDayCreate", dayElement);
            return dayElement;
        }
        function focusOnDayElem(targetNode) {
            targetNode.focus();
            if (self.config.mode === "range")
                onMouseOver(targetNode);
        }
        function getFirstAvailableDay(delta) {
            var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
            var endMonth = delta > 0 ? self.config.showMonths : -1;
            for (var m = startMonth; m != endMonth; m += delta) {
                var month = self.daysContainer.children[m];
                var startIndex = delta > 0 ? 0 : month.children.length - 1;
                var endIndex = delta > 0 ? month.children.length : -1;
                for (var i = startIndex; i != endIndex; i += delta) {
                    var c = month.children[i];
                    if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
                        return c;
                }
            }
            return undefined;
        }
        function getNextAvailableDay(current, delta) {
            var givenMonth = current.className.indexOf("Month") === -1
                ? current.dateObj.getMonth()
                : self.currentMonth;
            var endMonth = delta > 0 ? self.config.showMonths : -1;
            var loopDelta = delta > 0 ? 1 : -1;
            for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
                var month = self.daysContainer.children[m];
                var startIndex = givenMonth - self.currentMonth === m
                    ? current.$i + delta
                    : delta < 0
                        ? month.children.length - 1
                        : 0;
                var numMonthDays = month.children.length;
                for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
                    var c = month.children[i];
                    if (c.className.indexOf("hidden") === -1 &&
                        isEnabled(c.dateObj) &&
                        Math.abs(current.$i - i) >= Math.abs(delta))
                        return focusOnDayElem(c);
                }
            }
            self.changeMonth(loopDelta);
            focusOnDay(getFirstAvailableDay(loopDelta), 0);
            return undefined;
        }
        function focusOnDay(current, offset) {
            var dayFocused = isInView(document.activeElement || document.body);
            var startElem = current !== undefined
                ? current
                : dayFocused
                    ? document.activeElement
                    : self.selectedDateElem !== undefined && isInView(self.selectedDateElem)
                        ? self.selectedDateElem
                        : self.todayDateElem !== undefined && isInView(self.todayDateElem)
                            ? self.todayDateElem
                            : getFirstAvailableDay(offset > 0 ? 1 : -1);
            if (startElem === undefined)
                return self._input.focus();
            if (!dayFocused)
                return focusOnDayElem(startElem);
            getNextAvailableDay(startElem, offset);
        }
        function buildMonthDays(year, month) {
            var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
            var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12);
            var daysInMonth = self.utils.getDaysInMonth(month), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
            var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
            // prepend days from the ending of previous month
            for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
                days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
            }
            // Start at 1 since there is no 0th day
            for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
                days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
            }
            // append days from the next month
            for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth &&
                (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
                days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
            }
            //updateNavigationCurrentMonth();
            var dayContainer = createElement("div", "dayContainer");
            dayContainer.appendChild(days);
            return dayContainer;
        }
        function buildDays() {
            if (self.daysContainer === undefined) {
                return;
            }
            clearNode(self.daysContainer);
            // TODO: week numbers for each month
            if (self.weekNumbers)
                clearNode(self.weekNumbers);
            var frag = document.createDocumentFragment();
            for (var i = 0; i < self.config.showMonths; i++) {
                var d = new Date(self.currentYear, self.currentMonth, 1);
                d.setMonth(self.currentMonth + i);
                frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
            }
            self.daysContainer.appendChild(frag);
            self.days = self.daysContainer.firstChild;
            if (self.config.mode === "range" && self.selectedDates.length === 1) {
                onMouseOver();
            }
        }
        function buildMonth() {
            var container = createElement("div", "flatpickr-month");
            var monthNavFragment = window.document.createDocumentFragment();
            var monthElement = createElement("span", "cur-month");
            var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
            var yearElement = yearInput.getElementsByTagName("input")[0];
            yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
            if (self.config.minDate) {
                yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
            }
            if (self.config.maxDate) {
                yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
                yearElement.disabled =
                    !!self.config.minDate &&
                        self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
            }
            var currentMonth = createElement("div", "flatpickr-current-month");
            currentMonth.appendChild(monthElement);
            currentMonth.appendChild(yearInput);
            monthNavFragment.appendChild(currentMonth);
            container.appendChild(monthNavFragment);
            return {
                container: container,
                yearElement: yearElement,
                monthElement: monthElement
            };
        }
        function buildMonths() {
            clearNode(self.monthNav);
            self.monthNav.appendChild(self.prevMonthNav);
            if (self.config.showMonths) {
                self.yearElements = [];
                self.monthElements = [];
            }
            for (var m = self.config.showMonths; m--;) {
                var month = buildMonth();
                self.yearElements.push(month.yearElement);
                self.monthElements.push(month.monthElement);
                self.monthNav.appendChild(month.container);
            }
            self.monthNav.appendChild(self.nextMonthNav);
        }
        function buildMonthNav() {
            self.monthNav = createElement("div", "flatpickr-months");
            self.yearElements = [];
            self.monthElements = [];
            self.prevMonthNav = createElement("span", "flatpickr-prev-month");
            self.prevMonthNav.innerHTML = self.config.prevArrow;
            self.nextMonthNav = createElement("span", "flatpickr-next-month");
            self.nextMonthNav.innerHTML = self.config.nextArrow;
            buildMonths();
            Object.defineProperty(self, "_hidePrevMonthArrow", {
                get: function () { return self.__hidePrevMonthArrow; },
                set: function (bool) {
                    if (self.__hidePrevMonthArrow !== bool) {
                        toggleClass(self.prevMonthNav, "disabled", bool);
                        self.__hidePrevMonthArrow = bool;
                    }
                }
            });
            Object.defineProperty(self, "_hideNextMonthArrow", {
                get: function () { return self.__hideNextMonthArrow; },
                set: function (bool) {
                    if (self.__hideNextMonthArrow !== bool) {
                        toggleClass(self.nextMonthNav, "disabled", bool);
                        self.__hideNextMonthArrow = bool;
                    }
                }
            });
            self.currentYearElement = self.yearElements[0];
            updateNavigationCurrentMonth();
            return self.monthNav;
        }
        function buildTime() {
            self.calendarContainer.classList.add("hasTime");
            if (self.config.noCalendar)
                self.calendarContainer.classList.add("noCalendar");
            self.timeContainer = createElement("div", "flatpickr-time");
            self.timeContainer.tabIndex = -1;
            var separator = createElement("span", "flatpickr-time-separator", ":");
            var hourInput = createNumberInput("flatpickr-hour");
            self.hourElement = hourInput.getElementsByTagName("input")[0];
            var minuteInput = createNumberInput("flatpickr-minute");
            self.minuteElement = minuteInput.getElementsByTagName("input")[0];
            self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
            self.hourElement.value = pad(self.latestSelectedDateObj
                ? self.latestSelectedDateObj.getHours()
                : self.config.time_24hr
                    ? self.config.defaultHour
                    : military2ampm(self.config.defaultHour));
            self.minuteElement.value = pad(self.latestSelectedDateObj
                ? self.latestSelectedDateObj.getMinutes()
                : self.config.defaultMinute);
            self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
            self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
            self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
            self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
            self.minuteElement.setAttribute("min", "0");
            self.minuteElement.setAttribute("max", "59");
            self.timeContainer.appendChild(hourInput);
            self.timeContainer.appendChild(separator);
            self.timeContainer.appendChild(minuteInput);
            if (self.config.time_24hr)
                self.timeContainer.classList.add("time24hr");
            if (self.config.enableSeconds) {
                self.timeContainer.classList.add("hasSeconds");
                var secondInput = createNumberInput("flatpickr-second");
                self.secondElement = secondInput.getElementsByTagName("input")[0];
                self.secondElement.value = pad(self.latestSelectedDateObj
                    ? self.latestSelectedDateObj.getSeconds()
                    : self.config.defaultSeconds);
                self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
                self.secondElement.setAttribute("min", "0");
                self.secondElement.setAttribute("max", "59");
                self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
                self.timeContainer.appendChild(secondInput);
            }
            if (!self.config.time_24hr) {
                // add self.amPM if appropriate
                self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj
                    ? self.hourElement.value
                    : self.config.defaultHour) > 11)]);
                self.amPM.title = self.l10n.toggleTitle;
                self.amPM.tabIndex = -1;
                self.timeContainer.appendChild(self.amPM);
            }
            return self.timeContainer;
        }
        function buildWeekdays() {
            if (!self.weekdayContainer)
                self.weekdayContainer = createElement("div", "flatpickr-weekdays");
            else
                clearNode(self.weekdayContainer);
            for (var i = self.config.showMonths; i--;) {
                var container = createElement("div", "flatpickr-weekdaycontainer");
                self.weekdayContainer.appendChild(container);
            }
            updateWeekdays();
            return self.weekdayContainer;
        }
        function updateWeekdays() {
            var firstDayOfWeek = self.l10n.firstDayOfWeek;
            var weekdays = self.l10n.weekdays.shorthand.slice();
            if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
                weekdays = weekdays.splice(firstDayOfWeek, weekdays.length).concat(weekdays.splice(0, firstDayOfWeek));
            }
            for (var i = self.config.showMonths; i--;) {
                self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
            }
        }
        /* istanbul ignore next */
        function buildWeeks() {
            self.calendarContainer.classList.add("hasWeeks");
            var weekWrapper = createElement("div", "flatpickr-weekwrapper");
            weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
            var weekNumbers = createElement("div", "flatpickr-weeks");
            weekWrapper.appendChild(weekNumbers);
            return {
                weekWrapper: weekWrapper,
                weekNumbers: weekNumbers
            };
        }
        function changeMonth(value, is_offset) {
            if (is_offset === void 0) { is_offset = true; }
            var delta = is_offset ? value : value - self.currentMonth;
            if ((delta < 0 && self._hidePrevMonthArrow === true) ||
                (delta > 0 && self._hideNextMonthArrow === true))
                return;
            self.currentMonth += delta;
            if (self.currentMonth < 0 || self.currentMonth > 11) {
                self.currentYear += self.currentMonth > 11 ? 1 : -1;
                self.currentMonth = (self.currentMonth + 12) % 12;
                triggerEvent("onYearChange");
            }
            buildDays();
            triggerEvent("onMonthChange");
            updateNavigationCurrentMonth();
        }
        function clear(triggerChangeEvent, toInitial) {
            if (triggerChangeEvent === void 0) { triggerChangeEvent = true; }
            if (toInitial === void 0) { toInitial = true; }
            self.input.value = "";
            if (self.altInput !== undefined)
                self.altInput.value = "";
            if (self.mobileInput !== undefined)
                self.mobileInput.value = "";
            self.selectedDates = [];
            self.latestSelectedDateObj = undefined;
            if (toInitial === true) {
                self.currentYear = self._initialDate.getFullYear();
                self.currentMonth = self._initialDate.getMonth();
            }
            self.showTimeInput = false;
            if (self.config.enableTime === true) {
                setDefaultHours();
            }
            self.redraw();
            if (triggerChangeEvent)
                // triggerChangeEvent is true (default) or an Event
                triggerEvent("onChange");
        }
        function close() {
            self.isOpen = false;
            if (!self.isMobile) {
                if (self.calendarContainer !== undefined) {
                    self.calendarContainer.classList.remove("open");
                }
                if (self._input !== undefined) {
                    self._input.classList.remove("active");
                }
            }
            triggerEvent("onClose");
        }
        function destroy() {
            if (self.config !== undefined)
                triggerEvent("onDestroy");
            for (var i = self._handlers.length; i--;) {
                var h = self._handlers[i];
                h.element.removeEventListener(h.event, h.handler, h.options);
            }
            self._handlers = [];
            if (self.mobileInput) {
                if (self.mobileInput.parentNode)
                    self.mobileInput.parentNode.removeChild(self.mobileInput);
                self.mobileInput = undefined;
            }
            else if (self.calendarContainer && self.calendarContainer.parentNode) {
                if (self.config.static && self.calendarContainer.parentNode) {
                    var wrapper = self.calendarContainer.parentNode;
                    wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
                    if (wrapper.parentNode) {
                        while (wrapper.firstChild)
                            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                        wrapper.parentNode.removeChild(wrapper);
                    }
                }
                else
                    self.calendarContainer.parentNode.removeChild(self.calendarContainer);
            }
            if (self.altInput) {
                self.input.type = "text";
                if (self.altInput.parentNode)
                    self.altInput.parentNode.removeChild(self.altInput);
                delete self.altInput;
            }
            if (self.input) {
                self.input.type = self.input._type;
                self.input.classList.remove("flatpickr-input");
                self.input.removeAttribute("readonly");
                self.input.value = "";
            }
            [
                "_showTimeInput",
                "latestSelectedDateObj",
                "_hideNextMonthArrow",
                "_hidePrevMonthArrow",
                "__hideNextMonthArrow",
                "__hidePrevMonthArrow",
                "isMobile",
                "isOpen",
                "selectedDateElem",
                "minDateHasTime",
                "maxDateHasTime",
                "days",
                "daysContainer",
                "_input",
                "_positionElement",
                "innerContainer",
                "rContainer",
                "monthNav",
                "todayDateElem",
                "calendarContainer",
                "weekdayContainer",
                "prevMonthNav",
                "nextMonthNav",
                "currentMonthElement",
                "currentYearElement",
                "navigationCurrentMonth",
                "selectedDateElem",
                "config",
            ].forEach(function (k) {
                try {
                    delete self[k];
                }
                catch (_) { }
            });
        }
        function isCalendarElem(elem) {
            if (self.config.appendTo && self.config.appendTo.contains(elem))
                return true;
            return self.calendarContainer.contains(elem);
        }
        function documentClick(e) {
            if (self.isOpen && !self.config.inline) {
                var eventTarget_1 = getEventTarget(e);
                var isCalendarElement = isCalendarElem(eventTarget_1);
                var isInput = eventTarget_1 === self.input ||
                    eventTarget_1 === self.altInput ||
                    self.element.contains(eventTarget_1) ||
                    // web components
                    // e.path is not present in all browsers. circumventing typechecks
                    (e.path &&
                        e.path.indexOf &&
                        (~e.path.indexOf(self.input) ||
                            ~e.path.indexOf(self.altInput)));
                var lostFocus = e.type === "blur"
                    ? isInput &&
                        e.relatedTarget &&
                        !isCalendarElem(e.relatedTarget)
                    : !isInput &&
                        !isCalendarElement &&
                        !isCalendarElem(e.relatedTarget);
                var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
                    return elem.contains(eventTarget_1);
                });
                if (lostFocus && isIgnored) {
                    self.close();
                    if (self.config.mode === "range" && self.selectedDates.length === 1) {
                        self.clear(false);
                        self.redraw();
                    }
                }
            }
        }
        function changeYear(newYear) {
            if (!newYear ||
                (self.config.minDate && newYear < self.config.minDate.getFullYear()) ||
                (self.config.maxDate && newYear > self.config.maxDate.getFullYear()))
                return;
            var newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
            self.currentYear = newYearNum || self.currentYear;
            if (self.config.maxDate &&
                self.currentYear === self.config.maxDate.getFullYear()) {
                self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
            }
            else if (self.config.minDate &&
                self.currentYear === self.config.minDate.getFullYear()) {
                self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
            }
            if (isNewYear) {
                self.redraw();
                triggerEvent("onYearChange");
            }
        }
        function isEnabled(date, timeless) {
            if (timeless === void 0) { timeless = true; }
            var dateToCheck = self.parseDate(date, undefined, timeless); // timeless
            if ((self.config.minDate &&
                dateToCheck &&
                compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0) ||
                (self.config.maxDate &&
                    dateToCheck &&
                    compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0))
                return false;
            if (self.config.enable.length === 0 && self.config.disable.length === 0)
                return true;
            if (dateToCheck === undefined)
                return false;
            var bool = self.config.enable.length > 0, array = bool ? self.config.enable : self.config.disable;
            for (var i = 0, d = void 0; i < array.length; i++) {
                d = array[i];
                if (typeof d === "function" &&
                    d(dateToCheck) // disabled by function
                )
                    return bool;
                else if (d instanceof Date &&
                    dateToCheck !== undefined &&
                    d.getTime() === dateToCheck.getTime())
                    // disabled by date
                    return bool;
                else if (typeof d === "string" && dateToCheck !== undefined) {
                    // disabled by date string
                    var parsed = self.parseDate(d, undefined, true);
                    return parsed && parsed.getTime() === dateToCheck.getTime()
                        ? bool
                        : !bool;
                }
                else if (
                // disabled by range
                typeof d === "object" &&
                    dateToCheck !== undefined &&
                    d.from &&
                    d.to &&
                    dateToCheck.getTime() >= d.from.getTime() &&
                    dateToCheck.getTime() <= d.to.getTime())
                    return bool;
            }
            return !bool;
        }
        function isInView(elem) {
            if (self.daysContainer !== undefined)
                return (elem.className.indexOf("hidden") === -1 &&
                    self.daysContainer.contains(elem));
            return false;
        }
        function onKeyDown(e) {
            // e.key                      e.keyCode
            // "Backspace"                        8
            // "Tab"                              9
            // "Enter"                           13
            // "Escape"     (IE "Esc")           27
            // "ArrowLeft"  (IE "Left")          37
            // "ArrowUp"    (IE "Up")            38
            // "ArrowRight" (IE "Right")         39
            // "ArrowDown"  (IE "Down")          40
            // "Delete"     (IE "Del")           46
            var isInput = e.target === self._input;
            var allowInput = self.config.allowInput;
            var allowKeydown = self.isOpen && (!allowInput || !isInput);
            var allowInlineKeydown = self.config.inline && isInput && !allowInput;
            if (e.keyCode === 13 && isInput) {
                if (allowInput) {
                    self.setDate(self._input.value, true, e.target === self.altInput
                        ? self.config.altFormat
                        : self.config.dateFormat);
                    return e.target.blur();
                }
                else
                    self.open();
            }
            else if (isCalendarElem(e.target) ||
                allowKeydown ||
                allowInlineKeydown) {
                var isTimeObj = !!self.timeContainer &&
                    self.timeContainer.contains(e.target);
                switch (e.keyCode) {
                    case 13:
                        if (isTimeObj) {
                            updateTime();
                            focusAndClose();
                        }
                        else
                            selectDate(e);
                        break;
                    case 27: // escape
                        e.preventDefault();
                        focusAndClose();
                        break;
                    case 8:
                    case 46:
                        if (isInput && !self.config.allowInput) {
                            e.preventDefault();
                            self.clear();
                        }
                        break;
                    case 37:
                    case 39:
                        if (!isTimeObj) {
                            e.preventDefault();
                            if (self.daysContainer !== undefined &&
                                (allowInput === false ||
                                    (document.activeElement && isInView(document.activeElement)))) {
                                var delta_1 = e.keyCode === 39 ? 1 : -1;
                                if (!e.ctrlKey)
                                    focusOnDay(undefined, delta_1);
                                else {
                                    e.stopPropagation();
                                    changeMonth(delta_1);
                                    focusOnDay(getFirstAvailableDay(1), 0);
                                }
                            }
                        }
                        else if (self.hourElement)
                            self.hourElement.focus();
                        break;
                    case 38:
                    case 40:
                        e.preventDefault();
                        var delta = e.keyCode === 40 ? 1 : -1;
                        if ((self.daysContainer && e.target.$i !== undefined) ||
                            e.target === self.input) {
                            if (e.ctrlKey) {
                                e.stopPropagation();
                                changeYear(self.currentYear - delta);
                                focusOnDay(getFirstAvailableDay(1), 0);
                            }
                            else if (!isTimeObj)
                                focusOnDay(undefined, delta * 7);
                        }
                        else if (self.config.enableTime) {
                            if (!isTimeObj && self.hourElement)
                                self.hourElement.focus();
                            updateTime(e);
                            self._debouncedChange();
                        }
                        break;
                    case 9:
                        if (isTimeObj) {
                            var elems = [
                                self.hourElement,
                                self.minuteElement,
                                self.secondElement,
                                self.amPM,
                            ].filter(function (x) { return x; });
                            var i = elems.indexOf(e.target);
                            if (i !== -1) {
                                var target = elems[i + (e.shiftKey ? -1 : 1)];
                                if (target !== undefined) {
                                    e.preventDefault();
                                    target.focus();
                                }
                                else if (e.shiftKey) {
                                    e.preventDefault();
                                    self._input.focus();
                                }
                            }
                        }
                        break;
                    default:
                        break;
                }
            }
            if (self.amPM !== undefined && e.target === self.amPM) {
                switch (e.key) {
                    case self.l10n.amPM[0].charAt(0):
                    case self.l10n.amPM[0].charAt(0).toLowerCase():
                        self.amPM.textContent = self.l10n.amPM[0];
                        setHoursFromInputs();
                        updateValue();
                        break;
                    case self.l10n.amPM[1].charAt(0):
                    case self.l10n.amPM[1].charAt(0).toLowerCase():
                        self.amPM.textContent = self.l10n.amPM[1];
                        setHoursFromInputs();
                        updateValue();
                        break;
                }
            }
            triggerEvent("onKeyDown", e);
        }
        function onMouseOver(elem) {
            if (self.selectedDates.length !== 1 ||
                (elem &&
                    (!elem.classList.contains("flatpickr-day") ||
                        elem.classList.contains("disabled"))))
                return;
            var hoverDate = elem
                ? elem.dateObj.getTime()
                : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime()), lastDate = self.daysContainer.lastChild
                .lastChild.dateObj.getTime();
            var containsDisabled = false;
            var minRange = 0, maxRange = 0;
            for (var t = rangeStartDate; t < lastDate; t += duration.DAY) {
                if (!isEnabled(new Date(t), true)) {
                    containsDisabled =
                        containsDisabled || (t > rangeStartDate && t < rangeEndDate);
                    if (t < initialDate && (!minRange || t > minRange))
                        minRange = t;
                    else if (t > initialDate && (!maxRange || t < maxRange))
                        maxRange = t;
                }
            }
            for (var m = 0; m < self.config.showMonths; m++) {
                var month = self.daysContainer.children[m];
                var prevMonth = self.daysContainer.children[m - 1];
                var _loop_1 = function (i, l) {
                    var dayElem = month.children[i], date = dayElem.dateObj;
                    var timestamp = date.getTime();
                    var outOfRange = (minRange > 0 && timestamp < minRange) ||
                        (maxRange > 0 && timestamp > maxRange);
                    if (outOfRange) {
                        dayElem.classList.add("notAllowed");
                        ["inRange", "startRange", "endRange"].forEach(function (c) {
                            dayElem.classList.remove(c);
                        });
                        return "continue";
                    }
                    else if (containsDisabled && !outOfRange)
                        return "continue";
                    ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
                        dayElem.classList.remove(c);
                    });
                    if (elem !== undefined) {
                        elem.classList.add(hoverDate < self.selectedDates[0].getTime()
                            ? "startRange"
                            : "endRange");
                        if (month.contains(elem) ||
                            !(m > 0 &&
                                prevMonth &&
                                prevMonth.lastChild.dateObj.getTime() >= timestamp)) {
                            if (initialDate < hoverDate && timestamp === initialDate)
                                dayElem.classList.add("startRange");
                            else if (initialDate > hoverDate && timestamp === initialDate)
                                dayElem.classList.add("endRange");
                            if (timestamp >= minRange &&
                                (maxRange === 0 || timestamp <= maxRange) &&
                                isBetween(timestamp, initialDate, hoverDate))
                                dayElem.classList.add("inRange");
                        }
                    }
                };
                for (var i = 0, l = month.children.length; i < l; i++) {
                    _loop_1(i, l);
                }
            }
        }
        function onResize() {
            if (self.isOpen && !self.config.static && !self.config.inline)
                positionCalendar();
        }
        function setDefaultTime() {
            self.setDate(self.config.minDate !== undefined
                ? new Date(self.config.minDate.getTime())
                : new Date(), false);
            setDefaultHours();
            updateValue();
        }
        function open(e, positionElement) {
            if (positionElement === void 0) { positionElement = self._positionElement; }
            if (self.isMobile === true) {
                if (e) {
                    e.preventDefault();
                    e.target && e.target.blur();
                }
                if (self.mobileInput !== undefined) {
                    self.mobileInput.focus();
                    self.mobileInput.click();
                }
                triggerEvent("onOpen");
                return;
            }
            if (self._input.disabled || self.config.inline)
                return;
            var wasOpen = self.isOpen;
            self.isOpen = true;
            if (!wasOpen) {
                self.calendarContainer.classList.add("open");
                self._input.classList.add("active");
                triggerEvent("onOpen");
                positionCalendar(positionElement);
            }
            if (self.config.enableTime === true && self.config.noCalendar === true) {
                if (self.selectedDates.length === 0) {
                    setDefaultTime();
                }
                if (self.config.allowInput === false &&
                    (e === undefined ||
                        !self.timeContainer.contains(e.relatedTarget))) {
                    setTimeout(function () { return self.hourElement.select(); }, 50);
                }
            }
        }
        function minMaxDateSetter(type) {
            return function (date) {
                var dateObj = (self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat));
                var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
                if (dateObj !== undefined) {
                    self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] =
                        dateObj.getHours() > 0 ||
                            dateObj.getMinutes() > 0 ||
                            dateObj.getSeconds() > 0;
                }
                if (self.selectedDates) {
                    self.selectedDates = self.selectedDates.filter(function (d) { return isEnabled(d); });
                    if (!self.selectedDates.length && type === "min")
                        setHoursFromDate(dateObj);
                    updateValue();
                }
                if (self.daysContainer) {
                    redraw();
                    if (dateObj !== undefined)
                        self.currentYearElement[type] = dateObj.getFullYear().toString();
                    else
                        self.currentYearElement.removeAttribute(type);
                    self.currentYearElement.disabled =
                        !!inverseDateObj &&
                            dateObj !== undefined &&
                            inverseDateObj.getFullYear() === dateObj.getFullYear();
                }
            };
        }
        function parseConfig() {
            var boolOpts = [
                "wrap",
                "weekNumbers",
                "allowInput",
                "clickOpens",
                "time_24hr",
                "enableTime",
                "noCalendar",
                "altInput",
                "shorthandCurrentMonth",
                "inline",
                "static",
                "enableSeconds",
                "disableMobile",
            ];
            var userConfig = __assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));
            var formats = {};
            self.config.parseDate = userConfig.parseDate;
            self.config.formatDate = userConfig.formatDate;
            Object.defineProperty(self.config, "enable", {
                get: function () { return self.config._enable; },
                set: function (dates) {
                    self.config._enable = parseDateRules(dates);
                }
            });
            Object.defineProperty(self.config, "disable", {
                get: function () { return self.config._disable; },
                set: function (dates) {
                    self.config._disable = parseDateRules(dates);
                }
            });
            var timeMode = userConfig.mode === "time";
            if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
                formats.dateFormat =
                    userConfig.noCalendar || timeMode
                        ? "H:i" + (userConfig.enableSeconds ? ":S" : "")
                        : flatpickr.defaultConfig.dateFormat +
                            " H:i" +
                            (userConfig.enableSeconds ? ":S" : "");
            }
            if (userConfig.altInput &&
                (userConfig.enableTime || timeMode) &&
                !userConfig.altFormat) {
                formats.altFormat =
                    userConfig.noCalendar || timeMode
                        ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K")
                        : flatpickr.defaultConfig.altFormat +
                            (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
            }
            Object.defineProperty(self.config, "minDate", {
                get: function () { return self.config._minDate; },
                set: minMaxDateSetter("min")
            });
            Object.defineProperty(self.config, "maxDate", {
                get: function () { return self.config._maxDate; },
                set: minMaxDateSetter("max")
            });
            var minMaxTimeSetter = function (type) { return function (val) {
                self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i");
            }; };
            Object.defineProperty(self.config, "minTime", {
                get: function () { return self.config._minTime; },
                set: minMaxTimeSetter("min")
            });
            Object.defineProperty(self.config, "maxTime", {
                get: function () { return self.config._maxTime; },
                set: minMaxTimeSetter("max")
            });
            if (userConfig.mode === "time") {
                self.config.noCalendar = true;
                self.config.enableTime = true;
            }
            Object.assign(self.config, formats, userConfig);
            for (var i = 0; i < boolOpts.length; i++)
                self.config[boolOpts[i]] =
                    self.config[boolOpts[i]] === true ||
                        self.config[boolOpts[i]] === "true";
            HOOKS.filter(function (hook) { return self.config[hook] !== undefined; }).forEach(function (hook) {
                self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
            });
            self.isMobile =
                !self.config.disableMobile &&
                    !self.config.inline &&
                    self.config.mode === "single" &&
                    !self.config.disable.length &&
                    !self.config.enable.length &&
                    !self.config.weekNumbers &&
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            for (var i = 0; i < self.config.plugins.length; i++) {
                var pluginConf = self.config.plugins[i](self) || {};
                for (var key in pluginConf) {
                    if (HOOKS.indexOf(key) > -1) {
                        self.config[key] = arrayify(pluginConf[key])
                            .map(bindToInstance)
                            .concat(self.config[key]);
                    }
                    else if (typeof userConfig[key] === "undefined")
                        self.config[key] = pluginConf[key];
                }
            }
            triggerEvent("onParseConfig");
        }
        function setupLocale() {
            if (typeof self.config.locale !== "object" &&
                typeof flatpickr.l10ns[self.config.locale] === "undefined")
                self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
            self.l10n = __assign({}, flatpickr.l10ns["default"], (typeof self.config.locale === "object"
                ? self.config.locale
                : self.config.locale !== "default"
                    ? flatpickr.l10ns[self.config.locale]
                    : undefined));
            tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
            self.formatDate = createDateFormatter(self);
            self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
        }
        function positionCalendar(customPositionElement) {
            if (self.calendarContainer === undefined)
                return;
            triggerEvent("onPreCalendarPosition");
            var positionElement = customPositionElement || self._positionElement;
            var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, (function (acc, child) { return acc + child.offsetHeight; }), 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" ||
                (configPosVertical !== "below" &&
                    distanceFromBottom < calendarHeight &&
                    inputBounds.top > calendarHeight);
            var top = window.pageYOffset +
                inputBounds.top +
                (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
            toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
            toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
            if (self.config.inline)
                return;
            var left = window.pageXOffset +
                inputBounds.left -
                (configPosHorizontal != null && configPosHorizontal === "center"
                    ? (calendarWidth - inputBounds.width) / 2
                    : 0);
            var right = window.document.body.offsetWidth - inputBounds.right;
            var rightMost = left + calendarWidth > window.document.body.offsetWidth;
            var centerMost = right + calendarWidth > window.document.body.offsetWidth;
            toggleClass(self.calendarContainer, "rightMost", rightMost);
            if (self.config.static)
                return;
            self.calendarContainer.style.top = top + "px";
            if (!rightMost) {
                self.calendarContainer.style.left = left + "px";
                self.calendarContainer.style.right = "auto";
            }
            else if (!centerMost) {
                self.calendarContainer.style.left = "auto";
                self.calendarContainer.style.right = right + "px";
            }
            else {
                var doc = document.styleSheets[0];
                // some testing environments don't have css support
                if (doc === undefined)
                    return;
                var bodyWidth = window.document.body.offsetWidth;
                var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
                var centerBefore = ".flatpickr-calendar.centerMost:before";
                var centerAfter = ".flatpickr-calendar.centerMost:after";
                var centerIndex = doc.cssRules.length;
                var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
                toggleClass(self.calendarContainer, "rightMost", false);
                toggleClass(self.calendarContainer, "centerMost", true);
                doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
                self.calendarContainer.style.left = centerLeft + "px";
                self.calendarContainer.style.right = "auto";
            }
        }
        function redraw() {
            if (self.config.noCalendar || self.isMobile)
                return;
            updateNavigationCurrentMonth();
            buildDays();
        }
        function focusAndClose() {
            self._input.focus();
            if (window.navigator.userAgent.indexOf("MSIE") !== -1 ||
                navigator.msMaxTouchPoints !== undefined) {
                // hack - bugs in the way IE handles focus keeps the calendar open
                setTimeout(self.close, 0);
            }
            else {
                self.close();
            }
        }
        function selectDate(e) {
            e.preventDefault();
            e.stopPropagation();
            var isSelectable = function (day) {
                return day.classList &&
                    day.classList.contains("flatpickr-day") &&
                    !day.classList.contains("disabled") &&
                    !day.classList.contains("notAllowed");
            };
            var t = findParent(e.target, isSelectable);
            if (t === undefined)
                return;
            var target = t;
            var selectedDate = (self.latestSelectedDateObj = new Date(target.dateObj.getTime()));
            var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth ||
                selectedDate.getMonth() >
                    self.currentMonth + self.config.showMonths - 1) &&
                self.config.mode !== "range";
            self.selectedDateElem = target;
            if (self.config.mode === "single")
                self.selectedDates = [selectedDate];
            else if (self.config.mode === "multiple") {
                var selectedIndex = isDateSelected(selectedDate);
                if (selectedIndex)
                    self.selectedDates.splice(parseInt(selectedIndex), 1);
                else
                    self.selectedDates.push(selectedDate);
            }
            else if (self.config.mode === "range") {
                if (self.selectedDates.length === 2) {
                    self.clear(false, false);
                }
                self.latestSelectedDateObj = selectedDate;
                self.selectedDates.push(selectedDate);
                // unless selecting same date twice, sort ascendingly
                if (compareDates(selectedDate, self.selectedDates[0], true) !== 0)
                    self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
            }
            setHoursFromInputs();
            if (shouldChangeMonth) {
                var isNewYear = self.currentYear !== selectedDate.getFullYear();
                self.currentYear = selectedDate.getFullYear();
                self.currentMonth = selectedDate.getMonth();
                if (isNewYear)
                    triggerEvent("onYearChange");
                triggerEvent("onMonthChange");
            }
            updateNavigationCurrentMonth();
            buildDays();
            updateValue();
            if (self.config.enableTime)
                setTimeout(function () { return (self.showTimeInput = true); }, 50);
            // maintain focus
            if (!shouldChangeMonth &&
                self.config.mode !== "range" &&
                self.config.showMonths === 1)
                focusOnDayElem(target);
            else if (self.selectedDateElem !== undefined &&
                self.hourElement === undefined) {
                self.selectedDateElem && self.selectedDateElem.focus();
            }
            if (self.hourElement !== undefined)
                self.hourElement !== undefined && self.hourElement.focus();
            if (self.config.closeOnSelect) {
                var single = self.config.mode === "single" && !self.config.enableTime;
                var range = self.config.mode === "range" &&
                    self.selectedDates.length === 2 &&
                    !self.config.enableTime;
                if (single || range) {
                    focusAndClose();
                }
            }
            triggerChange();
        }
        var CALLBACKS = {
            locale: [setupLocale, updateWeekdays],
            showMonths: [buildMonths, setCalendarWidth, buildWeekdays]
        };
        function set(option, value) {
            if (option !== null && typeof option === "object")
                Object.assign(self.config, option);
            else {
                self.config[option] = value;
                if (CALLBACKS[option] !== undefined)
                    CALLBACKS[option].forEach(function (x) { return x(); });
                else if (HOOKS.indexOf(option) > -1)
                    self.config[option] = arrayify(value);
            }
            self.redraw();
            updateValue(false);
        }
        function setSelectedDate(inputDate, format) {
            var dates = [];
            if (inputDate instanceof Array)
                dates = inputDate.map(function (d) { return self.parseDate(d, format); });
            else if (inputDate instanceof Date || typeof inputDate === "number")
                dates = [self.parseDate(inputDate, format)];
            else if (typeof inputDate === "string") {
                switch (self.config.mode) {
                    case "single":
                    case "time":
                        dates = [self.parseDate(inputDate, format)];
                        break;
                    case "multiple":
                        dates = inputDate
                            .split(self.config.conjunction)
                            .map(function (date) { return self.parseDate(date, format); });
                        break;
                    case "range":
                        dates = inputDate
                            .split(self.l10n.rangeSeparator)
                            .map(function (date) { return self.parseDate(date, format); });
                        break;
                    default:
                        break;
                }
            }
            else
                self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
            self.selectedDates = dates.filter(function (d) { return d instanceof Date && isEnabled(d, false); });
            if (self.config.mode === "range")
                self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
        }
        function setDate(date, triggerChange, format) {
            if (triggerChange === void 0) { triggerChange = false; }
            if (format === void 0) { format = self.config.dateFormat; }
            if ((date !== 0 && !date) || (date instanceof Array && date.length === 0))
                return self.clear(triggerChange);
            setSelectedDate(date, format);
            self.showTimeInput = self.selectedDates.length > 0;
            self.latestSelectedDateObj = self.selectedDates[0];
            self.redraw();
            jumpToDate();
            setHoursFromDate();
            updateValue(triggerChange);
            if (triggerChange)
                triggerEvent("onChange");
        }
        function parseDateRules(arr) {
            return arr
                .slice()
                .map(function (rule) {
                if (typeof rule === "string" ||
                    typeof rule === "number" ||
                    rule instanceof Date) {
                    return self.parseDate(rule, undefined, true);
                }
                else if (rule &&
                    typeof rule === "object" &&
                    rule.from &&
                    rule.to)
                    return {
                        from: self.parseDate(rule.from, undefined),
                        to: self.parseDate(rule.to, undefined)
                    };
                return rule;
            })
                .filter(function (x) { return x; }); // remove falsy values
        }
        function setupDates() {
            self.selectedDates = [];
            self.now = self.parseDate(self.config.now) || new Date();
            // Workaround IE11 setting placeholder as the input's value
            var preloadedDate = self.config.defaultDate ||
                ((self.input.nodeName === "INPUT" ||
                    self.input.nodeName === "TEXTAREA") &&
                    self.input.placeholder &&
                    self.input.value === self.input.placeholder
                    ? null
                    : self.input.value);
            if (preloadedDate)
                setSelectedDate(preloadedDate, self.config.dateFormat);
            self._initialDate =
                self.selectedDates.length > 0
                    ? self.selectedDates[0]
                    : self.config.minDate &&
                        self.config.minDate.getTime() > self.now.getTime()
                        ? self.config.minDate
                        : self.config.maxDate &&
                            self.config.maxDate.getTime() < self.now.getTime()
                            ? self.config.maxDate
                            : self.now;
            self.currentYear = self._initialDate.getFullYear();
            self.currentMonth = self._initialDate.getMonth();
            if (self.selectedDates.length > 0)
                self.latestSelectedDateObj = self.selectedDates[0];
            if (self.config.minTime !== undefined)
                self.config.minTime = self.parseDate(self.config.minTime, "H:i");
            if (self.config.maxTime !== undefined)
                self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
            self.minDateHasTime =
                !!self.config.minDate &&
                    (self.config.minDate.getHours() > 0 ||
                        self.config.minDate.getMinutes() > 0 ||
                        self.config.minDate.getSeconds() > 0);
            self.maxDateHasTime =
                !!self.config.maxDate &&
                    (self.config.maxDate.getHours() > 0 ||
                        self.config.maxDate.getMinutes() > 0 ||
                        self.config.maxDate.getSeconds() > 0);
            Object.defineProperty(self, "showTimeInput", {
                get: function () { return self._showTimeInput; },
                set: function (bool) {
                    self._showTimeInput = bool;
                    if (self.calendarContainer)
                        toggleClass(self.calendarContainer, "showTimeInput", bool);
                    self.isOpen && positionCalendar();
                }
            });
        }
        function setupInputs() {
            self.input = self.config.wrap
                ? element.querySelector("[data-input]")
                : element;
            /* istanbul ignore next */
            if (!self.input) {
                self.config.errorHandler(new Error("Invalid input element specified"));
                return;
            }
            // hack: store previous type to restore it after destroy()
            self.input._type = self.input.type;
            self.input.type = "text";
            self.input.classList.add("flatpickr-input");
            self._input = self.input;
            if (self.config.altInput) {
                // replicate self.element
                self.altInput = createElement(self.input.nodeName, self.input.className + " " + self.config.altInputClass);
                self._input = self.altInput;
                self.altInput.placeholder = self.input.placeholder;
                self.altInput.disabled = self.input.disabled;
                self.altInput.required = self.input.required;
                self.altInput.tabIndex = self.input.tabIndex;
                self.altInput.type = "text";
                self.input.setAttribute("type", "hidden");
                if (!self.config.static && self.input.parentNode)
                    self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
            }
            if (!self.config.allowInput)
                self._input.setAttribute("readonly", "readonly");
            self._positionElement = self.config.positionElement || self._input;
        }
        function setupMobile() {
            var inputType = self.config.enableTime
                ? self.config.noCalendar
                    ? "time"
                    : "datetime-local"
                : "date";
            self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
            self.mobileInput.step = self.input.getAttribute("step") || "any";
            self.mobileInput.tabIndex = 1;
            self.mobileInput.type = inputType;
            self.mobileInput.disabled = self.input.disabled;
            self.mobileInput.required = self.input.required;
            self.mobileInput.placeholder = self.input.placeholder;
            self.mobileFormatStr =
                inputType === "datetime-local"
                    ? "Y-m-d\\TH:i:S"
                    : inputType === "date"
                        ? "Y-m-d"
                        : "H:i:S";
            if (self.selectedDates.length > 0) {
                self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
            }
            if (self.config.minDate)
                self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
            if (self.config.maxDate)
                self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
            self.input.type = "hidden";
            if (self.altInput !== undefined)
                self.altInput.type = "hidden";
            try {
                if (self.input.parentNode)
                    self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
            }
            catch (_a) { }
            bind(self.mobileInput, "change", function (e) {
                self.setDate(e.target.value, false, self.mobileFormatStr);
                triggerEvent("onChange");
                triggerEvent("onClose");
            });
        }
        function toggle(e) {
            if (self.isOpen === true)
                return self.close();
            self.open(e);
        }
        function triggerEvent(event, data) {
            // If the instance has been destroyed already, all hooks have been removed
            if (self.config === undefined)
                return;
            var hooks = self.config[event];
            if (hooks !== undefined && hooks.length > 0) {
                for (var i = 0; hooks[i] && i < hooks.length; i++)
                    hooks[i](self.selectedDates, self.input.value, self, data);
            }
            if (event === "onChange") {
                self.input.dispatchEvent(createEvent("change"));
                // many front-end frameworks bind to the input event
                self.input.dispatchEvent(createEvent("input"));
            }
        }
        function createEvent(name) {
            var e = document.createEvent("Event");
            e.initEvent(name, true, true);
            return e;
        }
        function isDateSelected(date) {
            for (var i = 0; i < self.selectedDates.length; i++) {
                if (compareDates(self.selectedDates[i], date) === 0)
                    return "" + i;
            }
            return false;
        }
        function isDateInRange(date) {
            if (self.config.mode !== "range" || self.selectedDates.length < 2)
                return false;
            return (compareDates(date, self.selectedDates[0]) >= 0 &&
                compareDates(date, self.selectedDates[1]) <= 0);
        }
        function updateNavigationCurrentMonth() {
            if (self.config.noCalendar || self.isMobile || !self.monthNav)
                return;
            self.yearElements.forEach(function (yearElement, i) {
                var d = new Date(self.currentYear, self.currentMonth, 1);
                d.setMonth(self.currentMonth + i);
                self.monthElements[i].textContent =
                    monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) +
                        " ";
                yearElement.value = d.getFullYear().toString();
            });
            self._hidePrevMonthArrow =
                self.config.minDate !== undefined &&
                    (self.currentYear === self.config.minDate.getFullYear()
                        ? self.currentMonth <= self.config.minDate.getMonth()
                        : self.currentYear < self.config.minDate.getFullYear());
            self._hideNextMonthArrow =
                self.config.maxDate !== undefined &&
                    (self.currentYear === self.config.maxDate.getFullYear()
                        ? self.currentMonth + 1 > self.config.maxDate.getMonth()
                        : self.currentYear > self.config.maxDate.getFullYear());
        }
        function getDateStr(format) {
            return self.selectedDates
                .map(function (dObj) { return self.formatDate(dObj, format); })
                .filter(function (d, i, arr) {
                return self.config.mode !== "range" ||
                    self.config.enableTime ||
                    arr.indexOf(d) === i;
            })
                .join(self.config.mode !== "range"
                ? self.config.conjunction
                : self.l10n.rangeSeparator);
        }
        /**
         * Updates the values of inputs associated with the calendar
         */
        function updateValue(triggerChange) {
            if (triggerChange === void 0) { triggerChange = true; }
            if (self.selectedDates.length === 0)
                return self.clear(triggerChange);
            if (self.mobileInput !== undefined && self.mobileFormatStr) {
                self.mobileInput.value =
                    self.latestSelectedDateObj !== undefined
                        ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr)
                        : "";
            }
            self.input.value = getDateStr(self.config.dateFormat);
            if (self.altInput !== undefined) {
                self.altInput.value = getDateStr(self.config.altFormat);
            }
            if (triggerChange !== false)
                triggerEvent("onValueUpdate");
        }
        function onMonthNavClick(e) {
            e.preventDefault();
            var isPrevMonth = self.prevMonthNav.contains(e.target);
            var isNextMonth = self.nextMonthNav.contains(e.target);
            if (isPrevMonth || isNextMonth) {
                changeMonth(isPrevMonth ? -1 : 1);
            }
            else if (self.yearElements.indexOf(e.target) >= 0) {
                e.target.select();
            }
            else if (e.target.classList.contains("arrowUp")) {
                self.changeYear(self.currentYear + 1);
            }
            else if (e.target.classList.contains("arrowDown")) {
                self.changeYear(self.currentYear - 1);
            }
        }
        function timeWrapper(e) {
            e.preventDefault();
            var isKeyDown = e.type === "keydown", input = e.target;
            if (self.amPM !== undefined && e.target === self.amPM) {
                self.amPM.textContent =
                    self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
            }
            var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta ||
                (isKeyDown ? (e.which === 38 ? 1 : -1) : 0);
            var newValue = curValue + step * delta;
            if (typeof input.value !== "undefined" && input.value.length === 2) {
                var isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
                if (newValue < min) {
                    newValue =
                        max +
                            newValue +
                            int(!isHourElem) +
                            (int(isHourElem) && int(!self.amPM));
                    if (isMinuteElem)
                        incrementNumInput(undefined, -1, self.hourElement);
                }
                else if (newValue > max) {
                    newValue =
                        input === self.hourElement ? newValue - max - int(!self.amPM) : min;
                    if (isMinuteElem)
                        incrementNumInput(undefined, 1, self.hourElement);
                }
                if (self.amPM &&
                    isHourElem &&
                    (step === 1
                        ? newValue + curValue === 23
                        : Math.abs(newValue - curValue) > step)) {
                    self.amPM.textContent =
                        self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
                }
                input.value = pad(newValue);
            }
        }
        init();
        return self;
    }
    /* istanbul ignore next */
    function _flatpickr(nodeList, config) {
        // static list
        var nodes = Array.prototype.slice
            .call(nodeList)
            .filter(function (x) { return x instanceof HTMLElement; });
        var instances = [];
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            try {
                if (node.getAttribute("data-fp-omit") !== null)
                    continue;
                if (node._flatpickr !== undefined) {
                    node._flatpickr.destroy();
                    node._flatpickr = undefined;
                }
                node._flatpickr = FlatpickrInstance(node, config || {});
                instances.push(node._flatpickr);
            }
            catch (e) {
                console.error(e);
            }
        }
        return instances.length === 1 ? instances[0] : instances;
    }
    /* istanbul ignore next */
    if (typeof HTMLElement !== "undefined") {
        // browser env
        HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
            return _flatpickr(this, config);
        };
        HTMLElement.prototype.flatpickr = function (config) {
            return _flatpickr([this], config);
        };
    }
    /* istanbul ignore next */
    var flatpickr = function (selector, config) {
        if (typeof selector === "string") {
            return _flatpickr(window.document.querySelectorAll(selector), config);
        }
        else if (selector instanceof Node) {
            return _flatpickr([selector], config);
        }
        else {
            return _flatpickr(selector, config);
        }
    };
    /* istanbul ignore next */
    flatpickr.defaultConfig = defaults;
    flatpickr.l10ns = {
        en: __assign({}, english),
        "default": __assign({}, english)
    };
    flatpickr.localize = function (l10n) {
        flatpickr.l10ns["default"] = __assign({}, flatpickr.l10ns["default"], l10n);
    };
    flatpickr.setDefaults = function (config) {
        flatpickr.defaultConfig = __assign({}, flatpickr.defaultConfig, config);
    };
    flatpickr.parseDate = createDateParser({});
    flatpickr.formatDate = createDateFormatter({});
    flatpickr.compareDates = compareDates;
    /* istanbul ignore next */
    if (typeof jQuery !== "undefined") {
        jQuery.fn.flatpickr = function (config) {
            return _flatpickr(this, config);
        };
    }
    Date.prototype.fp_incr = function (days) {
        return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
    };
    if (typeof window !== "undefined") {
        window.flatpickr = flatpickr;
    }

    return flatpickr;

}));

},{}],39:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.de = {}));
}(this, function (exports) { 'use strict';

  var fp = typeof window !== "undefined" && window.flatpickr !== undefined
      ? window.flatpickr
      : {
          l10ns: {}
      };
  var German = {
      weekdays: {
          shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
          longhand: [
              "Sonntag",
              "Montag",
              "Dienstag",
              "Mittwoch",
              "Donnerstag",
              "Freitag",
              "Samstag",
          ]
      },
      months: {
          shorthand: [
              "Jan",
              "Feb",
              "Mär",
              "Apr",
              "Mai",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Okt",
              "Nov",
              "Dez",
          ],
          longhand: [
              "Januar",
              "Februar",
              "März",
              "April",
              "Mai",
              "Juni",
              "Juli",
              "August",
              "September",
              "Oktober",
              "November",
              "Dezember",
          ]
      },
      firstDayOfWeek: 1,
      weekAbbreviation: "KW",
      rangeSeparator: " bis ",
      scrollTitle: "Zum Ändern scrollen",
      toggleTitle: "Zum Umschalten klicken"
  };
  fp.l10ns.de = German;
  var de = fp.l10ns;

  exports.German = German;
  exports.default = de;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],40:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.fr = {}));
}(this, function (exports) { 'use strict';

  var fp = typeof window !== "undefined" && window.flatpickr !== undefined
      ? window.flatpickr
      : {
          l10ns: {}
      };
  var French = {
      firstDayOfWeek: 1,
      weekdays: {
          shorthand: ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"],
          longhand: [
              "dimanche",
              "lundi",
              "mardi",
              "mercredi",
              "jeudi",
              "vendredi",
              "samedi",
          ]
      },
      months: {
          shorthand: [
              "janv",
              "févr",
              "mars",
              "avr",
              "mai",
              "juin",
              "juil",
              "août",
              "sept",
              "oct",
              "nov",
              "déc",
          ],
          longhand: [
              "janvier",
              "février",
              "mars",
              "avril",
              "mai",
              "juin",
              "juillet",
              "août",
              "septembre",
              "octobre",
              "novembre",
              "décembre",
          ]
      },
      ordinal: function (nth) {
          if (nth > 1)
              return "";
          return "er";
      },
      rangeSeparator: " au ",
      weekAbbreviation: "Sem",
      scrollTitle: "Défiler pour augmenter la valeur",
      toggleTitle: "Cliquer pour basculer"
  };
  fp.l10ns.fr = French;
  var fr = fp.l10ns;

  exports.French = French;
  exports.default = fr;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],41:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.it = {}));
}(this, function (exports) { 'use strict';

  var fp = typeof window !== "undefined" && window.flatpickr !== undefined
      ? window.flatpickr
      : {
          l10ns: {}
      };
  var Italian = {
      weekdays: {
          shorthand: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
          longhand: [
              "Domenica",
              "Lunedì",
              "Martedì",
              "Mercoledì",
              "Giovedì",
              "Venerdì",
              "Sabato",
          ]
      },
      months: {
          shorthand: [
              "Gen",
              "Feb",
              "Mar",
              "Apr",
              "Mag",
              "Giu",
              "Lug",
              "Ago",
              "Set",
              "Ott",
              "Nov",
              "Dic",
          ],
          longhand: [
              "Gennaio",
              "Febbraio",
              "Marzo",
              "Aprile",
              "Maggio",
              "Giugno",
              "Luglio",
              "Agosto",
              "Settembre",
              "Ottobre",
              "Novembre",
              "Dicembre",
          ]
      },
      firstDayOfWeek: 1,
      ordinal: function () { return "°"; },
      rangeSeparator: " al ",
      weekAbbreviation: "Se",
      scrollTitle: "Scrolla per aumentare",
      toggleTitle: "Clicca per cambiare"
  };
  fp.l10ns.it = Italian;
  var it = fp.l10ns;

  exports.Italian = Italian;
  exports.default = it;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],42:[function(require,module,exports){
(function (global){
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Popper = factory());
}(this, (function () { 'use strict';

var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

var timeoutDuration = function () {
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }
  return 0;
}();

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */
function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent || null;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicitly asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);

  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;

  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

    // flips variation if reference element overflows boundaries
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    // flips variation if popper content overflows boundaries
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',
    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,
    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

return Popper;

})));


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],43:[function(require,module,exports){
(function (global){
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    __classPrivateFieldGet = function (receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    };

    __classPrivateFieldSet = function (receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[3])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJtYWluL3BvbHlmaWxscy9NYXRoLnNpZ24udHMiLCJtYWluL3BvbHlmaWxscy9zdGFydHNXaXRoLnRzIiwibWFpbi9zZHgudHMiLCJtYWluL3NyYy9Eb21FbGVtZW50LnRzIiwibWFpbi9zcmMvRG9tRnVuY3Rpb25zLnRzIiwibWFpbi9zcmMvSW5wdXRzLnRzIiwibWFpbi9zcmMvVXRpbHMudHMiLCJtYWluL3NyYy9hY2NvcmRpb24vQWNjb3JkaW9uLnRzIiwibWFpbi9zcmMvY2Fyb3VzZWwvQ2Fyb3VzZWwudHMiLCJtYWluL3NyYy9jaGFydHMvQmFyQ2hhcnRIb3Jpem9udGFsLnRzIiwibWFpbi9zcmMvY2hhcnRzL0JhckNoYXJ0VmVydGljYWwudHMiLCJtYWluL3NyYy9jaGFydHMvQ2hhcnRGdW5jdGlvbnMudHMiLCJtYWluL3NyYy9jaGFydHMvUGllQ2hhcnQudHMiLCJtYWluL3NyYy9jb2xsYXBzZS9Db2xsYXBzZS50cyIsIm1haW4vc3JjL2VtcHR5LXN0YXRlcy9FbXB0eVN0YXRlLnRzIiwibWFpbi9zcmMvZm9ybS9BdXRvY29tcGxldGUudHMiLCJtYWluL3NyYy9mb3JtL0lucHV0RmllbGQudHMiLCJtYWluL3NyYy9mb3JtL1JhbmdlLnRzIiwibWFpbi9zcmMvZm9ybS9TZWxlY3QudHMiLCJtYWluL3NyYy9mb3JtL1RleHRhcmVhLnRzIiwibWFpbi9zcmMvbG9hZGVyL0xvYWRlckJhci50cyIsIm1haW4vc3JjL21lbnUvTWVudUZseW91dC50cyIsIm1haW4vc3JjL21vZGFsL01vZGFsLnRzIiwibWFpbi9zcmMvbmF2aWdhdGlvbi9OYXZpZ2F0aW9uLnRzIiwibWFpbi9zcmMvbmF2aWdhdGlvbi9OYXZpZ2F0aW9uU2lkZS50cyIsIm1haW4vc3JjL25vdGlmaWNhdGlvbi9Ob3RpZmljYXRpb24udHMiLCJtYWluL3NyYy9wcm9ncmVzcy9Qcm9ncmVzc0Z1bGwudHMiLCJtYWluL3NyYy9wcm9ncmVzcy9Qcm9ncmVzc0xpZ2h0LnRzIiwibWFpbi9zcmMvc2R4LnRzIiwibWFpbi9zcmMvc2VhcmNoL1NlYXJjaElucHV0LnRzIiwibWFpbi9zcmMvdGFibGUvVGFibGUudHMiLCJtYWluL3NyYy90b29sYmFyL1Rvb2xiYXIudHMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwibm9kZV9tb2R1bGVzL2FuaW1lanMvbGliL2FuaW1lLmpzIiwibm9kZV9tb2R1bGVzL2JvZHktc2Nyb2xsLWxvY2svbGliL2JvZHlTY3JvbGxMb2NrLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9mbGF0cGlja3IvZGlzdC9mbGF0cGlja3IuanMiLCJub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvbDEwbi9kZS5qcyIsIm5vZGVfbW9kdWxlcy9mbGF0cGlja3IvZGlzdC9sMTBuL2ZyLmpzIiwibm9kZV9tb2R1bGVzL2ZsYXRwaWNrci9kaXN0L2wxMG4vaXQuanMiLCJub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvdW1kL3BvcHBlci5qcyIsIm5vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtjQ0FBOztBQUNBLElBQUksRUFBRSxVQUFOLElBQUksQ0FBSixFQUF1QjtBQUNwQixFQUFBLElBQVksQ0FBWixJQUFBLEdBQW9CLFVBQUEsQ0FBQSxFQUFrQjtBQUNyQyxXQUFRLENBQUMsR0FBRixDQUFDLEdBQUQsQ0FBQyxHQUFlLENBQUMsR0FBRixDQUFDLEdBQVMsQ0FBVixDQUFDLEdBQWMsQ0FBckMsQ0FBQTtBQURELEdBQUE7QUFHRjs7O0FDTEQ7O0FBRUEsSUFBSSxDQUFDLE1BQU0sQ0FBTixT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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsd0NBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbjhFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hrRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvLyBNYXRoLnNpZ24gKHVzZWQgaW4gUHJvZ3Jlc3NGdWxsKVxuaWYgKCEoXCJzaWduXCIgaW4gTWF0aCkpIHtcbiAgKE1hdGggYXMgYW55KS5zaWduID0gZnVuY3Rpb24oeDogbnVtYmVyKSB7XG4gICAgcmV0dXJuICh4ID4gMCkgPyAxIDogKCh4IDwgMCkgPyAtMSA6ICt4KVxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCkge1xuICBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggPSBmdW5jdGlvbihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiB8fCAwXG4gICAgcmV0dXJuIHRoaXMuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSA9PT0gcG9zaXRpb25cbiAgfVxufVxuIiwiLyogUG9seWZpbGxzICovXG5pbXBvcnQgXCIuL3BvbHlmaWxscy9NYXRoLnNpZ25cIlxuaW1wb3J0IFwiLi9wb2x5ZmlsbHMvc3RhcnRzV2l0aFwiXG5cbmltcG9ydCAqIGFzIHNkeEV4cG9ydHMgZnJvbSBcIi4vc3JjL3NkeFwiXG5cbmV4cG9ydCBpbnRlcmZhY2UgU0RYR2xvYmFsIHtcbiAgVkVSU0lPTjogc3RyaW5nXG5cbiAgTG9hZGVyQmFyOiB0eXBlb2Ygc2R4RXhwb3J0cy5Mb2FkZXJCYXJcblxuICBTZWxlY3Q6IHR5cGVvZiBzZHhFeHBvcnRzLlNlbGVjdFxuICBJbnB1dEZpZWxkOiB0eXBlb2Ygc2R4RXhwb3J0cy5JbnB1dEZpZWxkXG4gIFRleHRhcmVhOiB0eXBlb2Ygc2R4RXhwb3J0cy5UZXh0YXJlYVxuICBBdXRvY29tcGxldGU6IHR5cGVvZiBzZHhFeHBvcnRzLkF1dG9jb21wbGV0ZVxuXG4gIFByb2dyZXNzTGlnaHQ6IHR5cGVvZiBzZHhFeHBvcnRzLlByb2dyZXNzTGlnaHRcbiAgUHJvZ3Jlc3NGdWxsOiB0eXBlb2Ygc2R4RXhwb3J0cy5Qcm9ncmVzc0Z1bGxcblxuICBSYW5nZTogdHlwZW9mIHNkeEV4cG9ydHMuUmFuZ2VcbiAgTW9kYWw6IHR5cGVvZiBzZHhFeHBvcnRzLk1vZGFsXG4gIFRvb2xiYXI6IHR5cGVvZiBzZHhFeHBvcnRzLlRvb2xiYXJcbiAgTm90aWZpY2F0aW9uOiB0eXBlb2Ygc2R4RXhwb3J0cy5Ob3RpZmljYXRpb25cblxuICBDb2xsYXBzZTogdHlwZW9mIHNkeEV4cG9ydHMuQ29sbGFwc2VcbiAgQWNjb3JkaW9uOiB0eXBlb2Ygc2R4RXhwb3J0cy5BY2NvcmRpb25cblxuICBNZW51Rmx5b3V0OiB0eXBlb2Ygc2R4RXhwb3J0cy5NZW51Rmx5b3V0XG5cbiAgTmF2aWdhdGlvbjogdHlwZW9mIHNkeEV4cG9ydHMuTmF2aWdhdGlvblxuICBOYXZpZ2F0aW9uU2lkZTogdHlwZW9mIHNkeEV4cG9ydHMuTmF2aWdhdGlvblNpZGVcbiAgU2VhcmNoSW5wdXQ6IHR5cGVvZiBzZHhFeHBvcnRzLlNlYXJjaElucHV0XG4gIEVtcHR5U3RhdGU6IHR5cGVvZiBzZHhFeHBvcnRzLkVtcHR5U3RhdGVcbiAgQ2Fyb3VzZWw6IHR5cGVvZiBzZHhFeHBvcnRzLkNhcm91c2VsXG5cbiAgVGFibGU6IHR5cGVvZiBzZHhFeHBvcnRzLlRhYmxlXG5cbiAgUGllQ2hhcnQ6IHR5cGVvZiBzZHhFeHBvcnRzLlBpZUNoYXJ0XG4gIEJhckNoYXJ0SG9yaXpvbnRhbDogdHlwZW9mIHNkeEV4cG9ydHMuQmFyQ2hhcnRIb3Jpem9udGFsXG4gIEJhckNoYXJ0VmVydGljYWw6IHR5cGVvZiBzZHhFeHBvcnRzLkJhckNoYXJ0VmVydGljYWxcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBzZHg6IFNEWEdsb2JhbFxuICB9XG59XG5cbmxldCBzZHggPSB7XG4gIC4uLnNkeEV4cG9ydHMsXG4gIC4uLih3aW5kb3cuc2R4IGFzIGFueSkgfHwge30sXG4gIFZFUlNJT046IFwiJFZFUlNJT04kXCJcbn1cblxud2luZG93LnNkeCA9IHNkeFxuXG5zZHhFeHBvcnRzLnV0aWxzLm9uRG9jdW1lbnRSZWFkeSgoKSA9PiB7XG4gIHNkeEV4cG9ydHMuaW5pdElucHV0RmllbGQoKVxuICBzZHhFeHBvcnRzLmluaXRUZXh0YXJlYSgpXG4gIHNkeEV4cG9ydHMuaW5pdFNlbGVjdCgpXG4gIHNkeEV4cG9ydHMuaW5pdExvYWRlckJhcigpXG4gIHNkeEV4cG9ydHMuaW5pdEF1dG9jb21wbGV0ZSgpXG5cbiAgc2R4RXhwb3J0cy5pbml0UHJvZ3Jlc3NMaWdodCgpXG4gIHNkeEV4cG9ydHMuaW5pdFByb2dyZXNzRnVsbCgpXG5cbiAgc2R4RXhwb3J0cy5pbml0UmFuZ2UoKVxuICBzZHhFeHBvcnRzLmluaXRNb2RhbCgpXG5cbiAgc2R4RXhwb3J0cy5pbml0QWNjb3JkaW9uKClcbiAgc2R4RXhwb3J0cy5pbml0Q29sbGFwc2UoKVxuICBzZHhFeHBvcnRzLmluaXRNZW51Rmx5b3V0KClcblxuICBzZHhFeHBvcnRzLmluaXROYXZpZ2F0aW9uKClcbiAgc2R4RXhwb3J0cy5pbml0TmF2aWdhdGlvblNpZGUoKVxuICBzZHhFeHBvcnRzLmluaXRTZWFyY2hJbnB1dCgpXG4gIHNkeEV4cG9ydHMuaW5pdEVtcHR5U3RhdGUoKVxuICBzZHhFeHBvcnRzLmluaXRDYXJvdXNlbCgpXG4gIHNkeEV4cG9ydHMuaW5pdFRhYmxlKClcblxuICBzZHhFeHBvcnRzLmluaXRQaWVDaGFydCgpXG4gIHNkeEV4cG9ydHMuaW5pdEJhckNoYXJ0SG9yaXpvbnRhbCgpXG4gIHNkeEV4cG9ydHMuaW5pdEJhckNoYXJ0VmVydGljYWwoKVxufSlcbiIsImltcG9ydCAqIGFzIERvbSBmcm9tIFwiLi9Eb21GdW5jdGlvbnNcIlxuXG5sZXQgaHRtbEV2ZW50czoge1xuICBbZXZlbnROYW1lOiBzdHJpbmddOiAoKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIEEgd3JhcHBlciBjbGFzcyBmb3IgRE9NIEVsZW1lbnRzLlxuICovXG5jbGFzcyBEb21FbGVtZW50PFQgZXh0ZW5kcyBFbGVtZW50ID0gRWxlbWVudD4ge1xuICBwdWJsaWMgZWxlbWVudDogVFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtFbGVtZW50fSAtIFRoZSBlbGVtZW50IHRvIHdyYXAuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAtIFRoZSBET00gZWxlbWVudCB0byBjcmVhdGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBUIHwga2V5b2YgRWxlbWVudFRhZ05hbWVNYXApIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudCkgYXMgRWxlbWVudCBhcyBUXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgc3BlY2lmaWVkIENTUyBjbGFzcyB0byB0aGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IC0gVGhlIGNsYXNzIG5hbWUgdG8gYWRkLlxuICAgKiBAcmV0dXJuIHtEb21FbGVtZW50fSBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlIGZvciBmbHVlbnQgY2hhaW5pbmcgb2YgY2FsbHMuXG4gICAqL1xuICBwdWJsaWMgYWRkQ2xhc3MobmFtZTogc3RyaW5nKSB7XG4gICAgRG9tLmFkZENsYXNzKHRoaXMuZWxlbWVudCwgbmFtZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBDU1MgY2xhc3MgZnJvbSB0aGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IC0gVGhlIGNsYXNzIG5hbWUgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHtEb21FbGVtZW50fSBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlIGZvciBmbHVlbnQgY2hhaW5pbmcgb2YgY2FsbHMuXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlQ2xhc3MobmFtZTogc3RyaW5nKSB7XG4gICAgRG9tLnJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudCwgbmFtZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHVibGljIGhhc0NsYXNzKG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiBEb20uaGFzQ2xhc3ModGhpcy5lbGVtZW50LCBuYW1lKVxuICB9XG5cbiAgcHVibGljIHRvZ2dsZUNsYXNzKG5hbWU6IHN0cmluZykge1xuICAgIERvbS50b2dnbGVDbGFzcyh0aGlzLmVsZW1lbnQsIG5hbWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBjbGFzc2VzKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0XG4gIH1cblxuICBwdWJsaWMgc2V0SWQoaWQ6IHN0cmluZykge1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IGlubmVyVGV4dCgpIHtcbiAgICByZXR1cm4gRG9tLnRleHQodGhpcy5lbGVtZW50KVxuICB9XG5cbiAgZ2V0IGlubmVySHRtbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmlubmVySFRNTFxuICB9XG5cbiAgcHVibGljIHNldEh0bWwodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIEhUTUwgc3RyaW5nXCIpXG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IHZhbHVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHB1YmxpYyBnZXRBdHRyaWJ1dGUobmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUobmFtZSlcbiAgfVxuXG4gIHB1YmxpYyBzZXRBdHRyaWJ1dGUobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lci5cbiAgICovXG4gIHB1YmxpYyBhZGRFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBrZXlvZiBIVE1MRWxlbWVudEV2ZW50TWFwPih0eXBlOiBULCBsaXN0ZW5lcjogKGU6IEV2ZW50KSA9PiB2b2lkKSB7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpXG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIHB1YmxpYyByZW1vdmVFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBrZXlvZiBIVE1MRWxlbWVudEV2ZW50TWFwPih0eXBlOiBULCBsaXN0ZW5lcjogKGU6IEV2ZW50KSA9PiB2b2lkKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpXG4gIH1cblxuICBwdWJsaWMgYXBwZW5kQ2hpbGQobmV3Q2hpbGQ6IERvbUVsZW1lbnQpIHtcbiAgICBpZiAoIShuZXdDaGlsZCBpbnN0YW5jZW9mIERvbUVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG90aGVyIERvbUVsZW1lbnRzIGNhbiBiZSBhZGRlZCBhcyBjaGlsZHJlblwiKVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChuZXdDaGlsZC5lbGVtZW50KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgcHJlcGVuZENoaWxkKG5ld0NoaWxkOiBEb21FbGVtZW50KSB7XG4gICAgaWYgKCEobmV3Q2hpbGQgaW5zdGFuY2VvZiBEb21FbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBvdGhlciBEb21FbGVtZW50cyBjYW4gYmUgYWRkZWQgYXMgY2hpbGRyZW5cIilcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLmVsZW1lbnQsIHRoaXMuZWxlbWVudC5maXJzdENoaWxkKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgaW5zZXJ0QmVmb3JlKG5ld0NoaWxkOiBEb21FbGVtZW50KSB7XG4gICAgaWYgKCEobmV3Q2hpbGQgaW5zdGFuY2VvZiBEb21FbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBvdGhlciBEb21FbGVtZW50cyBjYW4gYmUgYWRkZWQgYXMgY2hpbGRyZW5cIilcbiAgICB9XG4gICAgaWYgKCF0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCBpcyBub3QgYXR0YWNoZWRcIilcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Q2hpbGQuZWxlbWVudCwgdGhpcy5lbGVtZW50KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgaW5zZXJ0QWZ0ZXIobmV3Q2hpbGQ6IERvbUVsZW1lbnQpIHtcbiAgICBpZiAoIShuZXdDaGlsZCBpbnN0YW5jZW9mIERvbUVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG90aGVyIERvbUVsZW1lbnRzIGNhbiBiZSBhZGRlZCBhcyBjaGlsZHJlblwiKVxuICAgIH1cbiAgICBpZiAoIXRoaXMuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IGlzIG5vdCBhdHRhY2hlZFwiKVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdDaGlsZC5lbGVtZW50LCB0aGlzLmVsZW1lbnQubmV4dFNpYmxpbmcpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVDaGlsZChvbGRDaGlsZDogRG9tRWxlbWVudCkge1xuICAgIGlmICghKG9sZENoaWxkIGluc3RhbmNlb2YgRG9tRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgYSBEb21FbGVtZW50cyBjaGlsZCBjYW4gYmUgcmVtb3ZlZFwiKVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZChvbGRDaGlsZC5lbGVtZW50KVxuICB9XG5cbiAgcHVibGljIGZpbmQoc2VsZWN0b3JzOiBzdHJpbmcpIHtcbiAgICBsZXQgZSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9ycylcbiAgICBpZiAoZSkge1xuICAgICAgcmV0dXJuIG5ldyBEb21FbGVtZW50KGUgYXMgRWxlbWVudClcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBwdWJsaWMgd3JhcFdpdGhFbGVtZW50KHdyYXBwZXJFbGVtZW50OiBEb21FbGVtZW50KSB7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCBpcyBub3QgYXR0YWNoZWRcIilcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHdyYXBwZXJFbGVtZW50LmVsZW1lbnQsIHRoaXMuZWxlbWVudClcbiAgICB3cmFwcGVyRWxlbWVudC5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgZGlzcGF0Y2hFdmVudChldmVudE5hbWU6IHN0cmluZykge1xuICAgIGxldCBldmVudFxuICAgIGxldCBlbCA9IHRoaXMuZWxlbWVudFxuXG4gICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKVxuICAgICAgZXZlbnQuaW5pdEV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgdHJ1ZSlcbiAgICB9IGVsc2UgaWYgKChkb2N1bWVudCBhcyBhbnkpLmNyZWF0ZUV2ZW50T2JqZWN0KSB7IC8vIElFIDwgOVxuICAgICAgZXZlbnQgPSAoZG9jdW1lbnQgYXMgYW55KS5jcmVhdGVFdmVudE9iamVjdCgpXG4gICAgICBldmVudC5ldmVudFR5cGUgPSBldmVudE5hbWVcbiAgICB9XG4gICAgZXZlbnQuZXZlbnROYW1lID0gZXZlbnROYW1lXG4gICAgaWYgKGVsLmRpc3BhdGNoRXZlbnQpIHtcbiAgICAgIGVsLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gICAgfSBlbHNlIGlmICgoZWwgYXMgYW55KS5maXJlRXZlbnQgJiYgaHRtbEV2ZW50c1tgb24ke2V2ZW50TmFtZX1gXSkgeyAvLyBJRSA8IDlcbiAgICAgIChlbCBhcyBhbnkpLmZpcmVFdmVudChgb24ke2V2ZW50LmV2ZW50VHlwZX1gLCBldmVudCkgLy8gY2FuIHRyaWdnZXIgb25seSByZWFsIGV2ZW50IChlLmcuICdjbGljaycpXG4gICAgfSBlbHNlIGlmIChlbFtldmVudE5hbWUgYXMga2V5b2YgRWxlbWVudF0pIHtcbiAgICAgIChlbCBhcyBhbnkpW2V2ZW50TmFtZV0oKVxuICAgIH0gZWxzZSBpZiAoZWxbYG9uJHtldmVudE5hbWV9YCBhcyBrZXlvZiBFbGVtZW50XSkge1xuICAgICAgKGVsIGFzIGFueSlbYG9uJHtldmVudE5hbWV9YF0oKVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjc3MocHJvcGVydHk6IHN0cmluZykge1xuICAgIHJldHVybiBEb20uY3NzKHRoaXMuZWxlbWVudCwgcHJvcGVydHkpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgY2hpbGQgbm9kZXMgb2YgdGhlIGN1cnJlbnQgRG9tRWxlbWVudC5cbiAgICovXG4gIHB1YmxpYyBlbXB0eSgpIHtcbiAgICBEb20uZW1wdHkodGhpcy5lbGVtZW50KVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERvbUVsZW1lbnRcbiIsIlxuZXhwb3J0IGZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQ6IEVsZW1lbnQsIG5hbWU6IHN0cmluZykge1xuICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzdHJpbmcgY2xhc3MgbmFtZVwiKVxuICB9XG5cbiAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50OiBFbGVtZW50LCBuYW1lOiBzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIGNsYXNzIG5hbWVcIilcbiAgfVxuXG4gIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShuYW1lKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudDogRWxlbWVudCwgbmFtZTogc3RyaW5nKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHN0cmluZyBjbGFzcyBuYW1lXCIpXG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW1lbnQ6IEVsZW1lbnQsIG5hbWU6IHN0cmluZykge1xuICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzdHJpbmcgY2xhc3MgbmFtZVwiKVxuICB9XG5cbiAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKG5hbWUpXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBoaWRkZW4gZnJvbSB2aWV3LlxuICogQHBhcmFtIHtFbGVtZW50fSBFbGVtZW50IFRoZSBkb20gZWxlbWVudCB0byBjaGVjay5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZVBhcmVudHMgSWYgc2V0IHRvIGB0cnVlYCBzZWFyY2hlcyB1cCB0aGUgRE9NIGFuZCBjaGVja3MgcGFyZW50IHZpc2liaWxpdHkgYXMgd2VsbC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSGlkZGVuKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBpbmNsdWRlUGFyZW50cyA9IGZhbHNlKTogYm9vbGVhbiB7XG4gIGlmIChpbmNsdWRlUGFyZW50cyA9PT0gZmFsc2UpIHtcbiAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpXG4gICAgcmV0dXJuIChzdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIikgfHwgZWxlbWVudC5vZmZzZXRMZWZ0IDwgMFxuICB9XG5cbiAgbGV0IHJlc3VsdFxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uZGl0aW9uYWwtYXNzaWdubWVudFxuICB3aGlsZSAoKHJlc3VsdCA9IGlzSGlkZGVuKGVsZW1lbnQsIGZhbHNlKSkgPT09IGZhbHNlICYmIGVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnRcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB0ZXh0IG9mIGFuIGVsZW1lbnQgYW4gbWFrZXMgc3VyZSB0aGlzIHdvcmtzIG9uIGFsbCBicm93c2Vycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHQoZWxlbWVudDogRWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC50ZXh0Q29udGVudCB8fCAoZWxlbWVudCBhcyBIVE1MRWxlbWVudCkuaW5uZXJUZXh0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJlbnRXaXRoQ2xhc3M8RSBleHRlbmRzIEVsZW1lbnQgPSBFbGVtZW50PihlbGVtZW50OiBFLCBjbGFzc05hbWU6IHN0cmluZyk6IEUgfCB1bmRlZmluZWQge1xuICBsZXQgY3VycmVudDogRSA9IGVsZW1lbnRcblxuICB3aGlsZSAoIWhhc0NsYXNzKGN1cnJlbnQsIGNsYXNzTmFtZSkgJiYgY3VycmVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50RWxlbWVudCBhcyBFbGVtZW50IGFzIEVcbiAgfVxuXG4gIGlmIChoYXNDbGFzcyhjdXJyZW50LCBjbGFzc05hbWUpKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRleHRXaWR0aCh0ZXh0OiBzdHJpbmcsIGZvbnQ6IHN0cmluZykge1xuICAvLyBOT1RFOiB0aGlzIHdpZHRoIG1lYXN1cmluZyBhbGdvcml0aG0gaXMgYSBsb3QgZmFzdGVyXG4gIC8vIGJ1dCBkb2VzIHVuZm9ydHVuYXRlbHkgbm90IHdvcmsgb24gSUUgMTAuLi5cblxuICAvLyBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKVxuICAvLyBsZXQgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIilcbiAgLy8gY29udGV4dC5mb250ID0gZm9udFxuICAvLyBsZXQgbWV0cmljcyA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dClcbiAgLy8gcmV0dXJuIE1hdGgucm91bmQobWV0cmljcy53aWR0aClcblxuICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICBkaXYuaW5uZXJIVE1MID0gdGV4dFxuXG4gIGRpdi5zdHlsZS5mb250ID0gZm9udFxuICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCJcbiAgZGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiXG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpXG5cbiAgY29uc3QgcmVzdWx0ID0gZGl2Lm9mZnNldFdpZHRoXG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNzcyhlbGVtZW50OiBFbGVtZW50LCBwcm9wZXJ0eTogc3RyaW5nKSB7XG4gIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KVxufVxuXG4vKipcbiAqIEdldHMgdGhlIHNpbmdsZSBlbGVtZW50IHJlZmVyZW5jZWQgaW4gYW4gaXRlbXMgZGF0YS0qIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7RG9tRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHJlZmVyZW5jZSBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIC0gVGhlIG5hbWUgb2YgdGhlIHJlZmVyZW5jZSBhdHRyaWJ1dGUuXG4gKiBAcmV0dXJucyB7RG9tRWxlbWVudH0gVGhlIHJlZmVyZW5jZWQgZWxlbWVudDsgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHJlZmVyZW5jZSBpcyBpbnZhbGlkXG4gKiBvciB0aGUgYXR0cmlidXRlIGNvdWxkIG5vdCBiZSBmb3VuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZVJlZmVyZW5jZTxJIGV4dGVuZHMgRWxlbWVudCA9IEVsZW1lbnQsIE8gZXh0ZW5kcyBFbGVtZW50ID0gST4oZWxlbWVudDogSSwgYXR0cmlidXRlOiBzdHJpbmcpOiBPIHwgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGF0dHJWYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSlcblxuICBpZiAoIWF0dHJWYWx1ZSB8fCBhdHRyVmFsdWUgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhdHRyVmFsdWUpIGFzIEVsZW1lbnQgYXMgT1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRvY3VtZW50IHJvb3QgZWxlbWVudCAobm9ybWFsbHkgdGhlIGJvZHkgZWxlbWVudClcbiAqIElmIHRoZSBkb2N1bWVudCB1c2VzIGEgc2R4LWNvbnRhaW5lciB3cmFwcGVyIHRoaXMgaXMgcmV0dXJuZWQgaW5zdGVhZC5cbiAqIEByZXR1cm5zIHtFbGVtZW50fSBUaGUgcm9vdCBkb20gZWxlbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJvb3RFbGVtZW50KCkge1xuICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuc2R4LWNvbnRhaW5lclwiKVxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQuYm9keVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBjaGlsZCBub2RlcyBmcm9tIHRoZSBwcm92aWRlZCBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBEb20gZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoZWxlbWVudDogRWxlbWVudCkge1xuICB3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgZWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50LmZpcnN0Q2hpbGQpXG4gIH1cbn1cbiIsIi8qIEtleWJvYXJkIGlucHV0IGtleWNvZGUgZGVmaW5pdGlvbnMgKi9cblxuZXhwb3J0IGNvbnN0IEtFWV9UQUIgPSA5XG5leHBvcnQgY29uc3QgS0VZX0VOVEVSID0gMTNcbmV4cG9ydCBjb25zdCBLRVlfRVNDQVBFID0gMjdcblxuLy8gQXJyb3cga2V5c1xuZXhwb3J0IGNvbnN0IEtFWV9BUlJPV19VUCA9IDM4XG5leHBvcnQgY29uc3QgS0VZX0FSUk9XX0RPV04gPSA0MFxuZXhwb3J0IGNvbnN0IEtFWV9BUlJPV19MRUZUID0gMzdcbmV4cG9ydCBjb25zdCBLRVlfQVJST1dfUklHSFQgPSAzOVxuXG4vLyBQYWdlIGtleXNcbmV4cG9ydCBjb25zdCBLRVlfUEFHRV9VUCA9IDMzXG5leHBvcnQgY29uc3QgS0VZX1BBR0VfRE9XTiA9IDM0XG5cbi8vIE51bWJlcnNcbmV4cG9ydCBjb25zdCBLRVlfTlJfMCA9IDQ4XG5leHBvcnQgY29uc3QgS0VZX05SXzEgPSA0OVxuZXhwb3J0IGNvbnN0IEtFWV9OUl85ID0gNTdcblxuLy8gaGVscGVyIGZ1bmN0aW9uc1xuZXhwb3J0IGxldCBjb250YWluc0tleSA9IChrZXljb2RlOiBudW1iZXIsIGlucHV0c0tleXM6IG51bWJlcltdKSA9PiB7XG4gIGxldCBoYXNLZXkgPSBmYWxzZVxuICBpZiAoaW5wdXRzS2V5cyAmJiBpbnB1dHNLZXlzLmxlbmd0aCA+IDApIHtcbiAgICBbXS5mb3JFYWNoLmNhbGwoaW5wdXRzS2V5cywgKGlucHV0c0tleTogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAoa2V5Y29kZSA9PT0gaW5wdXRzS2V5KSB7XG4gICAgICAgIGhhc0tleSA9IHRydWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIHJldHVybiBoYXNLZXlcbn1cblxuZXhwb3J0IGxldCBnZXRLZXlWYWx1ZSA9IChrZXljb2RlOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBpZiAoa2V5Y29kZSA8IDQ4IHx8IGtleWNvZGUgPiAxMDUpIHtcbiAgICByZXR1cm4gXCJcIlxuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDk2IDw9IGtleWNvZGUgJiYga2V5Y29kZSA8PSAxMDUgPyBrZXljb2RlIC0gNDggOiBrZXljb2RlKS50b0xvd2VyQ2FzZSgpXG59XG4iLCIvKipcbiAqIENhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBkb2N1bWVudCBoYXMgYmVlbiBjb21wbGV0ZWx5IHBhcnNlZC5cbiAqIEBwYXJhbSB7Y2FsbGJhY2t9IHZhbHVlIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb25Eb2N1bWVudFJlYWR5KGNhbGxiYWNrOiAoZT86IEV2ZW50KSA9PiB2b2lkKSB7XG4gIGZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQsIGZhbHNlKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlKVxuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrKVxuICB9IGVsc2Uge1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkLCBmYWxzZSlcblxuICAgIC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGNvbXBsZXRlZCwgZmFsc2UpXG4gIH1cbn1cblxuLyoqXG4gKiBTZWFyY2hlcyBmb3IgZWxlbWVudHMgd2l0aCB0aGUgZ2l2ZW4gc2VsZWN0b3IgYW5kIGNhbGxzIHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24gaWYgdGhlIGBkYXRhLWluaXRgIGF0dHJpYnV0ZSBpcyBwcmVzZW50IG9uIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHtzZWxlY3Rvcn0gdmFsdWUgVGhlIHF1ZXJ5LlxuICogQHBhcmFtIHtjYWxsYmFja30gdmFsdWUgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGluaXRpYWxpemUgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpbml0U2VsZWN0b3IgVGhlIGluaXRpdGFsaXphdGlvbiBlbGVtZW50IHNlbGVjdG9yIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoQW5kSW5pdGlhbGl6ZTxcbiAgSyBleHRlbmRzIGtleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcFxuICA+KFxuICAgIHNlbGVjdG9yOiBLLFxuICAgIGNhbGxiYWNrOiAoZWw6IEhUTUxFbGVtZW50VGFnTmFtZU1hcFtLXSkgPT4gdm9pZCxcbiAgICBpbml0U2VsZWN0b3I/OiAoZWw6IEhUTUxFbGVtZW50VGFnTmFtZU1hcFtLXSkgPT4gRWxlbWVudFxuICApOiB2b2lkXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoQW5kSW5pdGlhbGl6ZTxcbiAgRSBleHRlbmRzIEVsZW1lbnRcbiAgPihcbiAgICBzZWxlY3Rvcjogc3RyaW5nLFxuICAgIGNhbGxiYWNrOiAoZWw6IEUpID0+IHZvaWQsXG4gICAgaW5pdFNlbGVjdG9yPzogKGVsOiBFKSA9PiBFbGVtZW50XG4gICk6IHZvaWRcbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hBbmRJbml0aWFsaXplKFxuICBzZWxlY3Rvcjogc3RyaW5nLFxuICBjYWxsYmFjazogKGVsOiBFbGVtZW50KSA9PiB2b2lkLFxuICBpbml0U2VsZWN0b3I/OiAoZWw6IEVsZW1lbnQpID0+IEVsZW1lbnRcbik6IHZvaWQge1xuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNhbGxiYWNrIGNhbm5vdCBiZSB1bmRlZmluZWRcIilcbiAgfVxuXG4gIGxldCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpIGFzIE5vZGVMaXN0T2Y8RWxlbWVudD5cblxuICBmb3IgKGxldCBlIG9mIGVsZW1lbnRzKSB7XG5cbiAgICBsZXQgaW5pdEVsZW1lbnQ6IEVsZW1lbnQgPSBlXG5cbiAgICBpZiAoaW5pdFNlbGVjdG9yKSB7XG4gICAgICBpbml0RWxlbWVudCA9IGluaXRTZWxlY3RvcihlKVxuICAgIH1cblxuICAgIGlmIChpbml0RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWluaXRcIikgPT09IFwiYXV0b1wiKSB7XG4gICAgICBjYWxsYmFjayhlKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgd2hvc2UgdmFsdWUgaXMgbGltaXRlZCB0byB0aGUgZ2l2ZW4gcmFuZ2UuXG4gKlxuICogRXhhbXBsZTogbGltaXQgdGhlIG91dHB1dCBvZiB0aGlzIGNvbXB1dGF0aW9uIHRvIGJldHdlZW4gMCBhbmQgMjU1XG4gKiBVdGlscy5jbGFtcChudW1iZXIsIDAsIDI1NSlcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIG51bWJlciB0byBjbGFtcFxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbiBUaGUgbG93ZXIgYm91bmRhcnkgb2YgdGhlIG91dHB1dCByYW5nZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCBUaGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIG91dHB1dCByYW5nZVxuICogQHJldHVybnMgQSBudW1iZXIgaW4gdGhlIHJhbmdlIFttaW4sIG1heF1cbiAqIEB0eXBlIE51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhbXAodmFsdWU6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KVxufVxuXG4vKipcbiAqIEEgcG9seWZpbGwgZm9yIEV2ZW50LnByZXZlbnREZWZhdWx0KCkuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBwcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50OiBFdmVudCkge1xuICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH0gZWxzZSB7XG4gICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogQSBwb2x5ZmlsbCBmb3IgTm9kZS5yZW1vdmUoKS5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIHRvIHJlbW92ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShub2RlOiBOb2RlKSB7XG4gIGlmICghbm9kZSB8fCAhbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSlcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBwb2x5ZmlsbCBmb3IgdGhlIEFycmF5LmZpbmQoKSBtZXRob2QuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byBzZWFyY2ggaW4uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBleHByZXNzaW9uIC0gVGhlIGV4cHJlc3Npb24gdG8gZXZhbHVhdGUuIE11c3QgcmV0dXJuIHRydWUgaWYgdGhlIGVsZW1lbnQgbWF0Y2hlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmQ8VCA9IGFueT4oXG4gIGFycmF5OiBUW10gfCB7IGxlbmd0aDogbnVtYmVyLCBbaTogbnVtYmVyXTogVCB9LFxuICBleHByZXNzaW9uOiAoaXRlbTogVCkgPT4gYm9vbGVhblxuKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgaXRlbSA9IGFycmF5W2ldXG4gICAgaWYgKGV4cHJlc3Npb24oaXRlbSkgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBpdGVtXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIENoZWNrcyB0aGUgdXNlcmFnZW50IGFuZCByZXR1cm5zIHRoZSBNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXIgLyBFZGdlIHZlcnNpb24uXG4gKiBJZiBhbm90aGVyIGJyb3dzZXIgaXMgZGV0ZWN0ZWQgMCBpcyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVybmV0RXhwbG9yZXJPckVkZ2VWZXJzaW9uKHVzZXJBZ2VudDogc3RyaW5nID0gbmF2aWdhdG9yLnVzZXJBZ2VudCkge1xuICAvLyBoYW5kbGUgSUUgYW5kIEVkZ2VcbiAgY29uc3QgaWVPckVkZ2UgPSB1c2VyQWdlbnQuc2VhcmNoKC9NU0lFIHxFZGdlWy9dLylcbiAgaWYgKGllT3JFZGdlID4gMCkge1xuICAgIHJldHVybiBwYXJzZUludCh1c2VyQWdlbnQuc3Vic3RyaW5nKGllT3JFZGdlICsgNSwgdXNlckFnZW50LmluZGV4T2YoXCIuXCIsIGllT3JFZGdlKSksIDEwKVxuICB9XG4gIC8vIGhhbmRsZSBJRTExXG4gIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIlRyaWRlbnQvXCIpID4gMCkge1xuICAgIGNvbnN0IHJ2ID0gdXNlckFnZW50LmluZGV4T2YoXCJydjpcIilcbiAgICByZXR1cm4gcGFyc2VJbnQodXNlckFnZW50LnN1YnN0cmluZyhydiArIDMsIHVzZXJBZ2VudC5pbmRleE9mKFwiLlwiLCBydikpLCAxMClcbiAgfVxuXG4gIHJldHVybiAwXG59XG5cbi8qKlxuICogVHJpZXMgdG8gbW92ZSBhIGNoaWxkIGVsZW1lbnQgdG8gdGhlIHRvcCBieSBzY3JvbGxpbmcgdGhlIHBhcmVudCBlbGVtZW50LCBpZiBpdCBpcyBub3QgYWxyZWFkeSBmdWxseSB2aXNpYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoY2hpbGQ6IEhUTUxFbGVtZW50KSB7XG4gIGNvbnN0IHBhcmVudCA9IGNoaWxkLnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnRcbiAgY29uc3QgcGFyZW50UmVjdCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBjb25zdCBjaGlsZFJlY3QgPSBjaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBjb25zdCBpc0Z1bGx5VmlzaWJsZSA9IGNoaWxkUmVjdC50b3AgPj0gcGFyZW50UmVjdC50b3AgJiYgY2hpbGRSZWN0LmJvdHRvbSA8PSBwYXJlbnRSZWN0LnRvcCArIHBhcmVudC5jbGllbnRIZWlnaHRcblxuICBpZiAoIWlzRnVsbHlWaXNpYmxlKSB7XG4gICAgcGFyZW50LnNjcm9sbFRvcCA9IGNoaWxkUmVjdC50b3AgKyBwYXJlbnQuc2Nyb2xsVG9wIC0gcGFyZW50UmVjdC50b3BcbiAgfVxufVxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgYW5pbWUgZnJvbSBcImFuaW1lanNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0ICogYXMgRG9tIGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBRVUVSWV9UT0dHTEUgPSBcIi5hY2NvcmRpb25fX3RvZ2dsZVwiXG5jb25zdCBRVUVSWV9PUEVOX1NFQ1RJT04gPSBcIi5hY2NvcmRpb25fX2l0ZW0uaXMtb3BlblwiXG5jb25zdCBRVUVSWV9DT0xMQVBTRSA9IFwiLmFjY29yZGlvbl9fY29sbGFwc2VcIlxuXG5jb25zdCBDTEFTU19JVEVNID0gXCJhY2NvcmRpb25fX2l0ZW1cIlxuY29uc3QgQ0xBU1NfT1BFTiA9IFwiaXMtb3BlblwiXG5jb25zdCBDTEFTU19LRUVQX09QRU4gPSBcImFjY29yZGlvbl9fa2VlcC1vcGVuXCJcblxuY29uc3QgUkVHRVhfSElEREVOID0gL2FjY29yZGlvbi0taGlkZGVuLS4qL1xuXG5jb25zdCBBTklNQVRJT05fT1BFTiA9IDMwMFxuXG4vKipcbiAqIFRoZSBBY2NvcmRpb24gY29tcG9uZW50XG4gKi9cbmNsYXNzIEFjY29yZGlvbiBleHRlbmRzIERvbUVsZW1lbnQge1xuICBwcml2YXRlIF9zZWN0aW9uQ2xpY2tIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfaGlkZGVuSW5kaWNhdG9yITogSFRNTElucHV0RWxlbWVudFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyB0aGUgQWNjb3JkaW9uIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtEb21FbGVtZW50fSAtIFRoZSByb290IGVsZW1lbnQgb2YgdGhlIEFjY29yZGlvbiBjb21wb25lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX3NlY3Rpb25DbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVTZWN0aW9uQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBBY2NvcmRpb24gY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5zb21lKChjKSA9PiBSRUdFWF9ISURERU4udGVzdChjKSkpIHtcbiAgICAgIGxldCBpbmRpY2F0b3IgPSBuZXcgRG9tRWxlbWVudDxIVE1MSW5wdXRFbGVtZW50PihcImlucHV0XCIpXG4gICAgICAgIC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiaGlkZGVuXCIpXG4gICAgICAgIC5hZGRDbGFzcyhcImpzLWhpZGRlblwiKVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGluZGljYXRvcilcbiAgICAgIHRoaXMuX2hpZGRlbkluZGljYXRvciA9IGluZGljYXRvci5lbGVtZW50XG4gICAgfVxuXG4gICAgZm9yIChsZXQgdG9nZ2xlIG9mIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX1RPR0dMRSkpIHtcbiAgICAgIHRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fc2VjdGlvbkNsaWNrSGFuZGxlcilcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVNlY3Rpb25DbGljayhldmVudDogRXZlbnQpIHtcbiAgICBpZiAodGhpcy5faGlkZGVuSW5kaWNhdG9yKSB7XG4gICAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9oaWRkZW5JbmRpY2F0b3IpXG5cbiAgICAgIGlmIChzdHlsZS52aXNpYmlsaXR5ICE9PSBcInZpc2libGVcIikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbmF2U2VjdGlvbiA9IChldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLnBhcmVudEVsZW1lbnQhXG5cbiAgICB3aGlsZSAoIURvbS5oYXNDbGFzcyhuYXZTZWN0aW9uLCBDTEFTU19JVEVNKSAmJiBuYXZTZWN0aW9uLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIG5hdlNlY3Rpb24gPSBuYXZTZWN0aW9uLnBhcmVudEVsZW1lbnRcbiAgICB9XG5cbiAgICBsZXQgcHJldlNlY3Rpb24gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9PUEVOX1NFQ1RJT04pXG5cbiAgICBpZiAocHJldlNlY3Rpb24gJiYgcHJldlNlY3Rpb24gIT09IG5hdlNlY3Rpb24pIHtcbiAgICAgIGlmICghRG9tLmhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfS0VFUF9PUEVOKSl7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVNlY3Rpb24ocHJldlNlY3Rpb24pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fdG9nZ2xlU2VjdGlvbihuYXZTZWN0aW9uKVxuICB9XG5cbiAgcHJvdGVjdGVkIF90b2dnbGVTZWN0aW9uKGFjY1NlY3Rpb246IEVsZW1lbnQpIHtcbiAgICBsZXQgY29sbGFwc2VFbGVtZW50ID0gYWNjU2VjdGlvbi5xdWVyeVNlbGVjdG9yKFFVRVJZX0NPTExBUFNFKSEgYXMgSFRNTEVsZW1lbnRcblxuICAgIGlmIChEb20uaGFzQ2xhc3MoYWNjU2VjdGlvbiwgQ0xBU1NfT1BFTikpIHtcbiAgICAgIERvbS5yZW1vdmVDbGFzcyhhY2NTZWN0aW9uLCBDTEFTU19PUEVOKVxuICAgICAgdGhpcy5fY2xvc2VDb2xsYXBzZVNlY3Rpb24oY29sbGFwc2VFbGVtZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBEb20uYWRkQ2xhc3MoYWNjU2VjdGlvbiwgQ0xBU1NfT1BFTilcbiAgICAgIGlmIChjb2xsYXBzZUVsZW1lbnQpIHsgLy8gdG8gaWdub3JlIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgbm8gY29sbGFwc2libGUgZWxlbWVudCAoc2VlIHNkeCBkb2t1IG5hdmlnYXRpb24sIFwiYWxsIHRoZSBiYXNpY3NcIikgaW4gYSBsaXN0IG9mIGFjY29yZGlvblxuICAgICAgICB0aGlzLl9vcGVuQ29sbGFwc2VTZWN0aW9uKGNvbGxhcHNlRWxlbWVudClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX29wZW5Db2xsYXBzZVNlY3Rpb24oZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgZWwuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuXG4gICAgYW5pbWUoe1xuICAgICAgdGFyZ2V0czogZWwsXG4gICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX09QRU4sXG4gICAgICBoZWlnaHQ6IGVsLnNjcm9sbEhlaWdodCxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBlYXNpbmc6IFwiY3ViaWNCZXppZXIoMC41NTAsIDAuMDg1LCAwLjMyMCwgMSlcIixcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJ0cnVlXCIpXG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoQ0xBU1NfT1BFTilcbiAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCIgLy8gYWxsb3cgdG8gZ3JvdyBvciBzaHJpbmsgd2l0aCBjb250ZW50XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xvc2VDb2xsYXBzZVNlY3Rpb24oZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgLy8gQ2FuJ3QgYW5pbWF0ZSBcImF1dG9cIiwgdGhlcmVmb3JlIHVwZGF0ZSB0byBjdXJyZW50IGhlaWdodFxuICAgIGVsLnN0eWxlLmhlaWdodCA9IGAke2VsLnNjcm9sbEhlaWdodH1weGBcblxuICAgIGFuaW1lKHtcbiAgICAgIHRhcmdldHM6IGVsLFxuICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9PUEVOLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpXG4gICAgICAgIGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKSAvLyByZW1vdmVzIGV4dHJhIHBhZGRpbmcgaW4gRm9vdGVyIGFmdGVyIG9wZW5pbmcgYW5kIGNsb3NpbmdcbiAgICAgICAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJoZWlnaHRcIikgLy8gU0RYLTY5MSBNaXNzaW5nIGl0ZW1zIGluIEZvb3RlciBhZnRlciByZXNpemluZ1xuICAgICAgICBlbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcIm9wYWNpdHlcIikgLy8gU0RYLTY5MSBNaXNzaW5nIGl0ZW1zIGluIEZvb3RlciBhZnRlciByZXNpemluZ1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX09QRU4pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyBhbmQgY2xlYXJzIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCB0b2dnbGUgb2YgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfVE9HR0xFKSkge1xuICAgICAgdG9nZ2xlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9zZWN0aW9uQ2xpY2tIYW5kbGVyKVxuICAgIH1cblxuICAgICh0aGlzIGFzIGFueSkuX3NlY3Rpb25DbGlja0hhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuZWxlbWVudCA9IG51bGxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5hY2NvcmRpb25cIiwgKGUpID0+IHtcbiAgICBuZXcgQWNjb3JkaW9uKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IEFjY29yZGlvblxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgY2xhbXAsIHByZXZlbnREZWZhdWx0LCByZW1vdmUgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0ICogYXMgSW5wdXRzIGZyb20gXCIuLi9JbnB1dHNcIlxuaW1wb3J0ICogYXMgRG9tIGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBRVUVSWV9TTElERVIgPSBcIi5jYXJvdXNlbF9fY29udGFpbmVyXCJcbmNvbnN0IFFVRVJZX1NMSURFX0FSRUEgPSBcIi5jYXJvdXNlbF9fc2xpZGVyXCJcbmNvbnN0IFFVRVJZX1dSQVBQRVIgPSBcIi5jYXJvdXNlbF9fc2xpZGVyLXdyYXBwZXJcIlxuXG5jb25zdCBRVUVSWV9QQUdJTkFUSU9OID0gXCIuY2Fyb3VzZWxfX3BhZ2luYXRpb25cIlxuXG5jb25zdCBDTEFTU19BQ1RJVkUgPSBcInNsaWRlLS1hY3RpdmVcIlxuY29uc3QgQ0xBU1NfUFJFViA9IFwic2xpZGUtLXByZXZcIlxuY29uc3QgQ0xBU1NfTkVYVCA9IFwic2xpZGUtLW5leHRcIlxuXG5jb25zdCBDTEFTU19CVUxMRVQgPSBcInBhZ2luYXRpb24tYnVsbGV0XCJcbmNvbnN0IENMQVNTX0JVTExFVF9BQ1RJVkUgPSBcInBhZ2luYXRpb24tYnVsbGV0LS1hY3RpdmVcIlxuXG5jb25zdCBRVUVSWV9CVE5fUFJFViA9IFwiLmNhcm91c2VsX19idXR0b24tcHJldlwiXG5jb25zdCBRVUVSWV9CVE5fTkVYVCA9IFwiLmNhcm91c2VsX19idXR0b24tbmV4dFwiXG5jb25zdCBRVUVSWV9CVE5fV1JBUFBFUiA9IFwiLmNhcm91c2VsX19idXR0b24td3JhcHBlclwiXG5cbmNvbnN0IEFUVFJJQlVURV9JTkRFWCA9IFwianMtaW5kZXhcIlxuXG5jb25zdCBBTklNQVRJT05fRFVSQVRJT04gPSAzNTBcbmNvbnN0IEFOSU1BVElPTl9FQVNJTkcgPSBcImVhc2UtaW4tb3V0XCJcblxuY29uc3QgVE9VQ0hfRFVSQVRJT04gPSAzMDBcbmNvbnN0IFRPVUNIX0RFTFRBX01JTiA9IDI1XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVQcm9wZXJ0aWVzIHtcbiAgcmlnaHQ6IG51bWJlclxuICBsZWZ0OiBudW1iZXJcbiAgdmlzaWJsZTogYm9vbGVhblxuICBpbmRleDogbnVtYmVyXG4gIHdpZHRoOiBudW1iZXJcbiAgbWFyZ2luTGVmdDogbnVtYmVyXG4gIG1hcmdpblJpZ2h0OiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgRGlyZWN0aW9uID0gMCB8IC0xIHwgMVxuXG4vKipcbiAqIFRoZSBjYXJvdXNlbCBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xuY2xhc3MgQ2Fyb3VzZWwgZXh0ZW5kcyBEb21FbGVtZW50PEhUTUxFbGVtZW50PiB7XG4gIHByaXZhdGUgX3NsaWRlcjogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfd3JhcHBlcjogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfcGFnaW5hdGlvbj86IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX3NsaWRlQXJlYTogSFRNTEVsZW1lbnRcblxuICBwcml2YXRlIF9idG5XcmFwcGVyOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9wcmV2Q3RybDogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfbmV4dEN0cmw6IEhUTUxFbGVtZW50XG5cbiAgcHJpdmF0ZSBfc2xpZGVzOiBIVE1MRWxlbWVudFtdXG5cbiAgcHJpdmF0ZSBfaW5kZXg6IG51bWJlclxuICBwcml2YXRlIF9zbGlkZXNQZXJHcm91cDogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfc2xpZGVyV3JhcHBlcjogU2xpZGVyV3JhcHBlclxuXG4gIHByaXZhdGUgX2FkZGl0aW9uYWxTbGlkZU1hcmdpbjogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfcmVzaXplSGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9wcmV2SGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9uZXh0SGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9wYWdpbmF0aW9uQ2xpY2tIYW5kbGVyOiAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfa2V5ZG93bkhhbmRsZXI6IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX2hhbmRsZVRvdWNoc3RhcnQ6IChldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfaGFuZGxlVG91Y2htb3ZlOiAoZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2hhbmRsZVRvdWNoZW5kOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfYnJlYWtwb2ludFBob25lITogSFRNTERpdkVsZW1lbnRcbiAgcHJpdmF0ZSBfYnJlYWtwb2ludFRhYmxldCE6IEhUTUxEaXZFbGVtZW50XG4gIHByaXZhdGUgX2JyZWFrcG9pbnREZXNrdG9wITogSFRNTERpdkVsZW1lbnRcblxuICBwcml2YXRlIF90b3VjaE9mZnNldD86IHtcbiAgICB4OiBudW1iZXI7XG4gICAgdGltZTogbnVtYmVyO1xuICB9XG5cbiAgcHJpdmF0ZSBfZGVsdGE/OiB7XG4gICAgeDogbnVtYmVyO1xuICAgIGxhc3RNb3ZlOiBudW1iZXI7XG4gIH1cblxuICBwcml2YXRlIF9mcmFtZVdpZHRoPzogbnVtYmVyXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBjYXJvdXNlbCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gZWxlbWVudCAtIFRoZSByb290IGVsZW1lbnQgb2YgdGhlIENhcm91c2VsIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluaXRpYWwgaW5kZXguXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MRWxlbWVudCwgaW5kZXggPSAwKSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX3NsaWRlciA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX1NMSURFUikhIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fd3JhcHBlciA9IHRoaXMuX3NsaWRlci5xdWVyeVNlbGVjdG9yKFFVRVJZX1dSQVBQRVIpISBhcyBIVE1MRWxlbWVudFxuICAgIHRoaXMuX3BhZ2luYXRpb24gPSB0aGlzLl9zbGlkZXIucXVlcnlTZWxlY3RvcihRVUVSWV9QQUdJTkFUSU9OKSBhcyBIVE1MRWxlbWVudFxuICAgIHRoaXMuX3NsaWRlQXJlYSA9IHRoaXMuX3NsaWRlci5xdWVyeVNlbGVjdG9yKFFVRVJZX1NMSURFX0FSRUEpISBhcyBIVE1MRWxlbWVudFxuXG4gICAgdGhpcy5fYnRuV3JhcHBlciA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0JUTl9XUkFQUEVSKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl9wcmV2Q3RybCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0JUTl9QUkVWKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl9uZXh0Q3RybCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0JUTl9ORVhUKSEgYXMgSFRNTEVsZW1lbnRcblxuICAgIHRoaXMuX3NsaWRlcyA9IFtdXG5cbiAgICB0aGlzLl9pbmRleCA9IGluZGV4IHx8IDBcbiAgICB0aGlzLl9zbGlkZXNQZXJHcm91cCA9IDFcblxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIgPSBuZXcgU2xpZGVyV3JhcHBlcih0aGlzLl93cmFwcGVyLCB0aGlzLl9zbGlkZUFyZWEsIHRoaXMuZWxlbWVudClcbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4ID0gdGhpcy5faW5kZXhcbiAgICB0aGlzLl9hZGRpdGlvbmFsU2xpZGVNYXJnaW4gPSAwXG5cbiAgICB0aGlzLl9yZXNpemVIYW5kbGVyID0gdGhpcy5fb25yZXNpemUuYmluZCh0aGlzKVxuICAgIHRoaXMuX3ByZXZIYW5kbGVyID0gdGhpcy5wcmV2LmJpbmQodGhpcylcbiAgICB0aGlzLl9uZXh0SGFuZGxlciA9IHRoaXMubmV4dC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcGFnaW5hdGlvbkNsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZVBhZ2luYXRpb25DbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fa2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQgPSB0aGlzLl9vblRvdWNoc3RhcnQuYmluZCh0aGlzKVxuICAgIHRoaXMuX2hhbmRsZVRvdWNobW92ZSA9IHRoaXMuX29uVG91Y2htb3ZlLmJpbmQodGhpcylcbiAgICB0aGlzLl9oYW5kbGVUb3VjaGVuZCA9IHRoaXMuX29uVG91Y2hlbmQuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gICAgdGhpcy5zbGlkZSh0aGlzLl9pbmRleCwgMCwgZmFsc2UpXG5cbiAgICB0aGlzLl91cGRhdGVDdHJsT2Zmc2V0cygpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNhcm91c2VsIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICAvLyByZXNwb25zaXZlIGhlbHBlcnNcbiAgICB0aGlzLl9icmVha3BvaW50UGhvbmUgPSBuZXcgRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD4oXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhcImpzLXBob25lXCIpXG4gICAgICAuZWxlbWVudFxuXG4gICAgdGhpcy5fYnJlYWtwb2ludFRhYmxldCA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKFwianMtdGFibGV0XCIpXG4gICAgICAuZWxlbWVudFxuXG4gICAgdGhpcy5fYnJlYWtwb2ludERlc2t0b3AgPSBuZXcgRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD4oXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhcImpzLWRlc2t0b3BcIilcbiAgICAgIC5lbGVtZW50XG5cbiAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fYnJlYWtwb2ludFBob25lKVxuICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9icmVha3BvaW50VGFibGV0KVxuICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9icmVha3BvaW50RGVza3RvcClcblxuICAgIGlmICh0aGlzLl9wcmV2Q3RybCAmJiB0aGlzLl9uZXh0Q3RybCkge1xuICAgICAgdGhpcy5fcHJldkN0cmwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3ByZXZIYW5kbGVyKVxuICAgICAgdGhpcy5fbmV4dEN0cmwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX25leHRIYW5kbGVyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYWdpbmF0aW9uKSB7XG4gICAgICB0aGlzLl9wYWdpbmF0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9wYWdpbmF0aW9uQ2xpY2tIYW5kbGVyKVxuICAgIH1cblxuICAgIHRoaXMuX3NsaWRlcyA9IEFycmF5LmZyb20odGhpcy5fd3JhcHBlci5jaGlsZHJlbikgYXMgSFRNTEVsZW1lbnRbXVxuICAgIGlmICh0aGlzLl9zbGlkZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIlByb3ZpZGUgYXQgbGVhc3Qgb25lIHNsaWRlIHRvIHRoZSBzbGlkZXJcIilcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3NsaWRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHNsaWRlID0gdGhpcy5fc2xpZGVzW2ldXG4gICAgICBzbGlkZS5zZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0lOREVYLCBTdHJpbmcoaSkpXG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlUmVzcG9uc2l2ZU9wdGlvbnMoKVxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIuaW5pdGlhbGl6ZSgpXG5cbiAgICB0aGlzLnJlc2V0KClcblxuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcblxuICAgIHRoaXMuX3NsaWRlQXJlYS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQpXG4gICAgdGhpcy5fc2xpZGVBcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQpXG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgfVxuXG4gIHByb3RlY3RlZCBfaXNCcmVha3BvaW50QWN0aXZlKGJyZWFrcG9pbnQ6IEhUTUxEaXZFbGVtZW50KSB7XG4gICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoYnJlYWtwb2ludClcbiAgICByZXR1cm4gc3R5bGUudmlzaWJpbGl0eSA9PT0gXCJ2aXNpYmxlXCJcbiAgfVxuXG4gIHByb3RlY3RlZCBfb25yZXNpemUoKSB7XG4gICAgdGhpcy5yZXNldCgpXG4gICAgdGhpcy5fdXBkYXRlQ3RybE9mZnNldHMoKVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIHN1cmUgdGhlIGluZGV4IGlzIGFsd2F5cyBpbiB0aGUgcmFuZ2Ugb2YgYXZhaWxhYmxlIHNsaWRlXG4gICAqIEluIGNhc2UgaXQncyB0byBoaWdoIG9yIHRvIGxvdyBpdCBpcyB3cmFwcGVkIGFyb3VuZFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggdG8gYWRqdXN0IGFuZCBzYW5pdGl6ZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBpbmRleCAtIFRoZSBhZGp1c3RlZCBpbmRleFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9hZGp1c3RJbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgaW5kZXggPSAwXG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgaW5kZXggPSB0aGlzLl93cmFwcm91bmQoaW5kZXgsIDAsIHRoaXMuX3NsaWRlcy5sZW5ndGgpXG4gICAgfSBlbHNlIGlmIChpbmRleCA+PSB0aGlzLl9zbGlkZXMubGVuZ3RoKSB7XG4gICAgICBpbmRleCAlPSB0aGlzLl9zbGlkZXMubGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLl9zbGlkZXNQZXJHcm91cCkgKiB0aGlzLl9zbGlkZXNQZXJHcm91cFxuICB9XG5cbiAgcHJvdGVjdGVkIF93cmFwcm91bmQobjogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgICBpZiAobiA+PSBtYXgpIHtcbiAgICAgIHJldHVybiBtaW5cbiAgICB9XG5cbiAgICBpZiAobiA8IG1pbikge1xuICAgICAgcmV0dXJuIG1heCAtIDFcbiAgICB9XG5cbiAgICByZXR1cm4gblxuICB9XG5cbiAgcHJvdGVjdGVkIF93cmFwcm91bmRDb3VudChhOiBudW1iZXIsIGI6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBkaXJlY3Rpb246IERpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IDApIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgaWYgKGEgPCBtaW4gfHwgYSA+PSBtYXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgJ2EnIGlzIG91dCBvZiByYW5nZSwgVmFsdWU6ICR7YX0gTWluOiAke21pbn0sIE1heDogJHttYXh9YClcbiAgICB9XG5cbiAgICBpZiAoYiA8IG1pbiB8fCBiID49IG1heCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCAnYicgaXMgb3V0IG9mIHJhbmdlLCBWYWx1ZTogJHtifSBNaW46ICR7bWlufSwgTWF4OiAke21heH1gKVxuICAgIH1cblxuICAgIGxldCBpID0gMFxuICAgIHdoaWxlIChhICE9PSBiKSB7XG4gICAgICBpKytcbiAgICAgIGEgPSB0aGlzLl93cmFwcm91bmQoYSArIGRpcmVjdGlvbiwgbWluLCBtYXgpXG4gICAgfVxuXG4gICAgcmV0dXJuIGlcbiAgfVxuXG4gIHByb3RlY3RlZCBfdXBkYXRlQ3RybE9mZnNldHMoKSB7XG4gICAgaWYgKCF0aGlzLl9uZXh0Q3RybCB8fCAhdGhpcy5fcHJldkN0cmwgfHwgIXRoaXMuX2J0bldyYXBwZXIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBwcmV2Q3RybE1hcmdpbiA9IDBcbiAgICBsZXQgbmV4dEN0cmxNYXJnaW4gPSAwXG5cbiAgICBpZiAodGhpcy5fc2xpZGVzUGVyR3JvdXAgPiAxKSB7XG4gICAgICBsZXQgd3JhcHBlclJlY3QgPSB0aGlzLl9idG5XcmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICAgIGNvbnN0IHByZXZTbGlkZUNvdW50ID0gTWF0aC5mbG9vcigwLjUgKiB0aGlzLl9zbGlkZXNQZXJHcm91cClcbiAgICAgIGNvbnN0IHJpZ2h0SW5kZXggPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4ICsgcHJldlNsaWRlQ291bnQgKyAxXG5cbiAgICAgIGxldCBsZWZ0SW5kZXggPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4IC0gMVxuICAgICAgaWYgKHRoaXMuX3NsaWRlc1Blckdyb3VwICUgMiAhPT0gMCkge1xuICAgICAgICBsZWZ0SW5kZXggLT0gcHJldlNsaWRlQ291bnRcbiAgICAgIH1cblxuICAgICAgaWYgKChsZWZ0SW5kZXggPj0gMCAmJiBsZWZ0SW5kZXggPCB0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCkgJiZcbiAgICAgICAgKHJpZ2h0SW5kZXggPj0gMCAmJiByaWdodEluZGV4IDwgdGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGgpKSB7XG4gICAgICAgIGxldCBsZWZ0U2xpZGUgPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmdldFNsaWRlUHJvcGVydGllcyhsZWZ0SW5kZXgpXG4gICAgICAgIGxldCByaWdodFNsaWRlID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRTbGlkZVByb3BlcnRpZXMocmlnaHRJbmRleClcblxuICAgICAgICBsZXQgYnRuV2lkdGggPSB0aGlzLl9wcmV2Q3RybC5vZmZzZXRXaWR0aFxuICAgICAgICBpZiAoYnRuV2lkdGggPD0gMCkge1xuICAgICAgICAgIGJ0bldpZHRoID0gNjBcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZDdHJsTWFyZ2luID0gbGVmdFNsaWRlLnJpZ2h0IC0gd3JhcHBlclJlY3QubGVmdCAtIGJ0bldpZHRoXG4gICAgICAgIG5leHRDdHJsTWFyZ2luID0gd3JhcHBlclJlY3QucmlnaHQgLSByaWdodFNsaWRlLmxlZnQgLSBidG5XaWR0aFxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBsZWZ0ID0gcHJldkN0cmxNYXJnaW4gIT09IDAgPyBgJHtwcmV2Q3RybE1hcmdpbn1weGAgOiBcIlwiXG4gICAgdGhpcy5fcHJldkN0cmwuc3R5bGUubGVmdCA9IGxlZnRcblxuICAgIGxldCByaWdodCA9IG5leHRDdHJsTWFyZ2luICE9PSAwID8gYCR7bmV4dEN0cmxNYXJnaW59cHhgIDogXCJcIlxuICAgIHRoaXMuX25leHRDdHJsLnN0eWxlLnJpZ2h0ID0gcmlnaHRcbiAgfVxuXG4gIHByb3RlY3RlZCBfdXBkYXRlQWN0aXZlU2xpZGVzKG5leHRJbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3QgcHJldlNsaWRlQ291bnQgPSBNYXRoLmZsb29yKDAuNSAqICh0aGlzLl9zbGlkZXNQZXJHcm91cCAtIDEpKVxuICAgIGNvbnN0IGV2ZW5Hcm91cCA9IHRoaXMuX3NsaWRlc1Blckdyb3VwICUgMiA9PT0gMFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc2xpZGUgPSB0aGlzLl93cmFwcGVyLmNoaWxkcmVuW2ldXG5cbiAgICAgIGlmIChpID09PSBuZXh0SW5kZXggfHwgKGV2ZW5Hcm91cCAmJiBpID09PSBuZXh0SW5kZXggKyAxKSkge1xuICAgICAgICBEb20uYWRkQ2xhc3Moc2xpZGUsIENMQVNTX0FDVElWRSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhzbGlkZSwgQ0xBU1NfQUNUSVZFKVxuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IG5leHRJbmRleCAmJiBpID49IG5leHRJbmRleCAtIHByZXZTbGlkZUNvdW50KSB7XG4gICAgICAgIERvbS5hZGRDbGFzcyhzbGlkZSwgQ0xBU1NfUFJFVilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhzbGlkZSwgQ0xBU1NfUFJFVilcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPiBuZXh0SW5kZXggJiYgKGkgPD0gbmV4dEluZGV4ICsgcHJldlNsaWRlQ291bnQgfHwgKGV2ZW5Hcm91cCAmJiBpIDw9IG5leHRJbmRleCArIDEgKyBwcmV2U2xpZGVDb3VudCkpKSB7XG4gICAgICAgIERvbS5hZGRDbGFzcyhzbGlkZSwgQ0xBU1NfTkVYVClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhzbGlkZSwgQ0xBU1NfTkVYVClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBhbmQgY3JlYXRlcyB0aGUgcGFnaW5hdGlvbiBidWxsZXRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF91cGRhdGVQYWdpbmF0aW9uKCkge1xuICAgIGlmICghdGhpcy5fcGFnaW5hdGlvbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHRvID0gdGhpcy5faW5kZXhcblxuICAgIGxldCBidWxsZXRzID0gdGhpcy5fcGFnaW5hdGlvbi5jaGlsZHJlblxuICAgIGxldCB0b3RhbEl0ZW1zID0gTWF0aC5tYXgodGhpcy5fc2xpZGVzLmxlbmd0aCwgYnVsbGV0cy5sZW5ndGgpXG4gICAgbGV0IHNsaWRlQ291bnQgPSBNYXRoLmNlaWwodGhpcy5fc2xpZGVzLmxlbmd0aCAvIHRoaXMuX3NsaWRlc1Blckdyb3VwKVxuICAgIGxldCBhY3RpdmVTbGlkZUluZGV4ID0gTWF0aC5mbG9vcih0byAvIHRoaXMuX3NsaWRlc1Blckdyb3VwKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbEl0ZW1zOyBpKyspIHtcbiAgICAgIGxldCBidWxsZXRcblxuICAgICAgaWYgKGJ1bGxldHMubGVuZ3RoID4gaSkge1xuICAgICAgICBpZiAoYnVsbGV0cy5sZW5ndGggPD0gc2xpZGVDb3VudCkge1xuICAgICAgICAgIGJ1bGxldCA9IGJ1bGxldHNbaV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmUoYnVsbGV0c1tpXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpIDwgc2xpZGVDb3VudCkge1xuICAgICAgICBidWxsZXQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAgIC5hZGRDbGFzcyhDTEFTU19CVUxMRVQpXG4gICAgICAgICAgLmVsZW1lbnRcbiAgICAgICAgdGhpcy5fcGFnaW5hdGlvbi5hcHBlbmRDaGlsZChidWxsZXQpXG4gICAgICB9XG5cbiAgICAgIGlmIChidWxsZXQgJiYgaSA8IHNsaWRlQ291bnQpIHtcbiAgICAgICAgaWYgKGkgPT09IGFjdGl2ZVNsaWRlSW5kZXgpIHtcbiAgICAgICAgICBEb20uYWRkQ2xhc3MoYnVsbGV0LCBDTEFTU19CVUxMRVRfQUNUSVZFKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIERvbS5yZW1vdmVDbGFzcyhidWxsZXQsIENMQVNTX0JVTExFVF9BQ1RJVkUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVBhZ2luYXRpb25DbGljayhlOiBNb3VzZUV2ZW50KSB7XG4gICAgaWYgKCFEb20uaGFzQ2xhc3MoZS50YXJnZXQgYXMgRWxlbWVudCwgQ0xBU1NfQlVMTEVUKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGluZGV4ID0gQXJyYXkuZnJvbSh0aGlzLl9wYWdpbmF0aW9uIS5jaGlsZHJlbikuaW5kZXhPZihlLnRhcmdldCBhcyBFbGVtZW50KVxuICAgIGxldCBzbGlkZU51bWJlciA9IGluZGV4ICogdGhpcy5fc2xpZGVzUGVyR3JvdXBcblxuICAgIHRoaXMuc2xpZGVUbyhzbGlkZU51bWJlcilcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGxldCBrZXljb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZVxuXG4gICAgc3dpdGNoIChrZXljb2RlKSB7XG4gICAgICBjYXNlIElucHV0cy5LRVlfQVJST1dfTEVGVDpcbiAgICAgICAgdGhpcy5wcmV2KClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgSW5wdXRzLktFWV9BUlJPV19SSUdIVDpcbiAgICAgICAgdGhpcy5uZXh0KClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgSW5wdXRzLktFWV9FU0NBUEU6XG4gICAgICAgIHRoaXMuZWxlbWVudC5ibHVyKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9vblRvdWNoc3RhcnQoZXZlbnQ6IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50KSB7XG4gICAgY29uc3QgdG91Y2ggPSAoZXZlbnQgYXMgVG91Y2hFdmVudCkudG91Y2hlcyA/IChldmVudCBhcyBUb3VjaEV2ZW50KS50b3VjaGVzWzBdIDogZXZlbnQgYXMgTW91c2VFdmVudFxuXG4gICAgdGhpcy5fc2xpZGVBcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5faGFuZGxlVG91Y2hzdGFydClcbiAgICB0aGlzLl9zbGlkZUFyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5faGFuZGxlVG91Y2hzdGFydClcblxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIuYmVnaW5EcmFnKClcbiAgICBjb25zdCB7IHBhZ2VYIH0gPSB0b3VjaFxuXG4gICAgdGhpcy5fdG91Y2hPZmZzZXQgPSB7XG4gICAgICB4OiBwYWdlWCxcbiAgICAgIHRpbWU6IERhdGUubm93KClcbiAgICB9XG5cbiAgICB0aGlzLl9kZWx0YSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICBsYXN0TW92ZTogcGFnZVhcbiAgICB9XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX2hhbmRsZVRvdWNobW92ZSlcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX2hhbmRsZVRvdWNobW92ZSlcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX2hhbmRsZVRvdWNoZW5kKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMuX2hhbmRsZVRvdWNoZW5kKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl9oYW5kbGVUb3VjaGVuZClcbiAgfVxuXG4gIHByb3RlY3RlZCBfb25Ub3VjaG1vdmUoZXZlbnQ6IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50KSB7XG4gICAgY29uc3QgdG91Y2ggPSAoZXZlbnQgYXMgVG91Y2hFdmVudCkudG91Y2hlcyA/IChldmVudCBhcyBUb3VjaEV2ZW50KS50b3VjaGVzWzBdIDogZXZlbnQgYXMgTW91c2VFdmVudFxuICAgIGNvbnN0IHsgcGFnZVggfSA9IHRvdWNoXG5cbiAgICBsZXQgZGVsdGFNb3ZlID0gcGFnZVggLSB0aGlzLl9kZWx0YSEubGFzdE1vdmVcblxuICAgIHRoaXMuX2RlbHRhID0ge1xuICAgICAgeDogcGFnZVggLSB0aGlzLl90b3VjaE9mZnNldCEueCxcbiAgICAgIGxhc3RNb3ZlOiBwYWdlWFxuICAgIH1cblxuICAgIGlmICh0aGlzLl90b3VjaE9mZnNldCkge1xuICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG5cbiAgICAgIHRoaXMuX3NsaWRlcldyYXBwZXIubW92ZShkZWx0YU1vdmUpXG4gICAgICB0aGlzLl9jbG9uZVNsaWRlc1RvRml0V3JhcHBlcihmYWxzZSwgZGVsdGFNb3ZlKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfb25Ub3VjaGVuZCgpIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuX3RvdWNoT2Zmc2V0ID8gRGF0ZS5ub3coKSAtIHRoaXMuX3RvdWNoT2Zmc2V0LnRpbWUgOiB1bmRlZmluZWRcblxuICAgIGNvbnN0IGlzVmFsaWQgPSBOdW1iZXIoZHVyYXRpb24pIDwgVE9VQ0hfRFVSQVRJT04gJiZcbiAgICAgIE1hdGguYWJzKHRoaXMuX2RlbHRhIS54KSA+IFRPVUNIX0RFTFRBX01JTiB8fFxuICAgICAgTWF0aC5hYnModGhpcy5fZGVsdGEhLngpID4gdGhpcy5fZnJhbWVXaWR0aCEgLyAzXG5cbiAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gY2xhbXAodGhpcy5fZGVsdGEhLngsIC0xLCAxKSAqIC0xIGFzIERpcmVjdGlvblxuICAgICAgdGhpcy5zbGlkZShmYWxzZSwgZGlyZWN0aW9uLCB0cnVlKVxuXG4gICAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLmVuZERyYWcoKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbGlkZSBiYWNrIHRvIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgZHJhZyBvcGVyYXRpb25cbiAgICAgIHRoaXMuX3NsaWRlcldyYXBwZXIuY2FuY2VsRHJhZygpXG4gICAgfVxuXG4gICAgdGhpcy5fdG91Y2hPZmZzZXQgPSB1bmRlZmluZWRcblxuICAgIHRoaXMuX3NsaWRlQXJlYS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQpXG4gICAgdGhpcy5fc2xpZGVBcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQpXG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX2hhbmRsZVRvdWNobW92ZSlcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9oYW5kbGVUb3VjaGVuZClcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLl9oYW5kbGVUb3VjaGVuZClcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX2hhbmRsZVRvdWNobW92ZSlcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5faGFuZGxlVG91Y2hlbmQpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlZCBwYXJhbWV0ZXJzIGluIHJlZ2FyZCB0byB0aGUgY3VycmVudGx5IGFjdGl2ZSByZXNwb25zaXZlXG4gICAqIGJyZWFrcG9pbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX3VwZGF0ZVJlc3BvbnNpdmVPcHRpb25zKCkge1xuICAgIGlmICh0aGlzLl9pc0JyZWFrcG9pbnRBY3RpdmUodGhpcy5fYnJlYWtwb2ludFBob25lKSkge1xuICAgICAgdGhpcy5fc2xpZGVzUGVyR3JvdXAgPSAxXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzQnJlYWtwb2ludEFjdGl2ZSh0aGlzLl9icmVha3BvaW50VGFibGV0KSkge1xuICAgICAgdGhpcy5fc2xpZGVzUGVyR3JvdXAgPSAyXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzQnJlYWtwb2ludEFjdGl2ZSh0aGlzLl9icmVha3BvaW50RGVza3RvcCkpIHtcbiAgICAgIHRoaXMuX3NsaWRlc1Blckdyb3VwID0gM1xuICAgIH1cblxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIuc2xpZGVzUGVyR3JvdXAgPSB0aGlzLl9zbGlkZXNQZXJHcm91cFxuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgcmVxdWVzdGVkIHNsaWRlIGFuZCBhZGRzIGl0IHRvIHRoZSBzbGlkZXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBvcmlnaW5hbCBzbGlkZSBpbmRleCBvZiB0aGUgdGVtcGxhdGUgc2xpZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiAtIFRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdG8gYWRkIHRoZSBzbGlkZXMsIC0xIGZvciBsZWZ0LCAxIGZvciByaWdodFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9jbG9uZVNsaWRlKGluZGV4OiBudW1iZXIsIGRpcmVjdGlvbjogbnVtYmVyKSB7XG4gICAgbGV0IGNsb25lID0gdGhpcy5fc2xpZGVzW2luZGV4XS5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTEVsZW1lbnRcbiAgICBEb20ucmVtb3ZlQ2xhc3MoY2xvbmUsIENMQVNTX0FDVElWRSlcbiAgICBEb20ucmVtb3ZlQ2xhc3MoY2xvbmUsIENMQVNTX1BSRVYpXG4gICAgRG9tLnJlbW92ZUNsYXNzKGNsb25lLCBDTEFTU19ORVhUKVxuXG4gICAgdGhpcy5fc2xpZGVyV3JhcHBlci5hZGRTbGlkZShjbG9uZSwgZGlyZWN0aW9uKVxuXG4gICAgbGV0IHNsaWRlTWFyZ2luID0gdGhpcy5fYWRkaXRpb25hbFNsaWRlTWFyZ2luID4gMCA/IGAke3RoaXMuX2FkZGl0aW9uYWxTbGlkZU1hcmdpbn1weGAgOiBcIlwiXG4gICAgY2xvbmUuc3R5bGUubWFyZ2luTGVmdCA9IHNsaWRlTWFyZ2luXG4gICAgY2xvbmUuc3R5bGUubWFyZ2luUmlnaHQgPSBzbGlkZU1hcmdpblxuXG4gICAgcmV0dXJuIGNsb25lLm9mZnNldFdpZHRoXG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIGFuZCBhZGRzIHRoZSByZXF1ZXN0ZWQgYW1tb3VudCBvZiBzbGlkZXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzbGlkZUNvdW50IC0gVGhlIG51bWJlciBvZiBzbGlkZXMgdG8gYWRkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIGluIHdoaWNoIHRvIGFkZCB0aGUgc2xpZGVzLCAtMSBmb3IgbGVmdCwgMSBmb3IgcmlnaHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfY2xvbmVTbGlkZXNCeUNvdW50KHNsaWRlQ291bnQ6IG51bWJlciwgZGlyZWN0aW9uOiBEaXJlY3Rpb24pIHtcbiAgICBsZXQgb3JpZ2luYWxJbmRleCA9IGRpcmVjdGlvbiA8IDAgPyAwIDogdGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGggLSAxXG4gICAgbGV0IGluZGV4ID0gcGFyc2VJbnQodGhpcy5fd3JhcHBlci5jaGlsZHJlbltvcmlnaW5hbEluZGV4XS5nZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0lOREVYKSEsIDEwKVxuXG4gICAgd2hpbGUgKHNsaWRlQ291bnQgPiAwKSB7XG4gICAgICBpbmRleCA9IHRoaXMuX3dyYXByb3VuZChpbmRleCArIGRpcmVjdGlvbiwgMCwgdGhpcy5fc2xpZGVzLmxlbmd0aClcbiAgICAgIHRoaXMuX2Nsb25lU2xpZGUoaW5kZXgsIGRpcmVjdGlvbilcbiAgICAgIHNsaWRlQ291bnQtLVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBzY3JvbGwgY2xvdW50IGFuZCBpbnNlcnRzIHRoZSByZXF1aXJlZCBhbW1vdW50IG9mIHNsaWRlc1xuICAgKiBpbiB0aGUgYXByb3ByaWF0ZSBkaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuZXh0SW5kZXggLSBUaGUgc2xpZGUgdG8gc2Nyb2xsIHRvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIG9mIHRoZSBzY3JvbGxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfY2xvbmVTbGlkZXNCeVNjcm9sbENvdW50KG5leHRJbmRleDogbnVtYmVyLCBkaXJlY3Rpb246IERpcmVjdGlvbikge1xuICAgIGNvbnN0IHNjcm9sbENvdW50ID0gdGhpcy5fd3JhcHJvdW5kQ291bnQodGhpcy5faW5kZXgsIG5leHRJbmRleCwgMCwgdGhpcy5fc2xpZGVzLmxlbmd0aCwgZGlyZWN0aW9uKVxuXG4gICAgY29uc3Qgb3V0ZXJTbGlkZVByb3BzID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRTbGlkZVByb3BlcnRpZXMoZGlyZWN0aW9uID4gMCA/IHRoaXMuX3dyYXBwZXIuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDApXG4gICAgY29uc3QgaW5kZXhUb091dGVyU2xpZGVDb3VudCA9IHRoaXMuX3dyYXByb3VuZENvdW50KHRoaXMuX2luZGV4LCBvdXRlclNsaWRlUHJvcHMuaW5kZXgsIDAsIHRoaXMuX3NsaWRlcy5sZW5ndGgsIGRpcmVjdGlvbilcblxuICAgIGNvbnN0IHNsaWRlc1RvSW5zZXJ0ID0gc2Nyb2xsQ291bnQgLSBpbmRleFRvT3V0ZXJTbGlkZUNvdW50XG4gICAgaWYgKHNsaWRlc1RvSW5zZXJ0ID4gMCkge1xuICAgICAgdGhpcy5fY2xvbmVTbGlkZXNCeUNvdW50KHNsaWRlc1RvSW5zZXJ0LCBkaXJlY3Rpb24pXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jbG9uZVNsaWRlc0J5VG9GaWxsKHNwYWNlVG9GaWxsOiBudW1iZXIsIGRpcmVjdGlvbjogRGlyZWN0aW9uKSB7XG4gICAgbGV0IG9yaWdpbmFsSW5kZXggPSBkaXJlY3Rpb24gPCAwID8gMCA6IHRoaXMuX3dyYXBwZXIuY2hpbGRyZW4ubGVuZ3RoIC0gMVxuICAgIGxldCBpbmRleCA9IHBhcnNlSW50KHRoaXMuX3dyYXBwZXIuY2hpbGRyZW5bb3JpZ2luYWxJbmRleF0uZ2V0QXR0cmlidXRlKEFUVFJJQlVURV9JTkRFWCkhLCAxMClcblxuICAgIHdoaWxlIChzcGFjZVRvRmlsbCA+IDApIHtcbiAgICAgIGluZGV4ID0gdGhpcy5fd3JhcHJvdW5kKGluZGV4ICsgZGlyZWN0aW9uLCAwLCB0aGlzLl9zbGlkZXMubGVuZ3RoKVxuICAgICAgc3BhY2VUb0ZpbGwgLT0gdGhpcy5fY2xvbmVTbGlkZShpbmRleCwgZGlyZWN0aW9uKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xvbmVTbGlkZXNUb0ZpdFdyYXBwZXIoY2xlYW51cCA9IHRydWUsIHNsaWRlRGVsdGEgPSAwKSB7XG4gICAgY29uc3QgcmVhbEluZGV4ID0gdGhpcy5fc2xpZGVyV3JhcHBlci5pbmRleFxuICAgIGxldCBmaXJzdDogU2xpZGVQcm9wZXJ0aWVzXG4gICAgbGV0IGxhc3Q6IFNsaWRlUHJvcGVydGllc1xuXG4gICAgaWYgKGNsZWFudXAgPT09IGZhbHNlKSB7XG4gICAgICBmaXJzdCA9IHRoaXMuX3NsaWRlcldyYXBwZXIuZ2V0U2xpZGVQcm9wZXJ0aWVzKDApXG4gICAgICBsYXN0ID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRTbGlkZVByb3BlcnRpZXModGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGggLSAxKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRSZW1vdmFibGVTbGlkZXMoc2xpZGVEZWx0YSlcbiAgICAgIGZpcnN0ID0gcmVzdWx0LmZpcnN0IVxuICAgICAgbGFzdCA9IHJlc3VsdC5sYXN0IVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIHNsaWRlcyBmcm9tIHZpZXdcbiAgICAgIGZvciAobGV0IGkgPSByZXN1bHQuc2xpZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChyZXN1bHQuc2xpZGVzW2ldID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5fc2xpZGVyV3JhcHBlci5yZW1vdmVTbGlkZShpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHNwYWNlVG9GaWxsID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRFbXB0eVNwYWNlKGZpcnN0LmxlZnQsIGxhc3QucmlnaHQpXG5cbiAgICAvLyBDaGVjayBpZiBhZGRpdGlvbmFsIHNsaWRlcyBhcmUgcmVxdWlyZWQgb24gdGhlIGxlZnRcbiAgICBpZiAoZmlyc3QudmlzaWJsZSA9PT0gdHJ1ZSAmJiBzcGFjZVRvRmlsbC5sZWZ0ID4gMCkge1xuICAgICAgdGhpcy5fY2xvbmVTbGlkZXNCeVRvRmlsbChzcGFjZVRvRmlsbC5sZWZ0LCAtMSlcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhZGRpdGlvbmFsIHNsaWRlcyBhcmUgcmVxdWlyZWQgb24gdGhlIHJpZ2h0XG4gICAgaWYgKGxhc3QudmlzaWJsZSA9PT0gdHJ1ZSAmJiBzcGFjZVRvRmlsbC5yaWdodCA+IDApIHtcbiAgICAgIHRoaXMuX2Nsb25lU2xpZGVzQnlUb0ZpbGwoc3BhY2VUb0ZpbGwucmlnaHQsIDEpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlYWxJbmRleCAtIHRoaXMuX3NsaWRlcldyYXBwZXIuaW5kZXhcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZWFsICh3cmFwcGVyKSBpbmRleCBmb3IgdGhlIHNsaWRlIHdpdGggdGhlIGdpdmVuIG9yaWdpbmFsIGluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCB0byBzZWFyY2ggZm9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIGluIHdoaWNoIHRvIHNlYXJjaFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgd3JhcHBlciBpbmRleFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9nZXRSZWFsSW5kZXhGb3IoaW5kZXg6IG51bWJlciwgZGlyZWN0aW9uOiBEaXJlY3Rpb24pIHtcbiAgICBsZXQgaSA9IHRoaXMuX3NsaWRlcldyYXBwZXIuaW5kZXhcbiAgICB3aGlsZSAoaSA+PSAwICYmIGkgPCB0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgbGV0IHNsaWRlSW5kZXggPSBwYXJzZUludCh0aGlzLl93cmFwcGVyLmNoaWxkcmVuW2ldLmdldEF0dHJpYnV0ZShBVFRSSUJVVEVfSU5ERVgpISwgMTApXG4gICAgICBpZiAoc2xpZGVJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGlcbiAgICAgIH1cblxuICAgICAgaSArPSBkaXJlY3Rpb25cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENsb3VkIG5vdCBmaW5kIHJlYWwgaW5kZXggZm9yIHNsaWRlICR7aW5kZXh9IGluIGRpcmVjdGlvbiAke2RpcmVjdGlvbn1gKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGFjdGl2ZSBzbGlkZS4gSWYgdGhlIHNsaWRlcyBhcmUgZ3JvdXBlZCBldmVubHlcbiAgICogdGhlIGFjdGl2ZSBzbGlkZSBpcyBhbHdheXMgdGhlIGZpcnN0IGluIHRoZSBncm91cC5cbiAgICogQHJldHVybnMge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBhY3RpdmUgc2xpZGUuXG4gICAqL1xuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKSB7XG4gICAgdGhpcy5fZnJhbWVXaWR0aCA9IHRoaXMuX3NsaWRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgLndpZHRoIHx8IHRoaXMuX3NsaWRlci5vZmZzZXRXaWR0aFxuXG4gICAgdGhpcy5fdXBkYXRlUmVzcG9uc2l2ZU9wdGlvbnMoKVxuXG4gICAgaWYgKHRoaXMuX25leHRDdHJsKSB7XG4gICAgICAodGhpcy5fbmV4dEN0cmwgYXMgYW55KS5kaXNhYmxlZCA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3ByZXZDdHJsKSB7XG4gICAgICAodGhpcy5fcHJldkN0cmwgYXMgYW55KS5kaXNhYmxlZCA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NsaWRlc1Blckdyb3VwID09PSAxKSB7XG4gICAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9zbGlkZXIucGFyZW50RWxlbWVudCEpXG4gICAgICBsZXQgcGFyZW50V2lkdGggPSB0aGlzLl9zbGlkZXIucGFyZW50RWxlbWVudCEuY2xpZW50V2lkdGggKyAocGFyc2VGbG9hdChzdHlsZS5tYXJnaW5MZWZ0ISkgfHwgMCkgKyAocGFyc2VGbG9hdChzdHlsZS5tYXJnaW5SaWdodCEpIHx8IDApXG5cbiAgICAgIGxldCBvdXRlck1hcmdpbiA9IE1hdGguY2VpbChwYXJlbnRXaWR0aCAtIHRoaXMuX2ZyYW1lV2lkdGgpXG4gICAgICB0aGlzLl9hZGRpdGlvbmFsU2xpZGVNYXJnaW4gPSBNYXRoLmNlaWwob3V0ZXJNYXJnaW4gKiAwLjUpICsgMVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hZGRpdGlvbmFsU2xpZGVNYXJnaW4gPSAwXG4gICAgfVxuXG4gICAgbGV0IHNsaWRlTWFyZ2luID0gdGhpcy5fYWRkaXRpb25hbFNsaWRlTWFyZ2luID4gMCA/IGAke3RoaXMuX2FkZGl0aW9uYWxTbGlkZU1hcmdpbn1weGAgOiBcIlwiXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc2xpZGUgPSB0aGlzLl93cmFwcGVyLmNoaWxkcmVuW2ldIGFzIEhUTUxFbGVtZW50XG4gICAgICBzbGlkZS5zdHlsZS5tYXJnaW5MZWZ0ID0gc2xpZGVNYXJnaW5cbiAgICAgIHNsaWRlLnN0eWxlLm1hcmdpblJpZ2h0ID0gc2xpZGVNYXJnaW5cbiAgICB9XG5cbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLm9ucmVzaXplKClcbiAgICB0aGlzLl9jbG9uZVNsaWRlc1RvRml0V3JhcHBlcihmYWxzZSlcbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLm1vdmVUbyh0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4KVxuXG4gICAgdGhpcy5fdXBkYXRlUGFnaW5hdGlvbigpXG4gICAgdGhpcy5fdXBkYXRlQWN0aXZlU2xpZGVzKHRoaXMuX3NsaWRlcldyYXBwZXIuaW5kZXgpXG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIHNsaWRlciB0byB0aGUgbmV4dCBpdGVtLlxuICAgKi9cbiAgcHVibGljIHByZXYoKSB7XG4gICAgdGhpcy5zbGlkZShmYWxzZSwgLTEpXG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIHNsaWRlciB0byB0aGUgcHJldmlvdXMgaXRlbS5cbiAgICovXG4gIHB1YmxpYyBuZXh0KCkge1xuICAgIHRoaXMuc2xpZGUoZmFsc2UsIDEpXG4gIH1cblxuICBwdWJsaWMgc2xpZGUobmV4dEluZGV4OiBudW1iZXIgfCBmYWxzZSwgZGlyZWN0aW9uPzogRGlyZWN0aW9uLCBhbmltYXRlID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgbmV4dEluZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoZGlyZWN0aW9uISA+IDApIHtcbiAgICAgICAgbmV4dEluZGV4ID0gdGhpcy5faW5kZXggKyB0aGlzLl9zbGlkZXNQZXJHcm91cFxuICAgICAgICBkaXJlY3Rpb24gPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0SW5kZXggPSB0aGlzLl9pbmRleCAtIHRoaXMuX3NsaWRlc1Blckdyb3VwXG4gICAgICAgIGRpcmVjdGlvbiA9IC0xXG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV4dEluZGV4ID0gdGhpcy5fYWRqdXN0SW5kZXgobmV4dEluZGV4KVxuXG4gICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgIGRpcmVjdGlvbiA9IGNsYW1wKG5leHRJbmRleCAtIHRoaXMuX2luZGV4LCAtMSwgMSkgYXMgRGlyZWN0aW9uXG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZXJlIGFyZSBlbm91Z2h0IHNsaWRlcyBvbiBzY3JlZW5cbiAgICB0aGlzLl9jbG9uZVNsaWRlc1RvRml0V3JhcHBlcihmYWxzZSlcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBhcmUgZW5vdWdoIHNsaWRlcyBmb3IgdGhlIHNjcm9sbCBvcGVyYXRpb25cbiAgICB0aGlzLl9jbG9uZVNsaWRlc0J5U2Nyb2xsQ291bnQobmV4dEluZGV4LCBkaXJlY3Rpb24pXG5cbiAgICBsZXQgcmVhbEluZGV4ID0gdGhpcy5fZ2V0UmVhbEluZGV4Rm9yKG5leHRJbmRleCwgZGlyZWN0aW9uKVxuICAgIGxldCBzbGlkZURlbHRhID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRTbGlkZURlbHRhKHJlYWxJbmRleClcbiAgICByZWFsSW5kZXggPSBNYXRoLm1heChyZWFsSW5kZXggLSB0aGlzLl9jbG9uZVNsaWRlc1RvRml0V3JhcHBlcih0cnVlLCBzbGlkZURlbHRhKSwgMClcblxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIubW92ZVRvKHJlYWxJbmRleCwgdW5kZWZpbmVkLCBhbmltYXRlKVxuXG4gICAgLy8gVXBkYXRlIHRoZSBhY3RpdmUgaW5kZXhcbiAgICB0aGlzLl9pbmRleCA9IG5leHRJbmRleFxuXG4gICAgLy8gTWFyayBzbGlkZXMgYXMgYWN0aXZlXG4gICAgdGhpcy5fdXBkYXRlUGFnaW5hdGlvbigpXG4gICAgdGhpcy5fdXBkYXRlQWN0aXZlU2xpZGVzKHJlYWxJbmRleClcblxuICAgIC8vIGNvbnNvbGUubG9nKGBQZXJmb3JtZWQgc2xpZGUgdG8gJHt0aGlzLl9pbmRleH0sIHJlYWxJbmRleDogJHt0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4fWApXG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIHNsaWRlciB0byB0aGUgc2VsZWN0ZWQgc2xpZGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgc2xpZGUgdG8gc2xpZGUgdG8uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYW5pbWF0ZSAtIGBUcnVlYCBpZiB0aGUgc2xpZGUgc2hvdWxkIGJlIGFuaW1hdGVkOyBvdGhlcndpc2UgYGZhbHNlYC4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKi9cbiAgcHVibGljIHNsaWRlVG8oaW5kZXg6IG51bWJlciwgYW5pbWF0ZSA9IHRydWUpIHtcbiAgICB0aGlzLnNsaWRlKGluZGV4LCB1bmRlZmluZWQsIGFuaW1hdGUpXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudHMgYW5kIGZyZWVzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG5cbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpXG4gICAgdGhpcy5fc2xpZGVBcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5faGFuZGxlVG91Y2hzdGFydClcbiAgICB0aGlzLl9zbGlkZUFyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5faGFuZGxlVG91Y2hzdGFydClcblxuICAgIHRoaXMuX2JyZWFrcG9pbnRQaG9uZS5yZW1vdmUoKVxuICAgIHRoaXMuX2JyZWFrcG9pbnRUYWJsZXQucmVtb3ZlKClcbiAgICB0aGlzLl9icmVha3BvaW50RGVza3RvcC5yZW1vdmUoKVxuXG4gICAgaWYgKHRoaXMuX3ByZXZDdHJsICYmIHRoaXMuX25leHRDdHJsKSB7XG4gICAgICB0aGlzLl9wcmV2Q3RybC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fcHJldkhhbmRsZXIpXG4gICAgICB0aGlzLl9uZXh0Q3RybC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fbmV4dEhhbmRsZXIpXG4gICAgfVxuXG4gICAgKHRoaXMgYXMgYW55KS5fcHJldkN0cmwgPSB1bmRlZmluZWQ7XG4gICAgKHRoaXMgYXMgYW55KS5fbmV4dEN0cmwgPSB1bmRlZmluZWRcblxuICAgIGlmICh0aGlzLl9wYWdpbmF0aW9uKSB7XG4gICAgICB0aGlzLl9wYWdpbmF0aW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9wYWdpbmF0aW9uQ2xpY2tIYW5kbGVyKTtcbiAgICAgICh0aGlzIGFzIGFueSkuX3BhZ2luYXRpb24gPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLmRlc3Ryb3koKTtcbiAgICAodGhpcyBhcyBhbnkpLl9zbGlkZXJXcmFwcGVyID0gdW5kZWZpbmVkXG4gIH1cbn1cblxuY29uc3QgVFJBTlNGT1JNID0gXCJ0cmFuc2Zvcm1cIlxuY29uc3QgRFVSQVRJT04gPSBcInRyYW5zaXRpb25EdXJhdGlvblwiXG5jb25zdCBUSU1JTkcgPSBcInRyYW5zaXRpb25UaW1pbmdGdW5jdGlvblwiXG5cbmNsYXNzIFNsaWRlcldyYXBwZXIge1xuICBwcml2YXRlIF93cmFwcGVyRWxlbWVudDogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfc2xpZGVBcmVhRWxlbWVudDogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfY2Fyb3VzZWxFbGVtZW50OiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX3Bvc2l0aW9uOiBudW1iZXJcbiAgcHJpdmF0ZSBfaW5kZXg6IG51bWJlclxuXG4gIHByaXZhdGUgX2lzZHJhZ2dpbmc6IGJvb2xlYW5cbiAgcHJpdmF0ZSBfZHJhZ1N0YXJ0UG9zaXRpb24/OiBudW1iZXJcblxuICBwcml2YXRlIF9hcmVhT2Zmc2V0PzogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfc2xpZGVzUGVyR3JvdXAhOiBudW1iZXJcblxuICBwcml2YXRlIF9jb250YWluZXJNaW4hOiBudW1iZXJcbiAgcHJpdmF0ZSBfY29udGFpbmVyTWF4ITogbnVtYmVyXG5cbiAgY29uc3RydWN0b3Iod3JhcHBlckVsZW1lbnQ6IEhUTUxFbGVtZW50LCBzbGlkZUFyZWFFbGVtZW50OiBIVE1MRWxlbWVudCwgY2Fyb3VzZWxFbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50ID0gd3JhcHBlckVsZW1lbnRcbiAgICB0aGlzLl9zbGlkZUFyZWFFbGVtZW50ID0gc2xpZGVBcmVhRWxlbWVudFxuICAgIHRoaXMuX2Nhcm91c2VsRWxlbWVudCA9IGNhcm91c2VsRWxlbWVudFxuXG4gICAgdGhpcy5fcG9zaXRpb24gPSAwXG4gICAgdGhpcy5faW5kZXggPSAwXG4gICAgdGhpcy5faXNkcmFnZ2luZyA9IGZhbHNlXG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldFNsaWRlKGluZGV4OiBudW1iZXIpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuX3dyYXBwZXJFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCAnaW5kZXgnIGlzIG91dCBvZiByYW5nZSwgVmFsdWU6ICR7aW5kZXh9IE1pbjogMCwgTWF4OiAke3RoaXMuX3dyYXBwZXJFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDF9YClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlckVsZW1lbnQuY2hpbGRyZW5baW5kZXhdIGFzIEhUTUxFbGVtZW50XG4gIH1cblxuICBwcm90ZWN0ZWQgX3NldFRyYW5zZm9ybSh0YXJnZXRQb3NpdGlvbjogbnVtYmVyLCBhbmltYXRlZCA9IGZhbHNlLCBkdXJhdGlvbiA9IEFOSU1BVElPTl9EVVJBVElPTiwgZWFzZSA9IEFOSU1BVElPTl9FQVNJTkcpIHtcbiAgICBpZiAoYW5pbWF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICBkdXJhdGlvbiA9IDBcbiAgICB9XG5cbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBzdHlsZVtEVVJBVElPTl0gPSBgJHtkdXJhdGlvbn1tc2BcbiAgICAgIHN0eWxlW1RJTUlOR10gPSBlYXNlXG5cbiAgICAgIC8vIE5vIHN1YiBwaXhlbCB0cmFuc2l0aW9ucy5cbiAgICAgIHRhcmdldFBvc2l0aW9uID0gTWF0aC5mbG9vcih0YXJnZXRQb3NpdGlvbilcblxuICAgICAgc3R5bGVbVFJBTlNGT1JNXSA9IGB0cmFuc2xhdGUoJHt0YXJnZXRQb3NpdGlvbn1weCwgMClgXG4gICAgICB0aGlzLl9wb3NpdGlvbiA9IHRhcmdldFBvc2l0aW9uXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXRXcmFwcGVyU2xpZGVQb3NpdGlvbihpbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3Qgd3JhcHBlckNlbnRlciA9ICgwLjUgKiB0aGlzLl93cmFwcGVyRWxlbWVudC5vZmZzZXRXaWR0aClcbiAgICBjb25zdCBzbGlkZSA9IHRoaXMuX2dldFNsaWRlKGluZGV4KVxuXG4gICAgbGV0IHJlc3VsdCA9IDBcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBzbGlkZSAoY2VudGVyZWQpXG4gICAgaWYgKHRoaXMuX3NsaWRlc1Blckdyb3VwICUgMiA9PT0gMCkge1xuICAgICAgbGV0IHNsaWRlU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzbGlkZSlcbiAgICAgIGxldCBzbGlkZU1hcmdpbiA9IHNsaWRlU3R5bGUgPyBwYXJzZUludChzbGlkZVN0eWxlLm1hcmdpblJpZ2h0ISwgMTApIDogMFxuICAgICAgLy8gQ2VudGVyZWQgdG8gdGhlIHNwYWNlIGJldHdlZW4gdGhlIHR3byBjZW50ZXIgc2xpZGVzIG9mIHRoZSBncm91cFxuICAgICAgcmVzdWx0ID0gLXNsaWRlLm9mZnNldExlZnQgLSAoc2xpZGUuY2xpZW50V2lkdGgpICsgd3JhcHBlckNlbnRlciAtIHNsaWRlTWFyZ2luXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IC1zbGlkZS5vZmZzZXRMZWZ0IC0gKDAuNSAqIHNsaWRlLmNsaWVudFdpZHRoKSArIHdyYXBwZXJDZW50ZXJcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBnZXQgcG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uXG4gIH1cblxuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4XG4gIH1cblxuICBzZXQgaW5kZXgoaW5kZXg6IG51bWJlcikge1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXhcbiAgfVxuXG4gIHNldCBzbGlkZXNQZXJHcm91cCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5fc2xpZGVzUGVyR3JvdXAgPSB2YWx1ZVxuICB9XG5cbiAgcHVibGljIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5vbnJlc2l6ZSgpXG4gIH1cblxuICBwdWJsaWMgb25yZXNpemUoKSB7XG4gICAgLy8gdXBkYXRlIHRoZSBhcmVhIG9mZnNldCBmb3Igc2xpZGUgcG9zaXRpb24gY2FsY3VsYXRpb25cbiAgICB0aGlzLl9hcmVhT2Zmc2V0ID0gdGhpcy5fc2xpZGVBcmVhRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0XG5cbiAgICAvLyBHZXQgdGhlIGNvbnRhaW5lciBkaW1lbnNpb25zXG4gICAgY29uc3QgY29udGFpbmVyUmVjdCA9IHRoaXMuX2Nhcm91c2VsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIHRoaXMuX2NvbnRhaW5lck1pbiA9IGNvbnRhaW5lclJlY3QubGVmdFxuICAgIHRoaXMuX2NvbnRhaW5lck1heCA9IGNvbnRhaW5lclJlY3QucmlnaHRcbiAgfVxuXG4gIHB1YmxpYyBiZWdpbkRyYWcoKSB7XG4gICAgdGhpcy5faXNkcmFnZ2luZyA9IHRydWVcbiAgICB0aGlzLl9kcmFnU3RhcnRQb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uXG4gIH1cblxuICBwdWJsaWMgY2FuY2VsRHJhZygpIHtcbiAgICB0aGlzLl9pc2RyYWdnaW5nID0gZmFsc2VcbiAgICB0aGlzLl9zZXRUcmFuc2Zvcm0odGhpcy5fZHJhZ1N0YXJ0UG9zaXRpb24hLCB0cnVlLCBBTklNQVRJT05fRFVSQVRJT04sIEFOSU1BVElPTl9FQVNJTkcpXG5cbiAgICB0aGlzLl9kcmFnU3RhcnRQb3NpdGlvbiA9IHVuZGVmaW5lZFxuICB9XG5cbiAgcHVibGljIGVuZERyYWcoKSB7XG4gICAgdGhpcy5faXNkcmFnZ2luZyA9IGZhbHNlXG4gICAgdGhpcy5fZHJhZ1N0YXJ0UG9zaXRpb24gPSB1bmRlZmluZWRcbiAgfVxuXG4gIHB1YmxpYyBtb3ZlKGRlbHRhOiBudW1iZXIsIGFuaW1hdGVkID0gZmFsc2UsIGR1cmF0aW9uID0gQU5JTUFUSU9OX0RVUkFUSU9OLCBlYXNlID0gQU5JTUFUSU9OX0VBU0lORykge1xuICAgIGRlbHRhID0gTWF0aC50cnVuYyhkZWx0YSlcbiAgICBpZiAoTWF0aC5hYnMoZGVsdGEpIDw9IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCB0YXJnZXRQb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uICs9IGRlbHRhXG4gICAgdGhpcy5fc2V0VHJhbnNmb3JtKHRhcmdldFBvc2l0aW9uLCBhbmltYXRlZCwgZHVyYXRpb24sIGVhc2UpXG4gIH1cblxuICBwdWJsaWMgbW92ZVRvKGluZGV4OiBudW1iZXIsIGRlbHRhPzogbnVtYmVyLCBhbmltYXRlZCA9IGZhbHNlKSB7XG4gICAgbGV0IG5ld1Bvc2l0aW9uID0gMFxuICAgIGlmICghZGVsdGEpIHtcbiAgICAgIG5ld1Bvc2l0aW9uID0gdGhpcy5fZ2V0V3JhcHBlclNsaWRlUG9zaXRpb24oaW5kZXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1Bvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24gKz0gZGVsdGFcbiAgICB9XG5cbiAgICB0aGlzLl9pbmRleCA9IGluZGV4XG4gICAgdGhpcy5fc2V0VHJhbnNmb3JtKG5ld1Bvc2l0aW9uLCBhbmltYXRlZClcbiAgfVxuXG4gIHB1YmxpYyBhZGRTbGlkZShzbGlkZTogSFRNTEVsZW1lbnQsIHBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICBpZiAoIXNsaWRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIGFuIHVuZGVmaW5lZCBzbGlkZVwiKVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiAhPT0gLTEgJiYgcG9zaXRpb24gIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgb3V0IG9mIHJhbmdlLCAncG9zaXRpb24nIG11c3QgYmUgZWl0aGVyIDEgb3IgLTEuIFZhbHVlICR7cG9zaXRpb259YClcbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPiAwKSB7XG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hcHBlbmRDaGlsZChzbGlkZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuaW5zZXJ0QmVmb3JlKHNsaWRlLCB0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlblswXSlcbiAgICAgIHRoaXMuX2luZGV4KytcbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICBsZXQgd2lkdGggPSBzbGlkZS5vZmZzZXRXaWR0aFxuXG4gICAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzbGlkZSlcbiAgICAgIGxldCBtYXJnaW5MZWZ0ID0gc3R5bGUgPyBwYXJzZUludChzdHlsZS5tYXJnaW5MZWZ0ISwgMTApIDogMFxuICAgICAgbGV0IG1hcmdpblJpZ2h0ID0gc3R5bGUgPyBwYXJzZUludChzdHlsZS5tYXJnaW5SaWdodCEsIDEwKSA6IDBcblxuICAgICAgdGhpcy5tb3ZlKC0od2lkdGggKyBtYXJnaW5MZWZ0ICsgbWFyZ2luUmlnaHQpKVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVTbGlkZShpbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3Qgc2xpZGUgPSB0aGlzLl9nZXRTbGlkZShpbmRleClcbiAgICBsZXQgd2lkdGggPSBzbGlkZS5vZmZzZXRXaWR0aFxuXG4gICAgaWYgKGluZGV4IDw9IHRoaXMuX2luZGV4KSB7XG4gICAgICB3aWR0aCAqPSAtMVxuICAgICAgdGhpcy5faW5kZXgtLVxuICAgIH1cblxuICAgIHJlbW92ZShzbGlkZSlcblxuICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgIHRoaXMubW92ZSgtd2lkdGgpXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFNsaWRlRGVsdGEoaW5kZXg6IG51bWJlcikge1xuICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvblxuICAgIGlmICh0aGlzLl9pc2RyYWdnaW5nID09PSB0cnVlKSB7XG4gICAgICBjdXJyZW50UG9zaXRpb24gPSB0aGlzLl9kcmFnU3RhcnRQb3NpdGlvbiEgLSB0aGlzLl9wb3NpdGlvblxuICAgIH1cblxuICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy5fZ2V0V3JhcHBlclNsaWRlUG9zaXRpb24oaW5kZXgpXG4gICAgcmV0dXJuIG5ld1Bvc2l0aW9uIC0gY3VycmVudFBvc2l0aW9uXG4gIH1cblxuICBwdWJsaWMgZ2V0U2xpZGVQcm9wZXJ0aWVzKGluZGV4OiBudW1iZXIsIGRlbHRhID0gMCk6IFNsaWRlUHJvcGVydGllcyB7XG4gICAgbGV0IGN1cnJlbnRPZmZzZXQgPSB0aGlzLl9hcmVhT2Zmc2V0ISArIHRoaXMuX3Bvc2l0aW9uICsgZGVsdGFcbiAgICBsZXQgY3VycmVudExlZnQgPSBjdXJyZW50T2Zmc2V0XG4gICAgbGV0IGN1cnJlbnRSaWdodCA9IGN1cnJlbnRPZmZzZXRcbiAgICBsZXQgWyBjdXJyZW50TWFyZ2luTGVmdCwgY3VycmVudE1hcmdpblJpZ2h0IF0gPSBbIDAsIDAgXVxuXG4gICAgbGV0IHNsaWRlID0gdGhpcy5fZ2V0U2xpZGUoaW5kZXgpXG4gICAgbGV0IHNsaWRlSW5kZXggPSBwYXJzZUludChzbGlkZS5nZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0lOREVYKSEsIDEwKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gaW5kZXg7IGkrKykge1xuICAgICAgc2xpZGUgPSB0aGlzLl9nZXRTbGlkZShpKVxuICAgICAgbGV0IHNsaWRlU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzbGlkZSlcblxuICAgICAgY3VycmVudE1hcmdpbkxlZnQgPSBwYXJzZUludChzbGlkZVN0eWxlLm1hcmdpbkxlZnQhLCAxMClcbiAgICAgIGN1cnJlbnRNYXJnaW5SaWdodCA9IHBhcnNlSW50KHNsaWRlU3R5bGUubWFyZ2luUmlnaHQhLCAxMClcblxuICAgICAgY3VycmVudE9mZnNldCArPSBjdXJyZW50TWFyZ2luTGVmdFxuICAgICAgY3VycmVudExlZnQgPSBjdXJyZW50T2Zmc2V0XG4gICAgICBjdXJyZW50UmlnaHQgPSBjdXJyZW50TGVmdCArIHNsaWRlLm9mZnNldFdpZHRoXG5cbiAgICAgIGlmIChpIDwgaW5kZXgpIHtcbiAgICAgICAgY3VycmVudE9mZnNldCA9IGN1cnJlbnRSaWdodCArIGN1cnJlbnRNYXJnaW5SaWdodFxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB2aXNpYmxlID0gZmFsc2VcbiAgICBpZiAoKGN1cnJlbnRMZWZ0ID4gdGhpcy5fY29udGFpbmVyTWluICYmIGN1cnJlbnRMZWZ0IDwgdGhpcy5fY29udGFpbmVyTWF4KSB8fFxuICAgICAgKGN1cnJlbnRSaWdodCA+IHRoaXMuX2NvbnRhaW5lck1pbiAmJiBjdXJyZW50UmlnaHQgPCB0aGlzLl9jb250YWluZXJNYXgpKSB7XG4gICAgICB2aXNpYmxlID0gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2aXNpYmxlLFxuICAgICAgaW5kZXg6IHNsaWRlSW5kZXgsXG4gICAgICBsZWZ0OiBjdXJyZW50TGVmdCxcbiAgICAgIHJpZ2h0OiBjdXJyZW50UmlnaHQsXG4gICAgICB3aWR0aDogY3VycmVudFJpZ2h0IC0gY3VycmVudExlZnQsXG4gICAgICBtYXJnaW5MZWZ0OiBjdXJyZW50TWFyZ2luTGVmdCxcbiAgICAgIG1hcmdpblJpZ2h0OiBjdXJyZW50TWFyZ2luUmlnaHRcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0UmVtb3ZhYmxlU2xpZGVzKGRlbHRhOiBudW1iZXIpIHtcbiAgICBsZXQgc2xpZGVzID0gW11cbiAgICBsZXQgZmlyc3Q6IFNsaWRlUHJvcGVydGllcyB8IHVuZGVmaW5lZFxuICAgIGxldCBsYXN0OiBTbGlkZVByb3BlcnRpZXMgfCB1bmRlZmluZWRcblxuICAgIGxldCBpbmRleCA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LmNoaWxkcmVuLmxlbmd0aFxuICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgIGluZGV4LS1cblxuICAgICAgbGV0IHByb3BzTm93ID0gdGhpcy5nZXRTbGlkZVByb3BlcnRpZXMoaW5kZXgpXG4gICAgICBsZXQgcHJvcHNOZXcgPSB0aGlzLmdldFNsaWRlUHJvcGVydGllcyhpbmRleCwgZGVsdGEpXG5cbiAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5fd3JhcHBlckVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgICBsYXN0ID0gcHJvcHNOZXdcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIGZpcnN0ID0gcHJvcHNOZXdcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzTm93LnZpc2libGUgPT09IGZhbHNlICYmIHByb3BzTmV3LnZpc2libGUgPT09IGZhbHNlICYmXG4gICAgICAgIGluZGV4ICE9PSB0aGlzLl9pbmRleCAmJiB0aGlzLl9pc2RyYWdnaW5nID09PSBmYWxzZSkge1xuICAgICAgICBzbGlkZXMucHVzaCh0cnVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xpZGVzLnB1c2goZmFsc2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgc2xpZGVzLnJldmVyc2UoKVxuXG4gICAgbGV0IGZpcnN0VG9LZWVwID0gc2xpZGVzLmluZGV4T2YoZmFsc2UpXG4gICAgbGV0IGxhc3RUb0tlZXAgPSBzbGlkZXMubGFzdEluZGV4T2YoZmFsc2UpXG5cbiAgICBmb3IgKGxldCBpID0gZmlyc3RUb0tlZXA7IGkgPCBsYXN0VG9LZWVwOyBpKyspIHtcbiAgICAgIHNsaWRlc1tpXSA9IGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNsaWRlcyxcbiAgICAgIGZpcnN0OiBmaXJzdCBhcyBTbGlkZVByb3BlcnRpZXMsXG4gICAgICBsYXN0OiBsYXN0IGFzIFNsaWRlUHJvcGVydGllc1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRFbXB0eVNwYWNlKGxlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlcikge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBNYXRoLm1heChNYXRoLmNlaWwobGVmdCAtIHRoaXMuX2NvbnRhaW5lck1pbiksIDApLFxuICAgICAgcmlnaHQ6IE1hdGgubWF4KE1hdGguY2VpbCh0aGlzLl9jb250YWluZXJNYXggLSByaWdodCksIDApXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgKHRoaXMgYXMgYW55KS5fd3JhcHBlckVsZW1lbnQgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX3NsaWRlQXJlYUVsZW1lbnQgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX2Nhcm91c2VsRWxlbWVudCA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZGVzdHJveSgpIGluc3RlYWQuXG4gICAqIEB0b2RvIHJlbW92ZSBpbiB2ZXJzaW9uIDIuMC4wXG4gICAqL1xuICBwdWJsaWMgZGVzdG9yeSgpIHtcbiAgICB0aGlzLmRlc3Ryb3koKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLmNhcm91c2VsXCIsIChlKSA9PiB7XG4gICAgbmV3IENhcm91c2VsKGUgYXMgSFRNTEVsZW1lbnQpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IENhcm91c2VsXG4iLCJpbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCByZW1vdmUgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IHsgZ2V0QXR0cmlidXRlUmVmZXJlbmNlIH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5pbXBvcnQgeyB0cnlHZXREYXRhLCBjcmVhdGVMZWdlbmRJdGVtLCBpc0NvbG9yLCByZW1vdmVBbGxDaGlsZHJlbiwgQ2hhcnREYXRhLCBDaGFydEF4aXMgfSBmcm9tIFwiLi9DaGFydEZ1bmN0aW9uc1wiXG5cbmltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5cbmNvbnN0IFFVRVJZX0RFVEFJTF9SSUdIVCA9IFwiLmRldGFpbC1yaWdodFwiXG5jb25zdCBRVUVSWV9ERVRBSUxfQk9UVE9NID0gXCIuZGV0YWlsLWJvdHRvbVwiXG5jb25zdCBRVUVSWV9QUk9HUkVTUyA9IFwiLmJhci1jaGFydF9fcHJvZ3Jlc3NcIlxuXG5jb25zdCBDTEFTU19VTkxJTUlURUQgPSBcImJhci1jaGFydC1ob3Jpem9udGFsLS11bmxpbWl0ZWRcIlxuY29uc3QgQ0xBU1NfTElNSVRFRCA9IFwiYmFyLWNoYXJ0LWhvcml6b250YWwtLWxpbWl0ZWRcIlxuXG5jb25zdCBDTEFTU19ERVRBSUxfVkFMVUUgPSBcInZhbHVlXCJcbmNvbnN0IENMQVNTX0RFVEFJTF9VTklUID0gXCJ1bml0XCJcblxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SID0gXCJpbmRpY2F0b3JcIlxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SX1dSQVBQRVIgPSBcImluZGljYXRvci13cmFwcGVyXCJcblxuY29uc3QgQ0xBU1NfVE9PTFRJUCA9IFwidG9vbHRpcFwiXG5jb25zdCBDTEFTU19UT09MVElQX01VTFRJTElORSA9IFwidG9vbHRpcC0tbXVsdGlsaW5lXCJcblxuY29uc3QgQU5JTUFUSU9OX0RVUkFUSU9OID0gNTAwXG5cbi8qKlxuICogQmFyIENoYXJ0IEhvcml6b250YWwgQ29tcG9uZW50LlxuICovXG5jbGFzcyBCYXJDaGFydEhvcml6b250YWwgZXh0ZW5kcyBEb21FbGVtZW50PEhUTUxFbGVtZW50PiB7XG4gIHByaXZhdGUgX2RhdGEhOiBDaGFydERhdGFcblxuICBwcml2YXRlIF9sZWdlbmRJdGVtczogSFRNTEVsZW1lbnRbXVxuICBwcml2YXRlIF9wcm9nZXNzV3JhcHBlciE6IEhUTUxFbGVtZW50XG5cbiAgcHJpdmF0ZSBfdW5pdCE6IHN0cmluZ1xuICBwcml2YXRlIF9tYXhWYWx1ZSE6IG51bWJlclxuICBwcml2YXRlIF9wcmVjaXNpb24hOiBudW1iZXJcblxuICBwcml2YXRlIF9pc1VubGltaXRlZCE6IGJvb2xlYW5cbiAgcHJpdmF0ZSBfaXNMaW1pdGVkITogYm9vbGVhblxuXG4gIHByaXZhdGUgX2RldGFpbFJpZ2h0ITogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfbGVnZW5kITogSFRNTEVsZW1lbnRcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIGJhciBjaGFydCBob3Jpem9udGFsIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtEb21FbGVtZW50fSAtIHJvb3QgZWxlbWVudCBvZiB0aGUgY2hhcnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MRWxlbWVudCwgZGF0YT86IENoYXJ0RGF0YSkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGFcbiAgICB9XG5cbiAgICB0aGlzLl9sZWdlbmRJdGVtcyA9IFtdXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl91bml0ID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXVuaXRcIikgfHwgXCJcIlxuICAgIHRoaXMuX21heFZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtbWF4XCIpISlcbiAgICB0aGlzLl9wcmVjaXNpb24gPSBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtcHJlY2lzaW9uXCIpISwgMTApIHx8IDBcblxuICAgIHRoaXMuX2lzVW5saW1pdGVkID0gdGhpcy5oYXNDbGFzcyhDTEFTU19VTkxJTUlURUQpXG4gICAgdGhpcy5faXNMaW1pdGVkID0gdGhpcy5oYXNDbGFzcyhDTEFTU19MSU1JVEVEKVxuXG4gICAgdGhpcy5fcHJvZ2Vzc1dyYXBwZXIgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9QUk9HUkVTUykhIGFzIEhUTUxFbGVtZW50XG5cbiAgICBpZiAodGhpcy5faXNMaW1pdGVkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9kZXRhaWxSaWdodCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0RFVEFJTF9CT1RUT00pISBhcyBIVE1MRWxlbWVudFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kZXRhaWxSaWdodCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0RFVEFJTF9SSUdIVCkhIGFzIEhUTUxFbGVtZW50XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzVW5saW1pdGVkID09PSBmYWxzZSAmJiB0aGlzLl9pc0xpbWl0ZWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9sZWdlbmQgPSBnZXRBdHRyaWJ1dGVSZWZlcmVuY2UodGhpcy5lbGVtZW50LCBcImRhdGEtbGVnZW5kXCIpIVxuICAgIH1cblxuICAgIGlmICghdGhpcy5fZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHRyeUdldERhdGEodGhpcy5lbGVtZW50KVxuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlcigpXG4gIH1cblxuICBwcm90ZWN0ZWQgX3JlbmRlcigpIHtcbiAgICBsZXQgZGF0YU9uZSA9IHRoaXMuX2RhdGFbMF1cbiAgICBsZXQgZGF0YVR3byA9IHRoaXMuX2RhdGFbMV1cblxuICAgIGxldCB0b29sdGlwID0gdGhpcy5faXNMaW1pdGVkID09PSBmYWxzZSA/IHRoaXMuX2dldFRvb2x0aXBDb250ZW50KHRoaXMuX2RhdGEpIDogdW5kZWZpbmVkXG5cbiAgICBsZXQgYW5pbWF0ZWRWYWx1ZUVsZW1lbnQ6IEVsZW1lbnQgfCB1bmRlZmluZWRcblxuICAgIC8vIENsZWFudXBcbiAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9kZXRhaWxSaWdodClcbiAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9wcm9nZXNzV3JhcHBlcilcblxuICAgIC8vIENsZWFyIG9ubHkgb3duIGxlZ2VuZCBpdGVtc1xuICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5fbGVnZW5kSXRlbXMpIHtcbiAgICAgIHJlbW92ZShpdGVtKVxuICAgIH1cbiAgICB0aGlzLl9sZWdlbmRJdGVtcyA9IFtdXG5cbiAgICBpZiAoZGF0YU9uZSkge1xuICAgICAgaWYgKHRoaXMuX2lzVW5saW1pdGVkID09PSBmYWxzZSB8fCAodGhpcy5faXNVbmxpbWl0ZWQgPT09IHRydWUgJiYgIWRhdGFUd28pKSB7XG5cbiAgICAgICAgbGV0IHZhbEVsZW1lbnQgPSBhbmltYXRlZFZhbHVlRWxlbWVudCA9IHRoaXMuX2NyZWF0ZVZhbHVlRWxlbWVudChkYXRhT25lKVxuICAgICAgICB0aGlzLl9kZXRhaWxSaWdodC5hcHBlbmRDaGlsZCh2YWxFbGVtZW50KVxuXG4gICAgICAgIGlmICh0aGlzLl9pc0xpbWl0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgY29uc3Qgc2VwYXJhdG9yRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfREVUQUlMX1VOSVQpXG4gICAgICAgICAgICAuZWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgIHNlcGFyYXRvckVsZW1lbnQuaW5uZXJUZXh0ID0gYCAke3RoaXMuX3VuaXR9YFxuXG4gICAgICAgICAgdGhpcy5fZGV0YWlsUmlnaHQuYXBwZW5kQ2hpbGQoc2VwYXJhdG9yRWxlbWVudClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdGhlIGluZGljYXRvclxuICAgICAgbGV0IGluZGljYXRvciA9IHRoaXMuX2FkZEluZGljYXRvcihkYXRhT25lLCB0b29sdGlwKVxuICAgICAgdGhpcy5fYW5pbWF0ZUluZGljYXRvcihpbmRpY2F0b3IsIDApXG5cbiAgICAgIC8vIEFuaW1hdGUgdGhlIHZhbHVlIGlmIHJlcXVpcmVkXG4gICAgICBpZiAoYW5pbWF0ZWRWYWx1ZUVsZW1lbnQgJiYgdGhpcy5faXNMaW1pdGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGVWYWx1ZUVsZW1lbnQoYW5pbWF0ZWRWYWx1ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQsIGRhdGFPbmUudmFsdWUpXG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgbGVnZW5kXG4gICAgICBpZiAodGhpcy5fbGVnZW5kKSB7XG4gICAgICAgIGNvbnN0IGxlZ2VuZEl0ZW0gPSBjcmVhdGVMZWdlbmRJdGVtKGRhdGFPbmUpXG4gICAgICAgIHRoaXMuX2xlZ2VuZC5hcHBlbmRDaGlsZChsZWdlbmRJdGVtKVxuICAgICAgICB0aGlzLl9sZWdlbmRJdGVtcy5wdXNoKGxlZ2VuZEl0ZW0pXG5cbiAgICAgICAgdGhpcy5fYW5pbWF0ZUxlZ2VuZChsZWdlbmRJdGVtLCAwKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkYXRhVHdvKSB7XG4gICAgICBsZXQgdmFsRWxlbWVudCA9IHRoaXMuX2NyZWF0ZVZhbHVlRWxlbWVudChkYXRhVHdvKVxuXG4gICAgICBsZXQgdW5pdEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfREVUQUlMX1VOSVQpXG4gICAgICAgIC5lbGVtZW50IGFzIEhUTUxFbGVtZW50XG4gICAgICB1bml0RWxlbWVudC5pbm5lclRleHQgPSBgICR7dGhpcy5fdW5pdH1gXG5cbiAgICAgIHRoaXMuX2RldGFpbFJpZ2h0LmFwcGVuZENoaWxkKHZhbEVsZW1lbnQpXG4gICAgICB0aGlzLl9kZXRhaWxSaWdodC5hcHBlbmRDaGlsZCh1bml0RWxlbWVudClcblxuICAgICAgLy8gQWRkIHRoZSBpbmRpY2F0b3JcbiAgICAgIGxldCBpbmRpY2F0b3IgPSB0aGlzLl9hZGRJbmRpY2F0b3IoZGF0YVR3bywgdG9vbHRpcClcbiAgICAgIHRoaXMuX2FuaW1hdGVJbmRpY2F0b3IoaW5kaWNhdG9yLCBBTklNQVRJT05fRFVSQVRJT04pXG5cbiAgICAgIC8vIEFkZCB0aGUgbGVnZW5kXG4gICAgICBpZiAodGhpcy5fbGVnZW5kKSB7XG4gICAgICAgIGNvbnN0IGxlZ2VuZEl0ZW0gPSBjcmVhdGVMZWdlbmRJdGVtKGRhdGFUd28pXG4gICAgICAgIHRoaXMuX2xlZ2VuZC5hcHBlbmRDaGlsZChsZWdlbmRJdGVtKVxuICAgICAgICB0aGlzLl9sZWdlbmRJdGVtcy5wdXNoKGxlZ2VuZEl0ZW0pXG5cbiAgICAgICAgdGhpcy5fYW5pbWF0ZUxlZ2VuZChsZWdlbmRJdGVtLCBBTklNQVRJT05fRFVSQVRJT04pXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzTGltaXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgbGV0IHZhbEVsZW1lbnQgPSB0aGlzLl9jcmVhdGVWYWx1ZUVsZW1lbnQoeyB2YWx1ZTogdGhpcy5fbWF4VmFsdWUgfSlcblxuICAgICAgbGV0IHVuaXRFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX0RFVEFJTF9VTklUKVxuICAgICAgICAuZWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICAgICAgdW5pdEVsZW1lbnQuaW5uZXJUZXh0ID0gYCAke3RoaXMuX3VuaXR9YFxuXG4gICAgICB0aGlzLl9kZXRhaWxSaWdodC5hcHBlbmRDaGlsZCh2YWxFbGVtZW50KVxuICAgICAgdGhpcy5fZGV0YWlsUmlnaHQuYXBwZW5kQ2hpbGQodW5pdEVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfYW5pbWF0ZVZhbHVlRWxlbWVudChhbmltYXRlZFZhbHVlRWxlbWVudDogSFRNTEVsZW1lbnQsIHRvVmFsdWU6IG51bWJlcikge1xuICAgIGxldCBjb3VudGVyID0geyB2YXI6IDAgfVxuICAgIGFuaW1lKHtcbiAgICAgIHRhcmdldHM6IGNvdW50ZXIsXG4gICAgICB2YXI6IHRvVmFsdWUsXG4gICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX0RVUkFUSU9OLFxuICAgICAgZWFzaW5nOiBcImVhc2VPdXRRdWludFwiLFxuICAgICAgcm91bmQ6IDEsXG4gICAgICB1cGRhdGU6ICgpID0+IHtcbiAgICAgICAgYW5pbWF0ZWRWYWx1ZUVsZW1lbnQhLmlubmVyVGV4dCA9IGAke2NvdW50ZXIudmFyfWBcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBfYW5pbWF0ZUluZGljYXRvcihpbmRpY2F0b3JXcmFwcGVyOiBIVE1MRWxlbWVudCwgYW5pbWF0aW9uT2Zmc2V0OiBudW1iZXIpIHtcbiAgICBjb25zdCBpbmRpY2F0b3IgPSBpbmRpY2F0b3JXcmFwcGVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJpbmRpY2F0b3JcIilbMF0gYXMgSFRNTEVsZW1lbnRcbiAgICBjb25zdCBpbmRpY2F0b3JXaWR0aCA9IGluZGljYXRvci5zY3JvbGxXaWR0aFxuICAgIGluZGljYXRvci5zdHlsZS53aWR0aCA9IFwiMHB4XCJcblxuICAgIGFuaW1lKHtcbiAgICAgIHRhcmdldHM6IGluZGljYXRvcixcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fRFVSQVRJT04sXG4gICAgICB3aWR0aDogaW5kaWNhdG9yV2lkdGggKyBcInB4XCIsXG4gICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIixcbiAgICAgIGRlbGF5OiBhbmltYXRpb25PZmZzZXQsXG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBpbmRpY2F0b3Iuc3R5bGUud2lkdGggPSBcIlwiXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgX2FuaW1hdGVMZWdlbmQobGVnZW5kSXRlbTogSFRNTEVsZW1lbnQsIGFuaW1hdGlvbk9mZnNldDogbnVtYmVyKSB7XG4gICAgbGVnZW5kSXRlbS5zdHlsZS5vcGFjaXR5ID0gXCIwXCJcbiAgICBhbmltZSh7XG4gICAgICB0YXJnZXRzOiBsZWdlbmRJdGVtLFxuICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9EVVJBVElPTixcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIixcbiAgICAgIGRlbGF5OiBhbmltYXRpb25PZmZzZXQsXG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBsZWdlbmRJdGVtLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwib3BhY2l0eVwiKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBwcm90ZWN0ZWQgX2NyZWF0ZVZhbHVlRWxlbWVudChkYXRhOiB7IHZhbHVlOiBudW1iZXIgfCBzdHJpbmcgfSkge1xuICAgIGxldCB1bmxpbWl0ZWRQcmVmaXggPSBcIlwiXG5cbiAgICBpZiAodGhpcy5faXNVbmxpbWl0ZWQgPT09IHRydWUpIHtcbiAgICAgIHVubGltaXRlZFByZWZpeCA9IFwiK1wiXG4gICAgfVxuXG4gICAgbGV0IHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgPSBwYXJzZUZsb2F0KChkYXRhLnZhbHVlIGFzIHN0cmluZykpXG5cbiAgICBpZiAodmFsdWUgPD0gMCkge1xuICAgICAgaWYgKHRoaXMuX3ByZWNpc2lvbiA9PT0gMCkge1xuICAgICAgICB2YWx1ZSA9IFwiMFwiXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IFwiLlwiXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wcmVjaXNpb247IGkrKykge1xuICAgICAgICAgIHZhbHVlICs9IFwiMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSB2YWx1ZS50b0ZpeGVkKHRoaXMuX3ByZWNpc2lvbilcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZUVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0RFVEFJTF9WQUxVRSlcbiAgICAgIC5lbGVtZW50IGFzIEhUTUxFbGVtZW50XG4gICAgdmFsdWVFbGVtZW50LmlubmVyVGV4dCA9IGAke3VubGltaXRlZFByZWZpeH0ke3ZhbHVlfWBcbiAgICByZXR1cm4gdmFsdWVFbGVtZW50XG4gIH1cblxuICBwcm90ZWN0ZWQgX2FkZEluZGljYXRvcihkYXRhOiBDaGFydEF4aXMsIHRvb2x0aXA/OiBzdHJpbmcpIHtcbiAgICBsZXQgd2lkdGggPSAoKDEwMC4wIC8gdGhpcy5fbWF4VmFsdWUpICogZGF0YS52YWx1ZSlcblxuICAgIGxldCBpbmRpY2F0b3IgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0lORElDQVRPUilcblxuICAgIGlmIChpc0NvbG9yKGRhdGEuY29sb3IpID09PSB0cnVlKSB7XG4gICAgICBpbmRpY2F0b3Iuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYGJhY2tncm91bmQtY29sb3I6ICR7ZGF0YS5jb2xvcn07YClcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kaWNhdG9yLmFkZENsYXNzKGRhdGEuY29sb3IpXG4gICAgfVxuXG4gICAgbGV0IGluZGljYXRvcldyYXBwZXIgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0lORElDQVRPUl9XUkFQUEVSKVxuICAgICAgLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGB3aWR0aDogJHt3aWR0aH0lYClcbiAgICAgIC5hcHBlbmRDaGlsZChpbmRpY2F0b3IpXG4gICAgICAuc2V0QXR0cmlidXRlKFwib25jbGlja1wiLCBcInZvaWQoMClcIilcblxuICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAgIT09IFwiXCIpIHtcbiAgICAgIGluZGljYXRvcldyYXBwZXJcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX1RPT0xUSVApXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19UT09MVElQX01VTFRJTElORSlcbiAgICAgICAgLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdG9vbHRpcClcbiAgICB9XG5cbiAgICB0aGlzLl9wcm9nZXNzV3JhcHBlci5hcHBlbmRDaGlsZChpbmRpY2F0b3JXcmFwcGVyLmVsZW1lbnQpXG4gICAgcmV0dXJuIGluZGljYXRvcldyYXBwZXIuZWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXRUb29sdGlwQ29udGVudChkYXRhTGlzdDogQ2hhcnREYXRhKSB7XG4gICAgbGV0IHRvb2x0aXAgPSBcIlwiXG4gICAgZm9yIChsZXQgZGF0YSBvZiBkYXRhTGlzdCkge1xuICAgICAgdG9vbHRpcCArPSBgJHtkYXRhLnRpdGxlfTogJHtkYXRhLnZhbHVlfSAke3RoaXMuX3VuaXR9XFxuYFxuICAgIH1cblxuICAgIHJldHVybiB0b29sdGlwLnRyaW0oKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGJhciBjaGFydCB3aXRoIHRoZSBzcGVjaWZpZWQgZGF0YSBkZWZpbml0aW9ucy5cbiAgICogQHBhcmFtIHtBcnJheX0gLSBiYXIgY2hhcnQgZGF0YSBkZWZpbml0aW9ucy5cbiAgICovXG4gIHB1YmxpYyB1cGRhdGUoZGF0YTogQ2hhcnREYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhXG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyBhbmQgY2xlYXJzIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAodGhpcyBhcyBhbnkpLl9kYXRhID0gdW5kZWZpbmVkXG5cbiAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9kZXRhaWxSaWdodClcbiAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9wcm9nZXNzV3JhcHBlcik7XG5cbiAgICAodGhpcyBhcyBhbnkpLl9kZXRhaWxSaWdodCA9IHVuZGVmaW5lZDtcbiAgICAodGhpcyBhcyBhbnkpLl9wcm9nZXNzV3JhcHBlciA9IHVuZGVmaW5lZFxuXG4gICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLl9sZWdlbmRJdGVtcykge1xuICAgICAgcmVtb3ZlKGl0ZW0pXG4gICAgfVxuXG4gICAgKHRoaXMgYXMgYW55KS5fbGVnZW5kSXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgKHRoaXMgYXMgYW55KS5fbGVnZW5kID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGRlc3Ryb3koKSBpbnN0ZWFkLlxuICAgKiBAdG9kbyByZW1vdmUgaW4gdmVyc2lvbiAyLjAuMFxuICAgKi9cbiAgcHVibGljIGRlc3RvcnkoKSB7XG4gICAgdGhpcy5kZXN0cm95KClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZTxIVE1MRWxlbWVudD4oXCIuYmFyLWNoYXJ0LWhvcml6b250YWxcIiwgKGUpID0+IHtcbiAgICBuZXcgQmFyQ2hhcnRIb3Jpem9udGFsKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhckNoYXJ0SG9yaXpvbnRhbFxuIiwiaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgeyB0ZXh0IH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5pbXBvcnQgeyBjcmVhdGVMZWdlbmRJdGVtLCBpc0NvbG9yLCByZW1vdmVBbGxDaGlsZHJlbiwgQ2hhcnRMYWJlbCB9IGZyb20gXCIuL0NoYXJ0RnVuY3Rpb25zXCJcblxuaW1wb3J0IGFuaW1lIGZyb20gXCJhbmltZWpzXCJcblxuY29uc3QgUVVFUllfREFUQV9DQVRFR09SSUVTID0gXCIuanMtZGF0YS1saXN0IC5qcy1jYXRlZ29yeVwiXG5jb25zdCBRVUVSWV9EQVRBX0lURU1TID0gXCIuanMtZGF0YS1saXN0IC5qcy1kYXRhXCJcbmNvbnN0IFFVRVJZX0NIQVJUID0gXCIuanMtY2hhcnRcIlxuY29uc3QgUVVFUllfTEVHRU5EID0gXCIuYmFyLWNoYXJ0X19sZWdlbmRcIlxuXG5jb25zdCBDTEFTU19JTkRJQ0FUT1IgPSBcImluZGljYXRvclwiXG5jb25zdCBDTEFTU19MQUJFTF9YID0gXCJheGlzLXgtbGFiZWxcIlxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SX1dSQVBQRVIgPSBcImluZGljYXRvci13cmFwcGVyXCJcbmNvbnN0IENMQVNTX0lORElDQVRPUl9JTk5FUl9XUkFQUEVSID0gXCJpbmRpY2F0b3Itd3JhcHBlci1pbm5lclwiXG5jb25zdCBDTEFTU19JTkRJQ0FUT1JfRU1QVFkgPSBcImVtcHR5XCJcblxuY29uc3QgQ0xBU1NfVE9PTFRJUCA9IFwidG9vbHRpcFwiXG5jb25zdCBDTEFTU19UT09MVElQX0xFRlQgPSBcInRvb2x0aXAtLWxlZnRcIlxuY29uc3QgQ0xBU1NfVE9PTFRJUF9SSUdIVCA9IFwidG9vbHRpcC0tcmlnaHRcIlxuY29uc3QgQ0xBU1NfVE9PTFRJUF9NVUxUSUxJTkUgPSBcInRvb2x0aXAtLW11bHRpbGluZVwiXG5cbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTiA9IDUwMFxuXG5leHBvcnQgaW50ZXJmYWNlIENhdGVnb3J5IGV4dGVuZHMgQ2hhcnRMYWJlbCB7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YUVudHJ5IHtcbiAgdGl0bGU6IHN0cmluZ1xuICBjbGFzczogc3RyaW5nXG4gIHZhbHVlczogbnVtYmVyW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGFydERhdGEge1xuICBjYXRlZ29yaWVzOiBDYXRlZ29yeVtdXG4gIGl0ZW1zOiBEYXRhRW50cnlbXVxufVxuXG4vKipcbiAqIEJhciBDaGFydCBIb3Jpem9udGFsIENvbXBvbmVudC5cbiAqL1xuY2xhc3MgQmFyQ2hhcnRWZXJ0aWNhbCBleHRlbmRzIERvbUVsZW1lbnQ8SFRNTEVsZW1lbnQ+IHtcbiAgcHJpdmF0ZSBfZGF0YSE6IENoYXJ0RGF0YVxuXG4gIHByaXZhdGUgX3VuaXQhOiBzdHJpbmdcbiAgcHJpdmF0ZSBfbWF4VmFsdWUhOiBudW1iZXJcblxuICBwcml2YXRlIF9jaGFydCE6IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX2xlZ2VuZCE6IEhUTUxFbGVtZW50XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBiYXIgY2hhcnQgaG9yaXpvbnRhbCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBlbGVtZW50IC0gcm9vdCBlbGVtZW50IG9mIHRoZSBjaGFydC5cbiAgICogQHBhcmFtIGRhdGEgLSBkYXRhIGZvciB0aGUgY2hhcnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MRWxlbWVudCwgZGF0YT86IENoYXJ0RGF0YSkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGFcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl91bml0ID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXVuaXRcIikgfHwgXCJcIlxuXG4gICAgdGhpcy5fbWF4VmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS1tYXhcIikhKSB8fCAxMDBcblxuICAgIHRoaXMuX2NoYXJ0ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfQ0hBUlQpISBhcyBIVE1MRWxlbWVudFxuICAgIHRoaXMuX2xlZ2VuZCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0xFR0VORCkhIGFzIEhUTUxFbGVtZW50XG5cbiAgICBpZiAoIXRoaXMuX2RhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl90cnlHZXREYXRhKHRoaXMuZWxlbWVudClcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXIoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF90cnlHZXREYXRhKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQ2hhcnREYXRhIHtcbiAgICBjb25zdCBkYXRhOiBDaGFydERhdGEgPSB7XG4gICAgICBjYXRlZ29yaWVzOiBbXSxcbiAgICAgIGl0ZW1zOiBbXVxuICAgIH1cblxuICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfREFUQV9DQVRFR09SSUVTKVxuICAgIGNvbnN0IGl0ZW1zID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX0RBVEFfSVRFTVMpXG5cbiAgICBmb3IgKGNvbnN0IGNhdGVnb3J5IG9mIGNhdGVnb3JpZXMpIHtcbiAgICAgIGRhdGEuY2F0ZWdvcmllcy5wdXNoKFxuICAgICAgICB7XG4gICAgICAgICAgdGl0bGU6IHRleHQoY2F0ZWdvcnkpLFxuICAgICAgICAgIGNvbG9yOiBjYXRlZ29yeS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbG9yXCIpIVxuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBjb25zdCBkYXRhRW50eTogRGF0YUVudHJ5ID0ge1xuICAgICAgICB0aXRsZTogdGV4dChpdGVtKSxcbiAgICAgICAgY2xhc3M6IGl0ZW0uZ2V0QXR0cmlidXRlKFwiZGF0YS1jbGFzc1wiKSEsXG4gICAgICAgIHZhbHVlczogW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFscyA9IGl0ZW0uZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKVxuICAgICAgaWYgKHZhbHMpIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdmFscy5zcGxpdChcIixcIikpIHtcbiAgICAgICAgICBkYXRhRW50eS52YWx1ZXMucHVzaChwYXJzZUZsb2F0KHZhbCkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGF0YS5pdGVtcy5wdXNoKGRhdGFFbnR5KVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldFRvb2x0aXBDb250ZW50KGVudHJ5OiBEYXRhRW50cnksIGNhdGVnb3JpZXM6IENhdGVnb3J5W10pIHtcbiAgICBsZXQgdG9vbHRpcCA9IFwiXCJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJ5LnZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdG9vbHRpcCArPSBgJHtjYXRlZ29yaWVzW2ldLnRpdGxlfTogJHtlbnRyeS52YWx1ZXNbaV19ICR7dGhpcy5fdW5pdH1cXG5gXG4gICAgfVxuXG4gICAgcmV0dXJuIHRvb2x0aXAudHJpbSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX3JlbmRlcigpIHtcbiAgICBpZiAodGhpcy5fbGVnZW5kKSB7XG4gICAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9sZWdlbmQpXG5cbiAgICAgIGZvciAoY29uc3QgY2F0ZWdvcnkgb2YgdGhpcy5fZGF0YS5jYXRlZ29yaWVzKSB7XG4gICAgICAgIGNvbnN0IGxlZ2VuZEl0ZW0gPSBjcmVhdGVMZWdlbmRJdGVtKGNhdGVnb3J5KVxuICAgICAgICB0aGlzLl9sZWdlbmQuYXBwZW5kQ2hpbGQobGVnZW5kSXRlbSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9jaGFydClcblxuICAgIGNvbnN0IGFuaW1hdGlvblN0YWdlczogRWxlbWVudFtdW10gPSBbXVxuXG4gICAgbGV0IGxlZnRTaWRlSXRlbXMgPSBNYXRoLmZsb29yKHRoaXMuX2RhdGEuaXRlbXMubGVuZ3RoIC8gMilcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5fZGF0YS5pdGVtcykge1xuICAgICAgbGV0IGVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImxpXCIpXG5cbiAgICAgIGlmIChpdGVtLmNsYXNzKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoaXRlbS5jbGFzcylcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGlzdEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcInVsXCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19JTkRJQ0FUT1JfV1JBUFBFUilcblxuICAgICAgY29uc3Qgd3JhcHBlciA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19JTkRJQ0FUT1JfSU5ORVJfV1JBUFBFUilcbiAgICAgIGxpc3RFbGVtZW50LmFwcGVuZENoaWxkKHdyYXBwZXIpXG5cbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQobGlzdEVsZW1lbnQpXG5cbiAgICAgIGNvbnN0IHRvb2x0aXAgPSB0aGlzLl9nZXRUb29sdGlwQ29udGVudChpdGVtLCB0aGlzLl9kYXRhLmNhdGVnb3JpZXMpXG4gICAgICBpZiAodG9vbHRpcCkge1xuICAgICAgICB3cmFwcGVyXG4gICAgICAgICAgLmFkZENsYXNzKENMQVNTX1RPT0xUSVApXG4gICAgICAgICAgLmFkZENsYXNzKGxlZnRTaWRlSXRlbXMgPD0gMCA/IENMQVNTX1RPT0xUSVBfTEVGVCA6IENMQVNTX1RPT0xUSVBfUklHSFQpXG4gICAgICAgICAgLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdG9vbHRpcClcblxuICAgICAgICBpZiAoaXRlbS52YWx1ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHdyYXBwZXIuYWRkQ2xhc3MoQ0xBU1NfVE9PTFRJUF9NVUxUSUxJTkUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtLnZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBoZWlnaHQgPSAodGhpcy5fY2hhcnQub2Zmc2V0SGVpZ2h0IC8gdGhpcy5fbWF4VmFsdWUpICogaXRlbS52YWx1ZXNbaV1cblxuICAgICAgICBjb25zdCBpbmRpY2F0b3IgPSBuZXcgRG9tRWxlbWVudChcImxpXCIpXG4gICAgICAgICAgLmFkZENsYXNzKENMQVNTX0lORElDQVRPUilcbiAgICAgICAgICAuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYGhlaWdodDogJHtoZWlnaHR9cHg7YClcblxuICAgICAgICBpZiAoaGVpZ2h0ID4gMCkge1xuICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fZGF0YS5jYXRlZ29yaWVzW2ldLmNvbG9yXG4gICAgICAgICAgaWYgKGlzQ29sb3IoY29sb3IpKSB7XG4gICAgICAgICAgICBpbmRpY2F0b3Iuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYGJhY2tncm91bmQtY29sb3I6ICR7Y29sb3J9O2ApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGljYXRvci5hZGRDbGFzcyhjb2xvcilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYW5pbWF0aW9uU3RhZ2VzLmxlbmd0aCA8PSBpKSB7XG4gICAgICAgICAgICBhbmltYXRpb25TdGFnZXMucHVzaChbXSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhbmltYXRpb25TdGFnZXNbaV0ucHVzaChpbmRpY2F0b3IuZWxlbWVudClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRpY2F0b3IuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0VNUFRZKVxuICAgICAgICB9XG5cbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChpbmRpY2F0b3IpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRpdGxlRG9tRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19MQUJFTF9YKVxuICAgICAgY29uc3QgdGl0bGVFbGVtZW50ID0gdGl0bGVEb21FbGVtZW50LmVsZW1lbnQgYXMgSFRNTEVsZW1lbnRcbiAgICAgIHRpdGxlRWxlbWVudC5pbm5lclRleHQgPSBpdGVtLnRpdGxlXG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRpdGxlRG9tRWxlbWVudClcblxuICAgICAgdGhpcy5fY2hhcnQuYXBwZW5kQ2hpbGQoZWxlbWVudC5lbGVtZW50KVxuICAgICAgbGVmdFNpZGVJdGVtcyAtPSAxXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmltYXRpb25TdGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IEFOSU1BVElPTl9EVVJBVElPTiAqIGlcbiAgICAgIHRoaXMuX2FuaW1hdGVCYXJzKGFuaW1hdGlvblN0YWdlc1tpXSBhcyBIVE1MRWxlbWVudFtdLCBvZmZzZXQpXG5cbiAgICAgIGlmICh0aGlzLl9sZWdlbmQpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZUxlZ2VuZCh0aGlzLl9sZWdlbmQuY2hpbGRyZW5baV0gYXMgSFRNTEVsZW1lbnQsIG9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9hbmltYXRlQmFycyhiYXJzOiBIVE1MRWxlbWVudFtdLCBhbmltYXRpb25PZmZzZXQ6IG51bWJlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYmFyID0gYmFyc1tpXVxuICAgICAgY29uc3QgYmFySGVpZ2h0ID0gYmFyLnN0eWxlLmhlaWdodFxuICAgICAgYmFyLnN0eWxlLmhlaWdodCA9IFwiMFwiXG4gICAgICBhbmltZSh7XG4gICAgICAgIHRhcmdldHM6IGJhcnNbaV0sXG4gICAgICAgIGhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIixcbiAgICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9EVVJBVElPTixcbiAgICAgICAgZGVsYXk6IGFuaW1hdGlvbk9mZnNldFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9hbmltYXRlTGVnZW5kKGxlZ2VuZDogSFRNTEVsZW1lbnQsIGFuaW1hdGlvbk9mZnNldDogbnVtYmVyKSB7XG4gICAgbGVnZW5kLnN0eWxlLm9wYWNpdHkgPSBcIjBcIlxuICAgIGFuaW1lKHtcbiAgICAgIHRhcmdldHM6IGxlZ2VuZCxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIixcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fRFVSQVRJT04sXG4gICAgICBkZWxheTogYW5pbWF0aW9uT2Zmc2V0XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBiYXIgY2hhcnQgd2l0aCB0aGUgc3BlY2lmaWVkIGRhdGEgZGVmaW5pdGlvbnMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IC0gYmFyIGNoYXJ0IGRhdGEgZGVmaW5pdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlKGRhdGE6IENoYXJ0RGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YVxuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZXZlbnQgaGFuZGxlcnMgYW5kIGNsZWFycyByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgKHRoaXMgYXMgYW55KS5fZGF0YSA9IHVuZGVmaW5lZFxuXG4gICAgaWYgKHRoaXMuX2xlZ2VuZCkge1xuICAgICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fbGVnZW5kKTtcbiAgICAgICh0aGlzIGFzIGFueSkuX2xlZ2VuZCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZGVzdHJveSgpIGluc3RlYWQuXG4gICAqIEB0b2RvIHJlbW92ZSBpbiB2ZXJzaW9uIDIuMC4wXG4gICAqL1xuICBwdWJsaWMgZGVzdG9yeSgpIHtcbiAgICB0aGlzLmRlc3Ryb3koKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplPEhUTUxFbGVtZW50PihcIi5iYXItY2hhcnQtdmVydGljYWxcIiwgKGUpID0+IHtcbiAgICBuZXcgQmFyQ2hhcnRWZXJ0aWNhbChlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXJDaGFydFZlcnRpY2FsXG4iLCJpbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgeyB0ZXh0IH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhcnRMYWJlbCB7XG4gIHRpdGxlOiBzdHJpbmdcbiAgY29sb3I6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoYXJ0QXhpcyBleHRlbmRzIENoYXJ0TGFiZWwge1xuICB2YWx1ZTogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIENoYXJ0RGF0YSA9IENoYXJ0QXhpc1tdXG5cbmNvbnN0IFFVRVJZX0RBVEEgPSBcIi5qcy1kYXRhXCJcblxuZXhwb3J0IGZ1bmN0aW9uIHRyeUdldERhdGEoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBDaGFydERhdGEge1xuICBsZXQgZGF0YSA9IFtdXG4gIGxldCBlbGVtZW50cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9EQVRBKVxuXG4gIGZvciAobGV0IGVudHJ5IG9mIGVsZW1lbnRzKSB7XG4gICAgbGV0IHZhbHVlID0gcGFyc2VGbG9hdChlbnRyeS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpISlcbiAgICBsZXQgY29sb3IgPSBlbnRyeS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbG9yXCIpIVxuICAgIGxldCB0aXRsZSA9IHRleHQoZW50cnkpXG5cbiAgICBsZXQgaXRlbSA9IHtcbiAgICAgIHRpdGxlLFxuICAgICAgdmFsdWUsXG4gICAgICBjb2xvclxuICAgIH1cblxuICAgIGRhdGEucHVzaChpdGVtKVxuICB9XG5cbiAgcmV0dXJuIGRhdGFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFsbENoaWxkcmVuKG5vZGU6IE5vZGUpIHtcbiAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMZWdlbmRJdGVtKGRhdGE6IENoYXJ0TGFiZWwpIHtcbiAgY29uc3QgYnVsbGV0ID0gbmV3IERvbUVsZW1lbnQ8SFRNTFNwYW5FbGVtZW50PihcInNwYW5cIilcbiAgICAuYWRkQ2xhc3MoXCJidWxsZXRcIilcblxuICBpZiAoaXNDb2xvcihkYXRhLmNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgIGJ1bGxldC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgYmFja2dyb3VuZC1jb2xvcjogJHtkYXRhLmNvbG9yfTtgKVxuICB9IGVsc2Uge1xuICAgIGJ1bGxldC5hZGRDbGFzcyhkYXRhLmNvbG9yKVxuICB9XG5cbiAgY29uc3QgY2FwdGlvbiA9IG5ldyBEb21FbGVtZW50PEhUTUxTcGFuRWxlbWVudD4oXCJzcGFuXCIpXG4gICAgLnNldEh0bWwoZGF0YS50aXRsZSlcblxuICByZXR1cm4gbmV3IERvbUVsZW1lbnQ8SFRNTExJRWxlbWVudD4oXCJsaVwiKVxuICAgIC5hcHBlbmRDaGlsZChidWxsZXQpXG4gICAgLmFwcGVuZENoaWxkKGNhcHRpb24pXG4gICAgLmVsZW1lbnRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29sb3Ioc3RyOiBzdHJpbmcpIHtcbiAgY29uc3QgcGF0dGVybiA9IC9eIy9pXG4gIHJldHVybiBwYXR0ZXJuLnRlc3Qoc3RyKVxufVxuIiwiaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgeyByZW1vdmVBbGxDaGlsZHJlbiwgdHJ5R2V0RGF0YSwgaXNDb2xvciwgQ2hhcnREYXRhIH0gZnJvbSBcIi4vQ2hhcnRGdW5jdGlvbnNcIlxuaW1wb3J0IGFuaW1lIGZyb20gXCJhbmltZWpzXCJcblxuY29uc3QgUVVFUllfQ0hBUlQgPSBcIi5qcy1jaGFydFwiXG5jb25zdCBRVUVSWV9MRUdFTkQgPSBcIi5qcy1sZWdlbmRcIlxuXG5jb25zdCBEQVNIX1NFUEFSQVRPUl9XSURUSCA9IDNcbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTiA9IDE1MDBcbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTl9MRUdFTkQgPSA1MDBcblxuY29uc3QgUVVFUllfTUVUQV9USVRMRSA9IFwiLm1ldGEgLnRpdGxlXCJcbmNvbnN0IFFVRVJZX01FVEFfU1VCVElUTEUgPSBcIi5tZXRhIC5zdWJ0aXRsZVwiXG5cbi8qKlxuICogUGllIENoYXJ0IENvbXBvbmVudC5cbiAqL1xuY2xhc3MgUGllQ2hhcnQgZXh0ZW5kcyBEb21FbGVtZW50PEhUTUxFbGVtZW50PiB7XG4gIHByaXZhdGUgX2RhdGEhOiBDaGFydERhdGFcblxuICBwcml2YXRlIF9jaGFydCE6IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX2xlZ2VuZCE6IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX3RpdGxlITogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfc3VidGl0bGUhOiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX3VuaXQhOiBzdHJpbmdcbiAgcHJpdmF0ZSBfYWx3YXlzU2hvd0xlZ2VuZCE6IGJvb2xlYW5cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIFBpZSBDaGFydCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gLSByb290IGVsZW1lbnQgb2YgdGhlIGNoYXJ0LlxuICAgKiBAcGFyYW0ge0FycmF5fSAtIHBpZSBjaGFydCBkYXRhIGRlZmluaXRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQsIGRhdGE/OiBDaGFydERhdGEpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YVxuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuX2NoYXJ0ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfQ0hBUlQpISBhcyBIVE1MRWxlbWVudFxuICAgIHRoaXMuX2xlZ2VuZCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0xFR0VORCkhIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fdGl0bGUgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9NRVRBX1RJVExFKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl9zdWJ0aXRsZSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX01FVEFfU1VCVElUTEUpISBhcyBIVE1MRWxlbWVudFxuXG4gICAgdGhpcy5fdW5pdCA9IHRoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS11bml0XCIpIHx8IFwiXCJcbiAgICB0aGlzLl9hbHdheXNTaG93TGVnZW5kID0gdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRhdGEtYWx3YXlzLXNob3ctbGVnZW5kXCIpXG5cbiAgICBpZiAoIXRoaXMuX2RhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0cnlHZXREYXRhKHRoaXMuZWxlbWVudClcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXIoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9yZW5kZXIoKSB7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLl9kYXRhLnJlZHVjZSgoYSwgYikgPT4gYSArIGIudmFsdWUsIDApXG4gICAgY29uc3QgciA9IDE2XG4gICAgY29uc3QgZGFzaFRvdGFsID0gKDIgKiByICogTWF0aC5QSSlcblxuICAgIGxldCBjdXJyZW50Um90YXRlID0gOVxuXG4gICAgLy8gQ2xlYW51cFxuICAgIHJlbW92ZUFsbENoaWxkcmVuKHRoaXMuX2NoYXJ0KVxuXG4gICAgaWYgKHRoaXMuX2xlZ2VuZCkge1xuICAgICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fbGVnZW5kKVxuICAgIH1cblxuICAgIGxldCBwZXJjZW50YWdlQWRqdXN0VG90YWwgPSAwXG4gICAgbGV0IHBlcmNlbnRhZ2VBZGp1c3QgPSAwXG4gICAgY29uc3Qgc2VwYXJhdG9yUGVyY2VudGFnZSA9IERBU0hfU0VQQVJBVE9SX1dJRFRIIC8gMTAwXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5fZGF0YVtpXVxuXG4gICAgICBjb25zdCBwZXJjZW50YWdlID0gZW50cnkudmFsdWUgLyB0b3RhbFxuICAgICAgaWYgKHBlcmNlbnRhZ2UgPCBzZXBhcmF0b3JQZXJjZW50YWdlKSB7XG4gICAgICAgIHBlcmNlbnRhZ2VBZGp1c3RUb3RhbCArPSAoc2VwYXJhdG9yUGVyY2VudGFnZSAtIHBlcmNlbnRhZ2UpXG4gICAgICAgIHBlcmNlbnRhZ2VBZGp1c3QrK1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwZXJjZW50YWdlQWRqdXN0ID4gMCkge1xuICAgICAgcGVyY2VudGFnZUFkanVzdCA9IHBlcmNlbnRhZ2VBZGp1c3RUb3RhbCAvICh0aGlzLl9kYXRhLmxlbmd0aCAtIHBlcmNlbnRhZ2VBZGp1c3QpXG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IGFuaW1lLnRpbWVsaW5lKClcblxuICAgIGxldCBhbmltYXRpb25PZmZzZXQgPSAwXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IHRoaXMuX2RhdGFbaV1cblxuICAgICAgY29uc3QgZGlzcGxheVBlcmNlbnRhZ2UgPSBlbnRyeS52YWx1ZSAvIHRvdGFsXG4gICAgICBjb25zdCBwZXJjZW50YWdlID0gTWF0aC5tYXgoc2VwYXJhdG9yUGVyY2VudGFnZSwgZGlzcGxheVBlcmNlbnRhZ2UgLSBwZXJjZW50YWdlQWRqdXN0KVxuXG4gICAgICBsZXQgZGFzaFdpZHRoID0gKHBlcmNlbnRhZ2UgKiBkYXNoVG90YWwpIC0gREFTSF9TRVBBUkFUT1JfV0lEVEhcblxuICAgICAgbGV0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpXG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBcIjAgMCAzNCAzNFwiKVxuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJpbWdcIilcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIiwgXCJ0aXRsZSBkZXNjXCIpXG5cbiAgICAgIGxldCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwidGl0bGVcIilcbiAgICAgIHRpdGxlLnNldEF0dHJpYnV0ZShcImlkXCIsIFwidGl0bGVcIilcbiAgICAgIHRpdGxlLmlubmVySFRNTCA9IGBQaWUgY2hhcnQgc2VnbWVudCAke01hdGguZmxvb3IoZGlzcGxheVBlcmNlbnRhZ2UgKiAxMDApfSVgXG5cbiAgICAgIGxldCBkZXNjcmlwdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZGVzY1wiKVxuICAgICAgZGVzY3JpcHRpb24uc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJkZXNjXCIpXG4gICAgICBkZXNjcmlwdGlvbi5pbm5lckhUTUwgPSBgJHtlbnRyeS50aXRsZX06ICR7ZW50cnkudmFsdWV9YFxuXG4gICAgICBsZXQgY2lyY2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJjaXJjbGVcIilcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeFwiLCBcIjE3XCIpXG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiY3lcIiwgXCIxN1wiKVxuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInJcIiwgU3RyaW5nKHIpKVxuXG4gICAgICBpZiAoaXNDb2xvcihlbnRyeS5jb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBgJHtlbnRyeS5jb2xvcn1gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGVudHJ5LmNvbG9yKVxuICAgICAgfVxuXG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKVxuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGB0cmFuc2Zvcm06IHJvdGF0ZSgke2N1cnJlbnRSb3RhdGV9ZGVnKTtgKVxuXG4gICAgICBzdmcuYXBwZW5kQ2hpbGQodGl0bGUpXG4gICAgICBzdmcuYXBwZW5kQ2hpbGQoZGVzY3JpcHRpb24pXG4gICAgICBzdmcuYXBwZW5kQ2hpbGQoY2lyY2xlKVxuICAgICAgdGhpcy5fY2hhcnQuYXBwZW5kQ2hpbGQoc3ZnKVxuXG4gICAgICBsZXQgYW5pbWF0aW9uRHVyYXRpb24gPSBBTklNQVRJT05fRFVSQVRJT04gKiBwZXJjZW50YWdlXG4gICAgICBjaXJjbGUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiXG5cbiAgICAgIGxldCBjb3VudGVyID0geyB2YXI6IDAuNSB9XG4gICAgICBhbmltYXRpb25zLmFkZCh7XG4gICAgICAgIHRhcmdldHM6IGNvdW50ZXIsXG4gICAgICAgIHZhcjogZGFzaFdpZHRoLFxuICAgICAgICBiZWdpbjogKCkgPT4ge1xuICAgICAgICAgIGNpcmNsZS5zdHlsZS5kaXNwbGF5ID0gXCJcIlxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6ICgpID0+IHtcbiAgICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBgJHtjb3VudGVyLnZhcn0gJHtkYXNoVG90YWx9YClcbiAgICAgICAgfSxcbiAgICAgICAgZHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICBlYXNpbmc6IFwiZWFzZUluUXVpbnRcIlxuICAgICAgfSlcblxuICAgICAgLy8gTGVnZW5kXG4gICAgICBpZiAodGhpcy5fbGVnZW5kICYmICh0aGlzLl9kYXRhLmxlbmd0aCA+IDEpIHx8IHRoaXMuX2Fsd2F5c1Nob3dMZWdlbmQpIHtcbiAgICAgICAgbGV0IGJ1bGxldCA9IG5ldyBEb21FbGVtZW50KFwic3BhblwiKVxuICAgICAgICAgIC5hZGRDbGFzcyhcImJ1bGxldFwiKVxuXG4gICAgICAgIGlmIChpc0NvbG9yKGVudHJ5LmNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGJ1bGxldC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgYmFja2dyb3VuZC1jb2xvcjogJHtlbnRyeS5jb2xvcn1gKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1bGxldC5hZGRDbGFzcyhlbnRyeS5jb2xvcilcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNhcHRpb24gPSBuZXcgRG9tRWxlbWVudChcInNwYW5cIilcbiAgICAgICAgY29uc3QgY2FwdGlvbkVsZW1lbnQgPSBjYXB0aW9uLmVsZW1lbnQgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgY2FwdGlvbkVsZW1lbnQuaW5uZXJUZXh0ID0gZW50cnkudGl0bGVcblxuICAgICAgICBsZXQgbGVnZW5kSXRlbSA9IG5ldyBEb21FbGVtZW50KFwibGlcIilcbiAgICAgICAgICAuYXBwZW5kQ2hpbGQoYnVsbGV0KVxuICAgICAgICAgIC5hcHBlbmRDaGlsZChjYXB0aW9uKVxuXG4gICAgICAgIHRoaXMuX2xlZ2VuZC5hcHBlbmRDaGlsZChsZWdlbmRJdGVtLmVsZW1lbnQpXG5cbiAgICAgICAgdGhpcy5fYW5pbWF0ZUxlZ2VuZChsZWdlbmRJdGVtLmVsZW1lbnQgYXMgSFRNTEVsZW1lbnQsIGFuaW1hdGlvbk9mZnNldClcbiAgICAgIH1cbiAgICAgIGFuaW1hdGlvbk9mZnNldCArPSBhbmltYXRpb25EdXJhdGlvblxuXG4gICAgICBjdXJyZW50Um90YXRlICs9ICgzNjAgKiBwZXJjZW50YWdlKVxuXG4gICAgICBpZiAoaSA9PT0gdGhpcy5fZGF0YS5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMuX3RpdGxlLmlubmVySFRNTCA9IGAke2VudHJ5LnZhbHVlfSAke3RoaXMuX3VuaXR9YFxuICAgICAgICB0aGlzLl9zdWJ0aXRsZS5pbm5lckhUTUwgPSBlbnRyeS50aXRsZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2FuaW1hdGVMZWdlbmQobGVnZW5kSXRlbTogSFRNTEVsZW1lbnQsIGFuaW1hdGlvbk9mZnNldDogbnVtYmVyKSB7XG4gICAgbGVnZW5kSXRlbS5zdHlsZS5vcGFjaXR5ID0gXCIwXCJcbiAgICBhbmltZSh7XG4gICAgICB0YXJnZXRzOiBsZWdlbmRJdGVtLFxuICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9EVVJBVElPTl9MRUdFTkQsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgZWFzaW5nOiBcImVhc2VJbk91dFF1aW50XCIsXG4gICAgICBkZWxheTogYW5pbWF0aW9uT2Zmc2V0LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgbGVnZW5kSXRlbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcIm9wYWNpdHlcIilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHBpZSBjaGFydCB3aXRoIHRoZSBzcGVjaWZpZWQgZGF0YSBkZWZpbml0aW9ucy5cbiAgICogQHBhcmFtIHtBcnJheX0gLSBwaWUgY2hhcnQgZGF0YSBkZWZpbml0aW9ucy5cbiAgICovXG4gIHB1YmxpYyB1cGRhdGUoZGF0YTogQ2hhcnREYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhXG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyBhbmQgY2xlYXJzIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAodGhpcyBhcyBhbnkpLl9kYXRhID0gdW5kZWZpbmVkO1xuICAgICh0aGlzIGFzIGFueSkuX3RpdGxlID0gdW5kZWZpbmVkO1xuICAgICh0aGlzIGFzIGFueSkuX3N1YnRpdGxlID0gdW5kZWZpbmVkO1xuICAgICh0aGlzIGFzIGFueSkuX3VuaXQgPSB1bmRlZmluZWRcblxuICAgIHJlbW92ZUFsbENoaWxkcmVuKHRoaXMuX2NoYXJ0KTtcbiAgICAodGhpcyBhcyBhbnkpLl9jaGFydCA9IHVuZGVmaW5lZFxuXG4gICAgaWYgKHRoaXMuX2xlZ2VuZCkge1xuICAgICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fbGVnZW5kKTtcbiAgICAgICh0aGlzIGFzIGFueSkuX2xlZ2VuZCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZGVzdHJveSgpIGluc3RlYWQuXG4gICAqIEB0b2RvIHJlbW92ZSBpbiB2ZXJzaW9uIDIuMC4wXG4gICAqL1xuICBwdWJsaWMgZGVzdG9yeSgpIHtcbiAgICB0aGlzLmRlc3Ryb3koKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplPEhUTUxFbGVtZW50PihcIi5waWUtY2hhcnRcIiwgKGUpID0+IHtcbiAgICBuZXcgUGllQ2hhcnQoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgUGllQ2hhcnRcbiIsImltcG9ydCB7IHByZXZlbnREZWZhdWx0IH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgeyBhZGRDbGFzcywgaGFzQ2xhc3MsIHJlbW92ZUNsYXNzLCBpc0hpZGRlbiB9IGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBDTEFTU19PUEVOID0gXCJpcy1vcGVuXCJcblxuY29uc3QgQU5JTUFUSU9OX09QRU4gPSAzMDBcblxuLyoqXG4gKiBUaGUgQ29sbGFwc2UgY29tcG9uZW50LlxuICovXG5jbGFzcyBDb2xsYXBzZSBleHRlbmRzIERvbUVsZW1lbnQge1xuICBwcml2YXRlIF9oaWRkZW5JbmRpY2F0b3IhOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9jb2xsYXBzaWJsZUVsZW1lbnRzITogTm9kZUxpc3RPZjxIVE1MRWxlbWVudD5cbiAgcHJpdmF0ZSBfY2xpY2tIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIENvbGxhcHNlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtEb21FbGVtZW50fSAtIFRoZSByb290IGVsZW1lbnQgb2YgdGhlIENvbGxhcHNlIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX2NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgQ29sbGFwc2UgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIGxldCBkYXRhVGFyZ2V0ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdGFyZ2V0XCIpXG4gICAgaWYgKGRhdGFUYXJnZXQgPT09IG51bGwgfHwgZGF0YVRhcmdldCA9PT0gXCJcIikge1xuXG4gICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICBjb25zb2xlLmVycm9yKFwiQSBjb2xsYXBzaWJsZSBlbGVtZW50IHJlcXVpcmVzIGEgJ2RhdGEtdGFyZ2V0JyB0aGF0IHNwZWNpZmllcyB0aGUgZWxlbWVudCB0byBjb2xsYXBzZVwiKVxuICAgICAgY29uc29sZS5pbmZvKHRoaXMuZWxlbWVudClcbiAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgaGlkZGVuVGFyZ2V0ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtaGlkZGVuXCIpXG4gICAgaWYgKGhpZGRlblRhcmdldCAhPT0gbnVsbCAmJiBoaWRkZW5UYXJnZXQgIT09IFwiXCIpIHtcbiAgICAgIHRoaXMuX2hpZGRlbkluZGljYXRvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaGlkZGVuVGFyZ2V0KSEgYXMgSFRNTEVsZW1lbnRcbiAgICB9XG5cbiAgICB0aGlzLl9jb2xsYXBzaWJsZUVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChkYXRhVGFyZ2V0KVxuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVDbGljayhldmVudDogRXZlbnQpIHtcbiAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICB0aGlzLnRvZ2dsZSgpXG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgY29sbGFwc2VpYmxlLlxuICAgKi9cbiAgcHVibGljIHRvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy5faGlkZGVuSW5kaWNhdG9yICYmIGlzSGlkZGVuKHRoaXMuX2hpZGRlbkluZGljYXRvciwgZmFsc2UpID09PSB0cnVlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaGFzQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKSA9PT0gZmFsc2UpIHtcbiAgICAgIGFkZENsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTilcblxuICAgICAgZm9yIChsZXQgcyBvZiB0aGlzLl9jb2xsYXBzaWJsZUVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMuX29wZW5Db2xsYXBzZShzKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX09QRU4pXG5cbiAgICAgIGZvciAobGV0IHMgb2YgdGhpcy5fY29sbGFwc2libGVFbGVtZW50cykge1xuICAgICAgICB0aGlzLl9jbG9zZUNvbGxhcHNlKHMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9vcGVuQ29sbGFwc2UoZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgYW5pbWUucmVtb3ZlKGVsKVxuXG4gICAgZWwuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuXG4gICAgYW5pbWUoe1xuICAgICAgdGFyZ2V0czogZWwsXG4gICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX09QRU4sXG4gICAgICBoZWlnaHQ6IGVsLnNjcm9sbEhlaWdodCArIFwicHhcIixcbiAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgY29uc3QgZG9tRWwgPSBuZXcgRG9tRWxlbWVudChlbClcbiAgICAgICAgZG9tRWwuYWRkQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICAgICAgZG9tRWwuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gc2V0IGFyaWEgZXhwYW5kZWRcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jbG9zZUNvbGxhcHNlKGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGFuaW1lLnJlbW92ZShlbClcblxuICAgIGFuaW1lKHtcbiAgICAgIHRhcmdldHM6IGVsLFxuICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9PUEVOLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgZWFzaW5nOiBcImN1YmljQmV6aWVyKDAuNTUwLCAwLjA4NSwgMC4zMjAsIDEpXCIsXG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBkb21FbCA9IG5ldyBEb21FbGVtZW50KGVsKVxuICAgICAgICBkb21FbC5yZW1vdmVDbGFzcyhDTEFTU19PUEVOKVxuICAgICAgICBkb21FbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBzZXQgYXJpYSBleHBhbmRlZFxuICAgIGVsLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGV2ZW50IGhhbmRsZXJzIGFuZCBjbGVhcnMgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICh0aGlzIGFzIGFueSkuX2NvbGxhcHNpYmxlRWxlbWVudHMgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMgYXMgYW55KS5fY2xpY2tIYW5kbGVyKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgICB9XG5cbiAgICAodGhpcyBhcyBhbnkpLmVsZW1lbnQgPSBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIGxldCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS10b2dnbGU9J2NvbGxhcHNlJ11cIilcbiAgZm9yIChsZXQgZSBvZiBlbGVtZW50cykge1xuICAgIGlmIChlLmdldEF0dHJpYnV0ZShcImRhdGEtaW5pdFwiKSA9PT0gXCJhdXRvXCIpIHtcbiAgICAgIG5ldyBDb2xsYXBzZShlIGFzIEhUTUxFbGVtZW50KVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2xsYXBzZVxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgeyBwYXJlbnRXaXRoQ2xhc3MsIGdldFJvb3RFbGVtZW50IH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IENMQVNTX0JPUkRFUiA9IFwiZW1wdHktc3RhdGVfX2JvcmRlclwiXG5jb25zdCBDTEFTU19CT1JERVJfTU9EQUwgPSBcImVtcHR5LXN0YXRlX19ib3JkZXItLW1vZGFsXCJcbmNvbnN0IENMQVNTX0FDVElWRSA9IFwiaXMtYWN0aXZlXCJcbmNvbnN0IENMQVNTX0hBU0ZJTEVTID0gXCJoYXMtZmlsZXNcIlxuY29uc3QgQ0xBU1NfTU9EQUwgPSBcImVtcHR5LXN0YXRlLS1tb2RhbFwiXG5jb25zdCBDTEFTU19NT0RBTF9DT05URU5UID0gXCJtb2RhbF9fY29udGVudFwiXG5cbmNvbnN0IFFVRVJZX01PREFMX0JPRFkgPSBcIi5tb2RhbF9fYm9keVwiXG5jb25zdCBRVUVSWV9GSUxFID0gXCJpbnB1dFt0eXBlPSdmaWxlJ11cIlxuXG4vKipcbiAqIEVtcHR5IHN0YXRlIHBhdHRlcm5cbiAqL1xuY2xhc3MgRW1wdHlTdGF0ZSBleHRlbmRzIERvbUVsZW1lbnQge1xuICBwcml2YXRlIF9ib3JkZXIhOiBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PlxuXG4gIHByaXZhdGUgX2ZpbGVJbnB1dDogSFRNTElucHV0RWxlbWVudFxuICBwcml2YXRlIF9idXR0b246IEhUTUxMYWJlbEVsZW1lbnRcblxuICBwcml2YXRlIF9kcmFnQXJlYSE6IEVsZW1lbnRcblxuICBwcml2YXRlIF9maWxlQ2hhbmdlZEhhbmRsZXI6IChldmVudDogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfcHJldmVudEV2ZW50c0hhbmRsZXI6IChldmVudDogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfZHJhZ0VudGVySGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9kcmFnTGVhdmVIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2Ryb3BIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfaXNEcmFnZ2luZzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyB0aGUgRW1wdHktU3RhdGUgcGF0dGVybiBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gLSByb290IGVsZW1lbnQgb2YgdGhlIGVtcHR5LXN0YXRlIHBhdHRlcm4uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX2ZpbGVJbnB1dCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0ZJTEUpISBhcyBIVE1MSW5wdXRFbGVtZW50XG4gICAgdGhpcy5fYnV0dG9uID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJsYWJlbFwiKSFcblxuICAgIHRoaXMuX2ZpbGVDaGFuZ2VkSGFuZGxlciA9IHRoaXMuX2hhbmRsZUZpbGVDaGFuZ2VkLmJpbmQodGhpcylcbiAgICB0aGlzLl9wcmV2ZW50RXZlbnRzSGFuZGxlciA9IHRoaXMuX3ByZXZlbnREcmFnRXZlbnRzLmJpbmQodGhpcylcbiAgICB0aGlzLl9kcmFnRW50ZXJIYW5kbGVyID0gdGhpcy5faGFuZGxlRHJhZ0VudGVyLmJpbmQodGhpcylcbiAgICB0aGlzLl9kcmFnTGVhdmVIYW5kbGVyID0gdGhpcy5faGFuZGxlRHJhZ0xlYXZlLmJpbmQodGhpcylcbiAgICB0aGlzLl9kcm9wSGFuZGxlciA9IHRoaXMuX2hhbmRsZURyb3AuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5oYXNDbGFzcyhDTEFTU19NT0RBTCkpIHtcbiAgICAgIC8vIGhhbmRsZSBtb2RhbCBkaWFsb2dzXG4gICAgICB0aGlzLl9kcmFnQXJlYSA9IHBhcmVudFdpdGhDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX01PREFMX0NPTlRFTlQpIVxuICAgICAgbGV0IGJvcmRlckFyZWEgPSB0aGlzLl9kcmFnQXJlYS5xdWVyeVNlbGVjdG9yKFFVRVJZX01PREFMX0JPRFkpIVxuICAgICAgYm9yZGVyQXJlYS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInBvaW50ZXItZXZlbnRzOiBub25lO1wiKVxuXG4gICAgICB0aGlzLl9ib3JkZXIgPSBuZXcgRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD4oXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX0JPUkRFUilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX0JPUkRFUl9NT0RBTClcblxuICAgICAgYm9yZGVyQXJlYS5hcHBlbmRDaGlsZCh0aGlzLl9ib3JkZXIuZWxlbWVudClcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3JtYWwgbW9kYWwgZGlhbG9nXG4gICAgICB0aGlzLl9kcmFnQXJlYSA9IHRoaXMuZWxlbWVudFxuICAgICAgbGV0IGJvcmRlckFyZWEgPSBnZXRSb290RWxlbWVudCgpXG5cbiAgICAgIHRoaXMuX2JvcmRlciA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfQk9SREVSKVxuXG4gICAgICBpZiAoIWJvcmRlckFyZWEucXVlcnlTZWxlY3RvcihgLiR7Q0xBU1NfQk9SREVSfWApKSB7XG4gICAgICAgIGJvcmRlckFyZWEuYXBwZW5kQ2hpbGQodGhpcy5fYm9yZGVyLmVsZW1lbnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZm9ybSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiZm9ybVwiKSFcblxuICAgIGZvciAobGV0IGV2ZW50IG9mIFsgXCJkcmFnXCIsIFwiZHJhZ3N0YXJ0XCIsIFwiZHJhZ2VuZFwiLCBcImRyYWdvdmVyXCIsIFwiZHJhZ2VudGVyXCIsIFwiZHJhZ2xlYXZlXCIsIFwiZHJvcFwiIF0pIHtcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLl9wcmV2ZW50RXZlbnRzSGFuZGxlcilcbiAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5fcHJldmVudEV2ZW50c0hhbmRsZXIpXG4gICAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLl9wcmV2ZW50RXZlbnRzSGFuZGxlcilcbiAgICB9XG5cbiAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgdGhpcy5fZHJhZ0VudGVySGFuZGxlcilcbiAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2VudGVyXCIsIHRoaXMuX2RyYWdFbnRlckhhbmRsZXIpXG5cbiAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2xlYXZlXCIsIHRoaXMuX2RyYWdMZWF2ZUhhbmRsZXIpXG4gICAgdGhpcy5fZHJhZ0FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbmRcIiwgdGhpcy5fZHJhZ0xlYXZlSGFuZGxlcilcbiAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCB0aGlzLl9kcmFnTGVhdmVIYW5kbGVyKVxuXG4gICAgdGhpcy5fZHJhZ0FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgdGhpcy5fZHJvcEhhbmRsZXIpXG4gICAgdGhpcy5fZmlsZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5fZmlsZUNoYW5nZWRIYW5kbGVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9wcmV2ZW50RHJhZ0V2ZW50cyhlOiBFdmVudCkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVEcmFnRW50ZXIoKSB7XG4gICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgPT09IHRydWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlXG4gICAgdGhpcy5fYnV0dG9uLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwicG9pbnRlci1ldmVudHM6IG5vbmU7XCIpXG5cbiAgICB0aGlzLmFkZENsYXNzKENMQVNTX0FDVElWRSlcbiAgICB0aGlzLl9ib3JkZXIuYWRkQ2xhc3MoQ0xBU1NfQUNUSVZFKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVEcmFnTGVhdmUoKSB7XG4gICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2VcbiAgICB0aGlzLl9idXR0b24uc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoQ0xBU1NfQUNUSVZFKVxuICAgIHRoaXMuX2JvcmRlci5yZW1vdmVDbGFzcyhDTEFTU19BQ1RJVkUpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZURyb3AoZTogRXZlbnQpIHtcbiAgICBjb25zdCBkcmFnRXZlbnQgPSBlIGFzIERyYWdFdmVudFxuICAgICh0aGlzLl9maWxlSW5wdXQgYXMgYW55KS5maWxlcyA9IGRyYWdFdmVudC5kYXRhVHJhbnNmZXIhLmZpbGVzXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUZpbGVDaGFuZ2VkKCkge1xuICAgIGxldCBmaWxlcyA9IHRoaXMuX2ZpbGVJbnB1dC5maWxlc1xuXG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfSEFTRklMRVMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoQ0xBU1NfSEFTRklMRVMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBmaWxlcy5cbiAgICovXG4gIGdldCBmaWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZUlucHV0LmZpbGVzXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIuZW1wdHktc3RhdGVcIiwgKGUpID0+IHtcbiAgICBuZXcgRW1wdHlTdGF0ZShlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBFbXB0eVN0YXRlXG4iLCJpbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCBwcmV2ZW50RGVmYXVsdCB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgeyBlbXB0eSwgYWRkQ2xhc3MsIHJlbW92ZUNsYXNzLCBoYXNDbGFzcyB9IGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0ICogYXMgSW5wdXRzIGZyb20gXCIuLi9JbnB1dHNcIlxuXG5jb25zdCBRVUVSWV9EUk9QRE9XTiA9IFwiLmpzLWF1dG9jb21wbGV0ZVwiXG5jb25zdCBDTEFTU19SRVNVTFQgPSBcImF1dG9jb21wbGV0ZV9fcmVzdWx0XCJcbmNvbnN0IENMQVNTX09QRU4gPSBcImlzLW9wZW5cIlxuY29uc3QgQ0xBU1NfSE9WRVIgPSBcImpzLWhvdmVyXCJcbmNvbnN0IEFUVFJJQlVURV9WQUxVRSA9IFwiZGF0YS12YWx1ZVwiXG5cbmNvbnN0IFRJTUVPVVRfQkxVUiA9IDQwMFxuXG5leHBvcnQgaW50ZXJmYWNlIFNvdXJjZSB7XG4gIChcbiAgICB0ZXJtOiBzdHJpbmcsXG4gICAgY2FsbGJhY2s6IChtYXRjaGVzOiBzdHJpbmdbXSwgdGVybXVzZWQ6IHN0cmluZykgPT4gdm9pZFxuICApOiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0b2NvbXBsZXRlQ29uZmlnIHtcbiAgbWluQ2hhcnM6IG51bWJlclxuICBzb3VyY2U6IFNvdXJjZVxufVxuXG4vKipcbiAqIEF1dG9jb21wbGV0ZSBjb21wb25lbnRcbiAqIEBmaXJlcyBBdXRvY29tcGxldGUjY2hhbmdlXG4gKi9cbmNsYXNzIEF1dG9jb21wbGV0ZSBleHRlbmRzIERvbUVsZW1lbnQ8SFRNTEVsZW1lbnQ+IHtcbiAgcHJpdmF0ZSBfc291cmNlITogU291cmNlXG4gIHByaXZhdGUgX21pbkNoYXJzITogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnRcbiAgcHJpdmF0ZSBfc3VnZ2VzdGlvbkxpc3QhOiBIVE1MVUxpc3RFbGVtZW50XG4gIHByaXZhdGUgX2Ryb3Bkb3duOiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX2NsaWNrSGFuZGxlcjogKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3dpbmRvd0NsaWNrSGFuZGxlcjogKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2tleVVwSGFuZGxlcjogKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2tleURvd25IYW5kbGVyOiAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfYmx1ckhhbmRsZXI6IChldmVudDogRXZlbnQpID0+IHZvaWRcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MRWxlbWVudCwgY29uZmlndXJhdGlvbj86IEF1dG9jb21wbGV0ZUNvbmZpZykge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9pbnB1dCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiaW5wdXRcIikhXG4gICAgdGhpcy5fZHJvcGRvd24gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9EUk9QRE9XTikhIGFzIEhUTUxFbGVtZW50XG5cbiAgICAvLyBTZXR1cCBldmVudCBjb250ZXh0XG4gICAgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZVdpbmRvd0NsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9rZXlVcEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlVcC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fa2V5RG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlEb3duLmJpbmQodGhpcylcbiAgICB0aGlzLl9ibHVySGFuZGxlciA9IHRoaXMuX2hhbmRsZUJsdXIuYmluZCh0aGlzKVxuXG4gICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHRoaXMuX21pbkNoYXJzID0gY29uZmlndXJhdGlvbi5taW5DaGFyc1xuICAgICAgdGhpcy5fc291cmNlID0gY29uZmlndXJhdGlvbi5zb3VyY2VcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX21pbkNoYXJzIHx8IHRoaXMuX21pbkNoYXJzIDwgMCkge1xuICAgICAgdGhpcy5fbWluQ2hhcnMgPSAyXG4gICAgfVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIEF1dG9jb21wbGV0ZSBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5fY2xlYXJTdWdnZXN0aW9ucygpXG5cbiAgICBpZiAodGhpcy5faW5wdXQuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlKClcbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlIGJyb3dzZXIgYXV0b2ZpbGxcbiAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVcIiwgXCJvZmZcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgQXV0b2NvbXBsZXRlIGNvbXBvbmVudCBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKiBAY2FsbGJhY2sgQXV0b2NvbXBsZXRlflN1Z2dlc3RcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHRlcm0gLSBUaGUgY3VycmVudCBzZWFyY2ggdGVybS5cbiAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gbWF0Y2hlcyAtIFRoZSBsaXN0IG9mIG1hdGNoaW5nIHN0cmluZ3MuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgQXV0b2NvbXBsZXRlIGNvbXBvbmVudCBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKiBAY2FsbGJhY2sgQXV0b2NvbXBsZXRlflNvdXJjZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gdGVybSAtIFRoZSBjdXJyZW50IHNlYXJjaCB0ZXJtLlxuICAgKiBAcHJvcGVydHkge0F1dG9jb21wbGV0ZX5TdWdnZXN0fSBzdWdnZXN0IC0gVGhlIGF1dG9jb21wbGV0ZSBjYWxsYmFjayBmdW5jdGlvbiB0byByZXBvcnQgdGhlIHJlc3VsdHMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgQXV0b2NvbXBsZXRlIGNvbXBvbmVudCBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBBdXRvY29tcGxldGV+Q29uZmlnXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtaW5DaGFycyAtIFRoZSBtaW5pbWFsIHJlcXVpcmVkIGNoYXJhY3RlcnMgdG8gc3RhcnQgcXVlcnlpbmcgZm9yIGF1dG9jb21wbGV0ZSBtYXRjaGVzLlxuICAgKiBAcHJvcGVydHkge0F1dG9jb21wbGV0ZX5Tb3VyY2V9IHNvdXJjZSAtIFRoZSBhdXRvY29tcGxldGUgc291cmNlIGZ1bmN0aW9uLlxuICAgKi9cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYXV0b2NvbXBsZXRlIGNvbXBvbmVudCBjb25maWd1cmF0aW9uIGZvciB0aGUgY3VycmVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0F1dG9jb21wbGV0ZX5Db25maWd9IGNvbmZpZ3VyYXRpb24gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgY29uZmlndXJlKGNvbmZpZ3VyYXRpb24/OiBBdXRvY29tcGxldGVDb25maWcpIHtcbiAgICBpZiAoIWNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjb25maWd1cmF0aW9uLm1pbkNoYXJzKSB7XG4gICAgICB0aGlzLl9taW5DaGFycyA9IE1hdGgubWluKGNvbmZpZ3VyYXRpb24ubWluQ2hhcnMsIDEpXG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZ3VyYXRpb24uc291cmNlKSB7XG4gICAgICB0aGlzLl9zb3VyY2UgPSBjb25maWd1cmF0aW9uLnNvdXJjZVxuICAgIH1cblxuICAgIHRoaXMuX2NsZWFyU3VnZ2VzdGlvbnMoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdCBjb250cm9sIHRvIHRoZSBlbmFibGVkIHN0YXRlLlxuICAgKi9cbiAgcHVibGljIGVuYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKVxuXG4gICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMuX2tleVVwSGFuZGxlcilcbiAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlEb3duSGFuZGxlcilcbiAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9ibHVySGFuZGxlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZWxlY3QgY29udHJvbCB0byB0aGUgZGlzYWJsZWQgc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgZGlzYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcInRydWVcIilcblxuICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLl9rZXlVcEhhbmRsZXIpXG4gICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5RG93bkhhbmRsZXIpXG4gICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fYmx1ckhhbmRsZXIpXG5cbiAgICB0aGlzLmNsb3NlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgY29tcG9uZW50IGFuZCBmcmVlcyBhbGwgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuXG4gICAgKHRoaXMgYXMgYW55KS5fa2V5VXBIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICh0aGlzIGFzIGFueSkuX2tleURvd25IYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICh0aGlzIGFzIGFueSkuX3dpbmRvd0NsaWNrSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAodGhpcyBhcyBhbnkpLl9ibHVySGFuZGxlciA9IHVuZGVmaW5lZDtcblxuICAgICh0aGlzIGFzIGFueSkuX2lucHV0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBzdWdnZXN0aW9ucyBkcm9wZG93bi5cbiAgICovXG4gIHB1YmxpYyBvcGVuKCkge1xuICAgIHRoaXMuX2Ryb3Bkb3duLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG5cbiAgICB0aGlzLmFkZENsYXNzKENMQVNTX09QRU4pXG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIHN1Z2dlc3Rpb25zIGRyb3Bkb3duLlxuICAgKi9cbiAgcHVibGljIGNsb3NlKCkge1xuICAgIHRoaXMuX2Ryb3Bkb3duLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG5cbiAgICB0aGlzLnJlbW92ZUNsYXNzKENMQVNTX09QRU4pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIGlucHV0IGZpZWxkLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdmFsdWUgb2YgdGhlIGlucHV0IGZpZWxkLlxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dC52YWx1ZVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVDbGljayhldmVudDogTW91c2VFdmVudCkge1xuICAgIGlmICghdGhpcy5faXNEcm9wZG93blRhcmdldChldmVudC50YXJnZXQgYXMgTm9kZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBjdXJyZW50ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50XG4gICAgd2hpbGUgKGN1cnJlbnQubm9kZU5hbWUgIT09IFwiTElcIiAmJiBjdXJyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnRcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudC5ub2RlTmFtZSA9PT0gXCJMSVwiKSB7XG4gICAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICAgIHRoaXMuX3NlbGVjdEl0ZW0oY3VycmVudClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUJsdXIoKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9LCBUSU1FT1VUX0JMVVIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUtleVVwKGV2dDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGxldCBrZXljb2RlID0gZXZ0LndoaWNoIHx8IGV2dC5rZXlDb2RlXG5cbiAgICBpZiAoSW5wdXRzLmNvbnRhaW5zS2V5KGtleWNvZGUsIFsgSW5wdXRzLktFWV9BUlJPV19VUCwgSW5wdXRzLktFWV9BUlJPV19ET1dOLCBJbnB1dHMuS0VZX0VOVEVSLCBJbnB1dHMuS0VZX1RBQiBdKSkge1xuICAgICAgLy8gRG8gbm90IGhhbmRsZSB0aGVzZSBldmVudHMgb24ga2V5dXBcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2dClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IGV2dC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnRcblxuICAgIGlmIChldnQuY3VycmVudFRhcmdldCAmJiB0YXJnZXQudmFsdWUgJiYgdGFyZ2V0LnZhbHVlLmxlbmd0aCA+PSB0aGlzLl9taW5DaGFycykge1xuICAgICAgdGhpcy5fZ2V0U3VnZ2VzdGlvbih0YXJnZXQudmFsdWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlS2V5RG93bihldnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBsZXQga2V5Y29kZSA9IGV2dC53aGljaCB8fCBldnQua2V5Q29kZVxuICAgIGNvbnN0IGlzT3BlbiA9IGhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTilcblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0VTQ0FQRSAmJiBpc09wZW4gPT09IHRydWUpIHtcbiAgICAgIC8vIGhhbmRsZSBFc2NhcGUga2V5IChFU0MpXG4gICAgICB0aGlzLmNsb3NlKClcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2dClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc09wZW4gPT09IHRydWUgJiYgSW5wdXRzLmNvbnRhaW5zS2V5KGtleWNvZGUsIFsgSW5wdXRzLktFWV9FTlRFUiwgSW5wdXRzLktFWV9UQUIgXSkpIHtcbiAgICAgIGxldCBmb2N1c2VkRWxlbWVudCA9IHRoaXMuX3N1Z2dlc3Rpb25MaXN0LnF1ZXJ5U2VsZWN0b3IoYC4ke0NMQVNTX0hPVkVSfWApXG5cbiAgICAgIHByZXZlbnREZWZhdWx0KGV2dClcbiAgICAgIHRoaXMuX3NlbGVjdEl0ZW0oZm9jdXNlZEVsZW1lbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNPcGVuID09PSB0cnVlICYmIElucHV0cy5jb250YWluc0tleShrZXljb2RlLCBbIElucHV0cy5LRVlfQVJST1dfVVAsIElucHV0cy5LRVlfQVJST1dfRE9XTiBdKSkge1xuICAgICAgLy8gVXAgYW5kIGRvd24gYXJyb3dzXG5cbiAgICAgIGxldCBmb2N1c2VkRWxlbWVudCA9IHRoaXMuX3N1Z2dlc3Rpb25MaXN0LnF1ZXJ5U2VsZWN0b3IoYC4ke0NMQVNTX0hPVkVSfWApIVxuICAgICAgaWYgKGZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKGZvY3VzZWRFbGVtZW50LCBDTEFTU19IT1ZFUilcblxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX3N1Z2dlc3Rpb25MaXN0LmNoaWxkTm9kZXMpIGFzIEVsZW1lbnRbXVxuXG4gICAgICAgIGNvbnN0IHRvdGFsTm9kZXMgPSBjaGlsZHJlbi5sZW5ndGggLSAxXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfVVAgPyAtMSA6IDFcblxuICAgICAgICBsZXQgaW5kZXggPSBjaGlsZHJlbi5pbmRleE9mKGZvY3VzZWRFbGVtZW50KVxuXG4gICAgICAgIGluZGV4ID0gTWF0aC5tYXgoTWF0aC5taW4oaW5kZXggKyBkaXJlY3Rpb24sIHRvdGFsTm9kZXMpLCAwKVxuICAgICAgICBmb2N1c2VkRWxlbWVudCA9IHRoaXMuX3N1Z2dlc3Rpb25MaXN0LmNoaWxkTm9kZXNbaW5kZXhdIGFzIEVsZW1lbnRcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9jdXNlZEVsZW1lbnQgPSB0aGlzLl9zdWdnZXN0aW9uTGlzdC5xdWVyeVNlbGVjdG9yKFwibGlcIikgYXMgRWxlbWVudFxuICAgICAgfVxuXG4gICAgICBhZGRDbGFzcyhmb2N1c2VkRWxlbWVudCwgQ0xBU1NfSE9WRVIpXG4gICAgICBwcmV2ZW50RGVmYXVsdChldnQpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVdpbmRvd0NsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2lzRHJvcGRvd25UYXJnZXQoZXZlbnQudGFyZ2V0IGFzIE5vZGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfc2VsZWN0SXRlbShpdGVtPzogRWxlbWVudCB8IG51bGwpIHtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRleHQgPSBpdGVtLmdldEF0dHJpYnV0ZShBVFRSSUJVVEVfVkFMVUUpXG4gICAgaWYgKHRleHQpIHtcbiAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gdGV4dFxuXG4gICAgICAvLyBEaXNwYXRjaCB0aGUgY2hhbmdlZCBldmVudFxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlXCIpXG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2lzRHJvcGRvd25UYXJnZXQodGFyZ2V0OiBOb2RlKSB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXRcbiAgICB3aGlsZSAoY3VycmVudCAhPT0gdGhpcy5fZHJvcGRvd24gJiYgY3VycmVudC5wYXJlbnROb2RlKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlXG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnQgPT09IHRoaXMuX2Ryb3Bkb3duXG4gIH1cblxuICBwcm90ZWN0ZWQgX2NsZWFyU3VnZ2VzdGlvbnMoKSB7XG4gICAgLy8gQ2xlYXIgdGhlIGRyb3Bkb3duIGl0ZW1cbiAgICBlbXB0eSh0aGlzLl9kcm9wZG93bilcblxuICAgIHRoaXMuX3N1Z2dlc3Rpb25MaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpXG4gICAgdGhpcy5fZHJvcGRvd24uYXBwZW5kQ2hpbGQodGhpcy5fc3VnZ2VzdGlvbkxpc3QpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2FkZFN1Z2dlc3Rpb24odGV4dDogc3RyaW5nLCB0ZXJtOiBzdHJpbmcpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWRUZXJtID0gdGVybS5yZXBsYWNlKC9bLVxcXFxeJCorPy4oKXxbXFxde31dL2csIFwiXFxcXCQmXCIpXG4gICAgY29uc3QgaHRtbCA9IHRleHQucmVwbGFjZShuZXcgUmVnRXhwKGAoJHtzYW5pdGl6ZWRUZXJtfSlgLCBcImdpXCIpLCBcIjxzdHJvbmc+JDE8L3N0cm9uZz5cIilcblxuICAgIGNvbnN0IHRleHRFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgICAuc2V0SHRtbChodG1sKVxuXG4gICAgY29uc3QgaW5uZXJFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19SRVNVTFQpXG4gICAgICAuYXBwZW5kQ2hpbGQodGV4dEVsZW1lbnQpXG5cbiAgICBjb25zdCBsaUVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImxpXCIpXG4gICAgICAuc2V0QXR0cmlidXRlKEFUVFJJQlVURV9WQUxVRSwgdGV4dClcbiAgICAgIC5hcHBlbmRDaGlsZChpbm5lckVsZW1lbnQpXG5cbiAgICB0aGlzLl9zdWdnZXN0aW9uTGlzdC5hcHBlbmRDaGlsZChsaUVsZW1lbnQuZWxlbWVudClcbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0U3VnZ2VzdGlvbih0ZXJtOiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMuX3NvdXJjZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNvdXJjZSBmdW5jdGlvbiBpcyB1bmRlZmluZWQsIGNhbm5vdCBsb2FkIHN1Z2dlc3Rpb25zXCIpXG4gICAgfVxuXG4gICAgdGhpcy5fc291cmNlKHRlcm0sIChtYXRjaGVzLCB0ZXJtdXNlZCkgPT4ge1xuICAgICAgdGhpcy5fb25NYXRjaGVzUmVjZWl2ZWQobWF0Y2hlcywgdGVybXVzZWQpXG4gICAgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfb25NYXRjaGVzUmVjZWl2ZWQobWF0Y2hlczogc3RyaW5nW10sIHRlcm06IHN0cmluZykge1xuICAgIHRoaXMuX2NsZWFyU3VnZ2VzdGlvbnMoKVxuXG4gICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2xlYXIgdGhlIGRyb3Bkb3duIGl0ZW1cbiAgICAgIGVtcHR5KHRoaXMuX3N1Z2dlc3Rpb25MaXN0KVxuXG4gICAgICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICAgIHRoaXMuX2FkZFN1Z2dlc3Rpb24obWF0Y2gsIHRlcm0pXG4gICAgICB9XG5cbiAgICAgIHRoaXMub3BlbigpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hhbmdlIGV2ZW50XG4gKlxuICogQGV2ZW50IEF1dG9jb21wbGV0ZSNjaGFuZ2VcbiAqIEB0eXBlIHtvYmplY3R9XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemU8SFRNTEVsZW1lbnQ+KFwiLmlucHV0LWZpZWxkLS1hdXRvY29tcGxldGVcIiwgKGUpID0+IHtcbiAgICBuZXcgQXV0b2NvbXBsZXRlKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IEF1dG9jb21wbGV0ZVxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgcmVtb3ZlIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCBmbGF0cGlja3IgZnJvbSBcImZsYXRwaWNrclwiXG5cbmltcG9ydCB7IEl0YWxpYW4gfSBmcm9tIFwiZmxhdHBpY2tyL2Rpc3QvbDEwbi9pdC5qc1wiXG5pbXBvcnQgeyBGcmVuY2ggfSBmcm9tIFwiZmxhdHBpY2tyL2Rpc3QvbDEwbi9mci5qc1wiXG5pbXBvcnQgeyBHZXJtYW4gfSBmcm9tIFwiZmxhdHBpY2tyL2Rpc3QvbDEwbi9kZS5qc1wiXG5cbmZsYXRwaWNrci5sb2NhbGl6ZShJdGFsaWFuKVxuZmxhdHBpY2tyLmxvY2FsaXplKEZyZW5jaClcbmZsYXRwaWNrci5sb2NhbGl6ZShHZXJtYW4pXG5cbmNvbnN0IERFRkFVTFRTX0ZMQVRQSUNLUiA9IHtcbiAgd3JhcDogdHJ1ZSwgLy8gZW5hYmxlIGNhbGVuZGFyIHRvZ2dsZSBpY29uXG4gIGFsbG93SW5wdXQ6IHRydWUsIC8vIGRvbid0IHNldCBpbnB1dCB0byByZWFkb25seVxuICBsb2NhbGU6IFwiZGVcIiwgLy8gR2VybWFuIGlzIGRlZmF1bHRcbiAgZGF0ZUZvcm1hdDogXCJkLm0uWVwiLCAvLyAxNS4wMS4yMDE3XG4gIHRpbWVfMjRocjogdHJ1ZVxufVxuXG5jb25zdCBDTEFTU19IQVNfVkFMVUUgPSBcImlzLWZpeGVkXCJcbmNvbnN0IENMQVNTX01FU1NBR0UgPSBcIi5tZXNzYWdlXCJcblxuLyoqXG4gKiBJbnB1dCBmaWVsZCBjb21wb25lbnRcbiAqL1xuY2xhc3MgSW5wdXRGaWVsZCBleHRlbmRzIERvbUVsZW1lbnQ8SFRNTElucHV0RWxlbWVudD4ge1xuICBwcml2YXRlIF9jaGFuZ2VkSGFuZGxlcjogKCkgPT4gdm9pZFxuICBwcml2YXRlIF9hbmltYXRpb25TdGFydEhhbmRsZXI6IChlOiBBbmltYXRpb25FdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9mbGF0cGlja3JJbnN0YW5jZTogYW55XG4gIHByaXZhdGUgX2RhdGVQaWNrZXJPcHRpb25zOiBhbnlcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MSW5wdXRFbGVtZW50LCBkYXRlUGlja2VyT3B0aW9ucz86IGFueSkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9jaGFuZ2VkSGFuZGxlciA9IHRoaXMub25WYWx1ZUNoYW5nZWQuYmluZCh0aGlzKVxuICAgIHRoaXMuX2FuaW1hdGlvblN0YXJ0SGFuZGxlciA9IHRoaXMuX29uQW5pbWF0aW9uU3RhcnQuYmluZCh0aGlzKVxuICAgIHRoaXMuX2RhdGVQaWNrZXJPcHRpb25zID0gZGF0ZVBpY2tlck9wdGlvbnNcbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgaW5wdXQgZmllbGQgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5fY2hhbmdlZEhhbmRsZXIpXG5cbiAgICBpZiAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIikgPT09IFwicGFzc3dvcmRcIikge1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25zdGFydFwiLCB0aGlzLl9hbmltYXRpb25TdGFydEhhbmRsZXIpXG4gICAgfVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZURhdGVQaWNrZXIoKVxuICAgIHRoaXMub25WYWx1ZUNoYW5nZWQoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplRGF0ZVBpY2tlcigpIHtcbiAgICBjb25zdCBwaWNrZXIgPSB0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudFxuICAgIGlmICghcGlja2VyIHx8ICFwaWNrZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZmxhdHBpY2tyXCIpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kYXRlUGlja2VyT3B0aW9ucykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fZGF0ZVBpY2tlck9wdGlvbnMgPSBKU09OLnBhcnNlKHBpY2tlci5kYXRhc2V0Lm9wdGlvbnMgfHwgXCJ7fVwiKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLl9kYXRlUGlja2VyT3B0aW9ucyA9IHt9XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybihcIl9pbml0aWFsaXplRGF0ZVBpY2tlciBKU09OLnBhcnNlIGZhaWxlZFwiLCBwaWNrZXIuZGF0YXNldC5vcHRpb25zLCBlKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9mbGF0cGlja3JJbnN0YW5jZSA9IGZsYXRwaWNrcihwaWNrZXIsIE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRTX0ZMQVRQSUNLUiwgdGhpcy5fZGF0ZVBpY2tlck9wdGlvbnMpKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9kZXN0cm95RGF0ZVBpY2tlcigpIHtcbiAgICBpZiAodGhpcy5fZmxhdHBpY2tySW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuX2ZsYXRwaWNrckluc3RhbmNlLmRlc3Ryb3koKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfb25BbmltYXRpb25TdGFydChlOiBBbmltYXRpb25FdmVudCkge1xuICAgIGlmIChlLmFuaW1hdGlvbk5hbWUgPT09IFwib25BdXRvRmlsbFN0YXJ0XCIpIHtcbiAgICAgIHRoaXMub25WYWx1ZUNoYW5nZWQodHJ1ZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm90aWZpZXMgdGhlIGlucHV0IGZpZWxkIGNvbXBvbmVudCB0aGF0IGl0J3MgdmFsdWUgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICovXG4gIHB1YmxpYyBvblZhbHVlQ2hhbmdlZChmb3JjZSA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudC52YWx1ZSAmJiB0aGlzLmVsZW1lbnQudmFsdWUgIT09IFwiXCIgfHwgZm9yY2UgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfSEFTX1ZBTFVFKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKENMQVNTX0hBU19WQUxVRSlcbiAgICAgIHRoaXMuZWxlbWVudC52YWx1ZSA9IFwiXCJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudCBhbmQgZnJlZXMgYWxsIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuX2NoYW5nZWRIYW5kbGVyKVxuXG4gICAgaWYgKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09PSBcInBhc3N3b3JkXCIpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uc3RhcnRcIiwgdGhpcy5fYW5pbWF0aW9uU3RhcnRIYW5kbGVyKVxuICAgIH1cblxuICAgICh0aGlzIGFzIGFueSkuX2NoYW5nZWRIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICh0aGlzIGFzIGFueSkuX2FuaW1hdGlvblN0YXJ0SGFuZGxlciA9IHVuZGVmaW5lZFxuXG4gICAgdGhpcy5fZGVzdHJveURhdGVQaWNrZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BsYXlzIHRoZSBzcGVjaWZpZWQgZXJyb3IgdGV4dCB1bmRlcm5lYXRoIHRoZSBpbnB1dCBmaWVsZC5cbiAgICogQHBhcmFtIHt0ZXh0fSB0ZXh0IFRoZSBlcnJvciB0ZXh0L2h0bWwgdG8gZGlzcGxheTsgb3IgdW5kZWZpbmVkIHRvIGhpZGUgdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBwdWJsaWMgc2hvd0Vycm9yKHRleHQ6IHN0cmluZykge1xuICAgIGxldCBtZXNzYWdlXG4gICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBsZXQgbXNnID0gdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcihDTEFTU19NRVNTQUdFKVxuXG4gICAgICBpZiAobXNnKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBuZXcgRG9tRWxlbWVudChtc2cpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0ZXh0IHx8IHRleHQgPT09IFwiXCIpIHtcbiAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgIHJlbW92ZShtZXNzYWdlLmVsZW1lbnQpXG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoXCJpbnZhbGlkXCIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmFkZENsYXNzKFwiaW52YWxpZFwiKVxuXG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKFwibWVzc2FnZVwiKVxuXG4gICAgICB0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudCEuYXBwZW5kQ2hpbGQobWVzc2FnZS5lbGVtZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLmVtcHR5KClcbiAgICB9XG5cbiAgICBjb25zdCBpY29uID0gbmV3IERvbUVsZW1lbnQoXCJpXCIpXG4gICAgICAuYWRkQ2xhc3MoXCJpY29uXCIpXG4gICAgICAuYWRkQ2xhc3MoXCJpY29uLTAyNi1leGNsYW1hdGlvbi1tYXJrLWNpcmNsZVwiKVxuICAgICAgLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKVxuXG4gICAgY29uc3QgbXNnID0gbmV3IERvbUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgICAuc2V0SHRtbCh0ZXh0KVxuXG4gICAgbWVzc2FnZS5hcHBlbmRDaGlsZChpY29uKVxuICAgIG1lc3NhZ2UuYXBwZW5kQ2hpbGQobXNnKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplPEhUTUxJbnB1dEVsZW1lbnQ+KFwiLmlucHV0LWZpZWxkIGlucHV0XCIsIChlKSA9PiB7XG4gICAgbmV3IElucHV0RmllbGQoZSlcbiAgfSwgKGUpID0+IGUucGFyZW50RWxlbWVudCEpXG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0RmllbGRcbiIsImltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5cbmltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIGNsYW1wLCBwcmV2ZW50RGVmYXVsdCB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgKiBhcyBJbnB1dHMgZnJvbSBcIi4uL0lucHV0c1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5cbmNvbnN0IE1BUkdJTl9USUNLID0gMzJcbmNvbnN0IENMQVNTX0hUTUw1ID0gXCJodG1sNVwiXG5jb25zdCBSQU5HRV9MSUdIVCA9IFwicmFuZ2UtLWxpZ2h0XCJcblxuY29uc3QgQ0xBU1NfQ09OVEFJTkVSID0gXCJyYW5nZS1jb250YWluZXJcIlxuY29uc3QgQ0xBU1NfU0xJREVSID0gXCJyYW5nZS1zbGlkZXJcIlxuY29uc3QgQ0xBU1NfQUNUSVZFID0gXCJyYW5nZS0tYWN0aXZlXCJcblxuY29uc3QgQ0xBU1NfVFJBQ0sgPSBcInJhbmdlLXRyYWNrXCJcbmNvbnN0IENMQVNTX1RSQUNLX1BST0dSRVNTID0gXCJyYW5nZS10cmFja19fcHJvZ3Jlc3NcIlxuXG5jb25zdCBDTEFTU19USUNLID0gXCJyYW5nZS10aWNrXCJcbmNvbnN0IENMQVNTX1RJQ0tfTEFCRUwgPSBcInJhbmdlLXRpY2tfX2xhYmVsXCJcbmNvbnN0IENMQVNTX1RJQ0tfQUNUSVZFID0gXCJyYW5nZS10aWNrLS1hY3RpdmVcIlxuXG5jb25zdCBDTEFTU19USFVNQiA9IFwicmFuZ2UtdGh1bWJcIlxuY29uc3QgQ0xBU1NfVEhVTUJfVkFMVUUgPSBcInJhbmdlLXRodW1iX192YWx1ZVwiXG5jb25zdCBDTEFTU19ESVNBQkxFRCA9IFwicmFuZ2UtLWRpc2FibGVkXCJcblxuY29uc3QgQ0xBU1NfRFJBR0dJTkcgPSBcInJhbmdlLS1kcmFnZ2luZ1wiXG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9ybWF0dGVyIHtcbiAgKHZhbHVlOiBudW1iZXIsIHNob3J0OiBib29sZWFuKTogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uIHtcbiAgdmFsdWU6IG51bWJlclxuICBsYWJlbDogc3RyaW5nIHwgbnVtYmVyXG59XG5cbi8qKlxuICogVGhlIHJhbmdlIHNsaWRlciBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xuY2xhc3MgUmFuZ2UgZXh0ZW5kcyBEb21FbGVtZW50PEhUTUxJbnB1dEVsZW1lbnQ+IHtcbiAgcHJpdmF0ZSBfZG93bkhhbmRsZXI6IChlOiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9tb3ZlSGFuZGxlcjogKGU6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2VuZEhhbmRsZXI6IChlOiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9rZXlkb3duSGFuZGxlcjogKGU6IEtleWJvYXJkRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfZm9jdXNIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfYmx1ckhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9yZXNpemVIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcblxuICBwcml2YXRlIF93cmFwcGVyRWxlbWVudCE6IERvbUVsZW1lbnQ8SFRNTEVsZW1lbnQ+XG4gIHByaXZhdGUgX3JhbmdlQ29udGFpbmVyITogRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD5cbiAgcHJpdmF0ZSBfcmFuZ2VUcmFjayE6IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+XG4gIHByaXZhdGUgX3JhbmdlUHJvZ3Jlc3MhOiBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PlxuICBwcml2YXRlIF90aWNrc1dyYXBwZXIhOiBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PlxuICBwcml2YXRlIF9yYW5nZVRodW1iITogRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD5cbiAgcHJpdmF0ZSBfdGh1bWJWYWx1ZSE6IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+XG4gIHByaXZhdGUgX291dHB1dExhYmVsPzogRG9tRWxlbWVudDxFbGVtZW50PlxuXG4gIHByaXZhdGUgX21pblZhbHVlITogbnVtYmVyXG4gIHByaXZhdGUgX21heFZhbHVlITogbnVtYmVyXG4gIHByaXZhdGUgX3RyYWNrVmFsdWVUb3RhbCE6IG51bWJlclxuXG4gIHByaXZhdGUgX2dyYWJQb3NpdGlvbiE6IG51bWJlclxuICBwcml2YXRlIF90cmFja1dpZHRoITogbnVtYmVyXG4gIHByaXZhdGUgX3RyYWNrUG9zaXRpb25NaW4hOiBudW1iZXJcbiAgcHJpdmF0ZSBfdHJhY2tQb3NpdGlvbk1heCE6IG51bWJlclxuICBwcml2YXRlIF90cmFja0xlZnRQb3NpdGlvbiE6IG51bWJlclxuICBwcml2YXRlIF9pdGVtV2lkdGghOiBudW1iZXJcblxuICBwcml2YXRlIF9mb3JtYXR0ZXIhOiBGb3JtYXR0ZXJcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIC8vIFNldHVwIGV2ZW50IGNvbnRleHRcbiAgICB0aGlzLl9kb3duSGFuZGxlciA9IHRoaXMuX2hhbmRsZURvd24uYmluZCh0aGlzKVxuICAgIHRoaXMuX21vdmVIYW5kbGVyID0gdGhpcy5faGFuZGxlTW92ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fZW5kSGFuZGxlciA9IHRoaXMuX2hhbmRsZUVuZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fa2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2ZvY3VzSGFuZGxlciA9IHRoaXMuX2hhbmRsZUZvY3VzLmJpbmQodGhpcylcbiAgICB0aGlzLl9ibHVySGFuZGxlciA9IHRoaXMuX2hhbmRsZUJsdXIuYmluZCh0aGlzKVxuICAgIHRoaXMuX3Jlc2l6ZUhhbmRsZXIgPSB0aGlzLmxheW91dC5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcblxuICAgIGlmICh0aGlzLmVsZW1lbnQuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHJhbmdlIHNsaWRlciBjb21wb25lbnQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGluc3BlY3RzIHRoZSBzZWxlY3QgZGVmaW5pdGlvbiBhbmQgaXRzIG9wdGlvbnMgYW5kXG4gICAqIGdlbmVyYXRlcyBuZXcgc3R5bGFibGUgRE9NIGVsZW1lbnRzIGFyb3VuZCB0aGUgb3JpZ2luYWwgcmFuZ2UgaW5wdXQtZWxlbWVudFxuICAgKiBkZWZpbml0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcblxuICAgIGlmICh0aGlzLmhhc0NsYXNzKENMQVNTX0hUTUw1KSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHVzZXMgSFRNTDUgc3R5bGluZywgZG8gbm90IHRvdWNoIGl0Li4uXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50ISlcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfQ09OVEFJTkVSKVxuXG4gICAgdGhpcy5fcmFuZ2VUcmFjayA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX1RSQUNLKVxuXG4gICAgLy8gY2hlY2sgaWYgcmFuZ2UtLWxpZ2h0IHNsaWRlciB0aGVuIGFkZCBwcm9ncmVzc1xuICAgIGlmICh0aGlzLl93cmFwcGVyRWxlbWVudC5oYXNDbGFzcyhSQU5HRV9MSUdIVCkpIHtcbiAgICAgIHRoaXMuX3JhbmdlUHJvZ3Jlc3MgPSBuZXcgRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD4oXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX1RSQUNLX1BST0dSRVNTKVxuXG4gICAgICB0aGlzLl9yYW5nZVRyYWNrLmFwcGVuZENoaWxkKHRoaXMuX3JhbmdlUHJvZ3Jlc3MpXG4gICAgfVxuXG4gICAgdGhpcy5fcmFuZ2VUaHVtYiA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX1RIVU1CKVxuXG4gICAgdGhpcy5fdGlja3NXcmFwcGVyID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfU0xJREVSKVxuXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcmFuZ2VUcmFjaylcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl90aWNrc1dyYXBwZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcmFuZ2VUaHVtYilcblxuICAgIC8vIGFkZCBjb250YWluZXIgdG8gd3JhcHBlclxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3JhbmdlQ29udGFpbmVyKVxuXG4gICAgLy8gZ2V0IG1pbiAmIG1heCBkZWZpbml0aW9uc1xuICAgIHRoaXMuX21pblZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLmVsZW1lbnQubWluKSB8fCAwXG4gICAgdGhpcy5fbWF4VmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuZWxlbWVudC5tYXgpIHx8IDFcblxuICAgIC8vIGdldCB0aGUgbGFiZWwvb3V0cHV0IGZvcm1hdCBzdHJpbmdcbiAgICB0aGlzLl9mb3JtYXR0ZXIgPSAod2luZG93IGFzIGFueSlbdGhpcy5nZXRBdHRyaWJ1dGUoXCJmb3JtYXR0ZXJcIikhXVxuXG4gICAgLy8gZ2V0IHRoZSBvdXRwdXQgbGFiZWwgYW5kIG1vdmUgaXQgYmVsb3cgdGhlIGNvbnRhaW5lclxuICAgIGlmICh0aGlzLmVsZW1lbnQuaWQpIHtcbiAgICAgIHRoaXMuX291dHB1dExhYmVsID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZmluZChgb3V0cHV0W2Zvcj0nJHt0aGlzLmVsZW1lbnQuaWR9J11gKVxuICAgICAgaWYgKHRoaXMuX291dHB1dExhYmVsKSB7XG4gICAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX291dHB1dExhYmVsKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5lbGVtZW50LnN0ZXApIHtcbiAgICAgIC8vIGZpeCBpc3N1ZXMgd2l0aCBmbG9hdCBzbGlkZXJzIGlmIHRoZSBzdGVwIGlzIHVuZGVmaW5lZFxuICAgICAgdGhpcy5lbGVtZW50LnN0ZXAgPSBcImFueVwiXG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnNMaXN0KClcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxlbmd0aCkge1xuICAgICAgdGhpcy5fYWRkVGlja3Mob3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19USUNLX0xBQkVMfWApLmxlbmd0aCA8PSAxKSB7XG4gICAgICB0aGlzLl90aHVtYlZhbHVlID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19USFVNQl9WQUxVRSlcblxuICAgICAgdGhpcy5fcmFuZ2VUaHVtYi5hcHBlbmRDaGlsZCh0aGlzLl90aHVtYlZhbHVlKVxuICAgIH1cblxuICAgIHRoaXMuX3RyYWNrVmFsdWVUb3RhbCA9IHRoaXMuX21heFZhbHVlIC0gdGhpcy5fbWluVmFsdWVcbiAgICB0aGlzLmxheW91dCgpXG5cbiAgICB0aGlzLl91cGRhdGVUaWNrU3RhdGUoKVxuXG4gICAgLy8gQXBwbHkgdGhlIHRhYiBpbmRleFxuICAgIGNvbnN0IHRhYkluZGV4ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpXG4gICAgaWYgKHRhYkluZGV4KSB7XG4gICAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCB0YWJJbmRleClcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0T3B0aW9uc0xpc3QoKSB7XG4gICAgbGV0IG9wdGlvbnM6IE9wdGlvbltdID0gW11cblxuICAgIGxldCBsaXN0SWQgPSB0aGlzLmdldEF0dHJpYnV0ZShcImxpc3RcIilcbiAgICBpZiAobGlzdElkKSB7XG4gICAgICBsZXQgZGF0YUxpc3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHtsaXN0SWR9YClcbiAgICAgIGlmIChkYXRhTGlzdCkge1xuICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiBkYXRhTGlzdC5xdWVyeVNlbGVjdG9yQWxsKFwib3B0aW9uXCIpKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gcGFyc2VGbG9hdChlbnRyeS5pbm5lclRleHQpXG4gICAgICAgICAgbGV0IGxhYmVsID0gZW50cnkuZ2V0QXR0cmlidXRlKFwibGFiZWxcIikgfHwgcGFyc2VGbG9hdCh2YWx1ZS50b0ZpeGVkKDIpKVxuXG4gICAgICAgICAgb3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbGFiZWxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU29ydCB0aGUgbGlzdCB0byBlbmFibGUgc25hcHBpbmdcbiAgICBvcHRpb25zID0gb3B0aW9ucy5zb3J0KChhLCBiKSA9PiBhLnZhbHVlIC0gYi52YWx1ZSlcblxuICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuX21pblZhbHVlID0gTnVtYmVyLk1BWF9WQUxVRVxuICAgICAgdGhpcy5fbWF4VmFsdWUgPSBOdW1iZXIuTUlOX1ZBTFVFXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9taW5WYWx1ZSA9IE1hdGgubWluKHRoaXMuX21pblZhbHVlLCBvcHRpb25zW2ldLnZhbHVlKVxuICAgICAgICB0aGlzLl9tYXhWYWx1ZSA9IE1hdGgubWF4KHRoaXMuX21heFZhbHVlLCBvcHRpb25zW2ldLnZhbHVlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBwcm90ZWN0ZWQgX2FkZFRpY2tzKGRhdGFJdGVtczogT3B0aW9uW10pIHtcbiAgICBmb3IgKGxldCBlbnRyeSBvZiBkYXRhSXRlbXMpIHtcbiAgICAgIGxldCB0aWNrRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIsIFN0cmluZyhlbnRyeS52YWx1ZSkpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19USUNLKVxuXG4gICAgICBsZXQgdGlja0xhYmVsID0gbmV3IERvbUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19USUNLX0xBQkVMKVxuICAgICAgICAuc2V0SHRtbChTdHJpbmcoZW50cnkubGFiZWwpKVxuXG4gICAgICB0aWNrRWxlbWVudC5hcHBlbmRDaGlsZCh0aWNrTGFiZWwpXG4gICAgICB0aGlzLl90aWNrc1dyYXBwZXIuYXBwZW5kQ2hpbGQodGlja0VsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pc0V2ZW50T25MYWJlbChldmVudDogRXZlbnQpIHtcbiAgICBjb25zdCBlbCA9IGV2ZW50LnRhcmdldCBhcyBFbGVtZW50XG5cbiAgICByZXR1cm4gISFlbD8uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX1RJQ0tfTEFCRUwpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZURvd24oZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSB7XG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfRFJBR0dJTkcpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX2VuZEhhbmRsZXIpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9tb3ZlSGFuZGxlcilcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9lbmRIYW5kbGVyKVxuXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX21vdmVIYW5kbGVyKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl9lbmRIYW5kbGVyKVxuXG4gICAgLy8gSWdub3JlIGNsaWNrcyBkaXJlY3RseSBvbiB0aGUgdGh1bWJcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLl9yYW5nZVRodW1iLmVsZW1lbnQgJiYgIXRoaXMuX2lzRXZlbnRPbkxhYmVsKGV2ZW50KSkge1xuICAgICAgbGV0IHBvcyA9IHRoaXMuX2dldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQpXG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbihwb3MsIHRydWUsIGZhbHNlLCBmYWxzZSlcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZU1vdmUoZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSB7XG4gICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgdGhpcy5fdW5mb2N1cygpXG5cbiAgICBpZiAoIXRoaXMuX2lzRXZlbnRPbkxhYmVsKGV2ZW50KSkge1xuICAgICAgbGV0IHBvcyA9IHRoaXMuX2dldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQpXG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbihwb3MsIHRydWUsIGZhbHNlLCBmYWxzZSlcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUVuZChldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpIHtcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5yZW1vdmVDbGFzcyhDTEFTU19EUkFHR0lORylcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5fZW5kSGFuZGxlcilcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9lbmRIYW5kbGVyKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fbW92ZUhhbmRsZXIpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fbW92ZUhhbmRsZXIpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX2VuZEhhbmRsZXIpXG5cbiAgICBsZXQgcG9zID0gdGhpcy5fZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudClcbiAgICB0aGlzLl9zZXRQb3NpdGlvbihwb3MsIHRydWUsIHRydWUsIHRydWUpXG4gICAgdGhpcy5faGFuZGxlQmx1cigpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBsZXQga2V5Y29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVcblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0VTQ0FQRSkge1xuICAgICAgLy8gaGFuZGxlIEVzY2FwZSBrZXkgKEVTQylcbiAgICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQuYmx1cigpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBpc1VwID0ga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9BUlJPV19VUCB8fCBrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX1JJR0hUXG4gICAgICB8fCBrZXljb2RlID09PSBJbnB1dHMuS0VZX1BBR0VfVVBcblxuICAgIGNvbnN0IGlzRG93biA9IGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfRE9XTiB8fCBrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX0xFRlRcbiAgICAgIHx8IGtleWNvZGUgPT09IElucHV0cy5LRVlfUEFHRV9ET1dOXG5cbiAgICBpZiAoaXNVcCB8fCBpc0Rvd24pIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblxuICAgICAgbGV0IGRpcmVjdGlvbiA9IGlzRG93biA/IC0xIDogMVxuXG4gICAgICAvLyBtYWtlIGEgbGFyZ2VyIHN0ZXAgaWYgaXRzIHRoZSB2ZXJ0aWNhbCBhcnJvdyBvciBwYWdlIGtleXNcbiAgICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX1VQIHx8IGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfRE9XTiB8fFxuICAgICAgICBrZXljb2RlID09PSBJbnB1dHMuS0VZX1BBR0VfVVAgfHwga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9QQUdFX0RPV04pIHtcbiAgICAgICAgZGlyZWN0aW9uICo9IDEwXG4gICAgICB9XG5cbiAgICAgIGxldCB2YWwgPSB0aGlzLnZhbHVlXG4gICAgICBpZiAodGhpcy5fdGlja3NXcmFwcGVyLmVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbCA9IHRoaXMuX2dldE5leHRWYWx1ZSh2YWwsIGRpcmVjdGlvbilcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgbGV0IHN0ZXA6IHN0cmluZyB8IG51bWJlciA9IHRoaXMuZWxlbWVudC5zdGVwXG4gICAgICAgIGlmICghc3RlcCB8fCBzdGVwID09PSBcImFueVwiKSB7XG4gICAgICAgICAgc3RlcCA9IFwiMC4xXCJcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3VmFsID0gdmFsICsgKHBhcnNlRmxvYXQoc3RlcCkgKiBkaXJlY3Rpb24pXG4gICAgICAgIHZhbCA9IG5ld1ZhbFxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRWYWx1ZSh2YWwsIHRydWUsIHRydWUpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUZvY3VzKCkge1xuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmFkZENsYXNzKENMQVNTX0FDVElWRSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQmx1cigpIHtcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5yZW1vdmVDbGFzcyhDTEFTU19BQ1RJVkUpXG4gIH1cblxuICBwcm90ZWN0ZWQgX3VuZm9jdXMoKSB7XG4gICAgaWYgKChkb2N1bWVudCBhcyBhbnkpLnNlbGVjdGlvbikge1xuICAgICAgKGRvY3VtZW50IGFzIGFueSkuc2VsZWN0aW9uLmVtcHR5KClcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpIS5yZW1vdmVBbGxSYW5nZXMoKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpIHtcbiAgICBsZXQgcGFnZVhcbiAgICBpZiAoXCJwYWdlWFwiIGluIGV2ZW50KSB7XG4gICAgICBwYWdlWCA9IGV2ZW50LnBhZ2VYXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZ2VYID0gKGV2ZW50LnRvdWNoZXNbMF0gfHwgZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pLnBhZ2VYXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhZ2VYIC0gdGhpcy5fdHJhY2tMZWZ0UG9zaXRpb24gKyB0aGlzLl9ncmFiUG9zaXRpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYW5kIHVwZGF0ZXMgdGhlIHBvc2l0aW9uIGFuZCBzZXRzIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9uIHRoZSBzbGlkZXIuXG4gICAqIEBwYXJhbSB7cG9zaXRpb259IHRoZSBuZXcgcG9zaXRpb24gdG8gc2V0LlxuICAgKiBAcGFyYW0ge3VwZGF0ZVZhbHVlfSB0cnVlIGlmIHRoZSB2YWx1ZSBzaG91bGQgYmUgdXBkYXRlZCBhcyB3ZWxsOyBvdGhlcndpc2UgZmFsc2UuXG4gICAqIEBwYXJhbSB7c25hcH0gdHJ1ZSBpZiBzbmFwcGluZyBzaG91bGQgYmUgdXNlZDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKiBAcGFyYW0ge2FuaW1hdGV9IHRydWUgaWYgdGhlIFVJIHVwZGF0ZSBzaG91bGQgYmUgYW5pbWF0ZWQ7IG90aGVyd2lzZSBmYWxzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfc2V0UG9zaXRpb24oXG4gICAgcG9zaXRpb246IG51bWJlcixcbiAgICB1cGRhdGVWYWx1ZSA9IHRydWUsXG4gICAgc25hcCA9IGZhbHNlLFxuICAgIGFuaW1hdGUgPSB0cnVlXG4gICkge1xuICAgIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uID09PSBudWxsIHx8IE51bWJlci5pc05hTihwb3NpdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc2l0aW9uIGlzIG5vdCBhIG51bWJlclwiKVxuICAgIH1cblxuICAgIC8vIENsYW1wIHRvIG1pbiBhbmQgbWF4IHJhbmdlXG4gICAgbGV0IG5ld1BvcyA9IGNsYW1wKHBvc2l0aW9uLCB0aGlzLl90cmFja1Bvc2l0aW9uTWluLCB0aGlzLl90cmFja1Bvc2l0aW9uTWF4KVxuICAgIGlmICh1cGRhdGVWYWx1ZSkge1xuICAgICAgbGV0IHZhbHVlID0gKHRoaXMuX3RyYWNrVmFsdWVUb3RhbCAvIHRoaXMuX3RyYWNrV2lkdGgpICogbmV3UG9zICsgdGhpcy5fbWluVmFsdWVcblxuICAgICAgaWYgKHRoaXMuX3RpY2tzV3JhcHBlci5lbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMSAmJiBzbmFwKSB7XG4gICAgICAgIGxldCBzbmFwUG9zID0gdGhpcy5fZ2V0U25hcFBvc2l0aW9uKG5ld1BvcylcbiAgICAgICAgbmV3UG9zID0gc25hcFBvcy5wb3NpdGlvblxuICAgICAgICB2YWx1ZSA9IHNuYXBQb3MudmFsdWVcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5lbGVtZW50LnN0ZXAgJiYgdGhpcy5lbGVtZW50LnN0ZXAgIT09IFwiYW55XCIpIHtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHBhcnNlRmxvYXQodGhpcy5lbGVtZW50LnN0ZXApXG4gICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAvIHN0ZXApICogc3RlcFxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRWYWx1ZSh2YWx1ZSwgZmFsc2UsIGZhbHNlKVxuICAgIH1cblxuICAgIGlmIChhbmltYXRlICYmIHVwZGF0ZVZhbHVlKSB7XG4gICAgICB0aGlzLl91cGRhdGVUaWNrU3RhdGUoKVxuICAgIH1cblxuICAgIGlmIChhbmltYXRlKSB7XG4gICAgICBhbmltZSh7XG4gICAgICAgIHRhcmdldHM6IHRoaXMuX3JhbmdlVGh1bWIuZWxlbWVudCxcbiAgICAgICAgZHVyYXRpb246IDIwMCxcbiAgICAgICAgbGVmdDogbmV3UG9zLFxuICAgICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIlxuICAgICAgfSlcblxuICAgICAgaWYgKHRoaXMuX3JhbmdlUHJvZ3Jlc3MpIHtcbiAgICAgICAgYW5pbWUoe1xuICAgICAgICAgIHRhcmdldHM6IHRoaXMuX3JhbmdlUHJvZ3Jlc3MuZWxlbWVudCxcbiAgICAgICAgICBkdXJhdGlvbjogMjAwLFxuICAgICAgICAgIHdpZHRoOiBuZXdQb3MsXG4gICAgICAgICAgZWFzaW5nOiBcImVhc2VJbk91dFF1aW50XCJcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmFuZ2VUaHVtYi5lbGVtZW50LnN0eWxlLmxlZnQgPSBuZXdQb3MgKyBcInB4XCJcblxuICAgICAgaWYgKHRoaXMuX3JhbmdlUHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy5fcmFuZ2VQcm9ncmVzcy5lbGVtZW50LnN0eWxlLndpZHRoID0gbmV3UG9zICsgXCJweFwiXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNuYXAgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAqIEBwYXJhbSB7dmFsdWV9IHRoZSB0YXJnZXQgdmFsdWUuXG4gICAqIEByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzbmFwIHBvc2l0aW9uIGFuZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfZ2V0U25hcFZhbHVlKHZhbHVlOiBudW1iZXIpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMuX3RpY2tzV3JhcHBlci5lbGVtZW50LmNoaWxkcmVuXG4gICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IDBcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcblxuICAgICAgbGV0IGN1cnJlbnRFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQodGlja3NbaV0pXG4gICAgICBsZXQgY3VycmVudFZhbHVlID0gcGFyc2VGbG9hdChjdXJyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpISlcbiAgICAgIGxldCBjdXJyZW50V2lkdGggPSBjdXJyZW50RWxlbWVudC5lbGVtZW50LmNsaWVudFdpZHRoXG5cbiAgICAgIGxldCBuZXh0RWxlbWVudFxuICAgICAgbGV0IG5leHRWYWx1ZSA9IE51bWJlci5NQVhfVkFMVUVcblxuICAgICAgaWYgKGkgPCB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIG5leHRFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQodGlja3NbaSArIDFdKVxuICAgICAgICBuZXh0VmFsdWUgPSBwYXJzZUZsb2F0KG5leHRFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIikhKVxuICAgICAgfVxuXG4gICAgICAvLyBsZWZ0IG1vc3QgZWxlbWVudFxuICAgICAgaWYgKGkgPT09IDAgJiYgdmFsdWUgPD0gY3VycmVudFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogTUFSR0lOX1RJQ0sgLSB0aGlzLl9ncmFiUG9zaXRpb25cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyByaWdodCBtb3N0IGVsZW1lbnRcbiAgICAgIGlmICghbmV4dEVsZW1lbnQgJiYgdmFsdWUgPj0gY3VycmVudFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogY3VycmVudFBvc2l0aW9uICsgKGN1cnJlbnRXaWR0aCAtIE1BUkdJTl9USUNLKSAtIHRoaXMuX2dyYWJQb3NpdGlvbiAtIDFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPj0gY3VycmVudFZhbHVlICYmIHZhbHVlIDwgbmV4dFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogY3VycmVudFBvc2l0aW9uICsgKDAuNSAqIGN1cnJlbnRXaWR0aCkgLSB0aGlzLl9ncmFiUG9zaXRpb25cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdXJyZW50UG9zaXRpb24gKz0gY3VycmVudFdpZHRoXG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGRldGVybWluZSBzbmFwIHZhbHVlXCIpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc25hcCBwb3NpdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtwb3NpdGlvbn0gdGhlIHRhcmdldCBwb3NpdGlvbi5cbiAgICogQHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNuYXAgcG9zaXRpb24gYW5kIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9nZXRTbmFwUG9zaXRpb24ocG9zaXRpb24/OiBudW1iZXIgfCBudWxsKSB7XG4gICAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKHBvc2l0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicG9zaXRpb24gaXMgbm90IGEgbnVtYmVyXCIpXG4gICAgfVxuXG4gICAgY29uc3QgdGlja3MgPSB0aGlzLl90aWNrc1dyYXBwZXIuZWxlbWVudC5jaGlsZHJlblxuICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSAwXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgY3VycmVudEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudCh0aWNrc1tpXSlcbiAgICAgIGxldCBjdXJyZW50VmFsdWUgPSBwYXJzZUZsb2F0KGN1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIikhKVxuICAgICAgbGV0IGN1cnJlbnRXaWR0aCA9IGN1cnJlbnRFbGVtZW50LmVsZW1lbnQuY2xpZW50V2lkdGhcblxuICAgICAgbGV0IG5leHRFbGVtZW50XG5cbiAgICAgIGlmIChpIDwgdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgICBuZXh0RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KHRpY2tzW2kgKyAxXSlcbiAgICAgIH1cblxuICAgICAgLy8gbGVmdCBtb3N0IGVsZW1lbnRcbiAgICAgIGlmIChpID09PSAwICYmIHBvc2l0aW9uIDw9IGN1cnJlbnRQb3NpdGlvbiArIGN1cnJlbnRXaWR0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgcG9zaXRpb246IE1BUkdJTl9USUNLIC0gdGhpcy5fZ3JhYlBvc2l0aW9uXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmlnaHQgbW9zdCBlbGVtZW50XG4gICAgICBpZiAoIW5leHRFbGVtZW50ICYmIHBvc2l0aW9uID49IGN1cnJlbnRQb3NpdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgcG9zaXRpb246IGN1cnJlbnRQb3NpdGlvbiArIChjdXJyZW50V2lkdGggLSBNQVJHSU5fVElDSykgLSB0aGlzLl9ncmFiUG9zaXRpb24gLSAxXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBvc2l0aW9uID49IGN1cnJlbnRQb3NpdGlvbiAmJiBwb3NpdGlvbiA8IChjdXJyZW50UG9zaXRpb24gKyBjdXJyZW50V2lkdGgpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogY3VycmVudFBvc2l0aW9uICsgKDAuNSAqIGN1cnJlbnRXaWR0aCkgLSB0aGlzLl9ncmFiUG9zaXRpb25cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdXJyZW50UG9zaXRpb24gKz0gY3VycmVudFdpZHRoXG4gICAgfVxuXG4gICAgLy8gTm8gdGlja3MgZm91bmQgKGUuZy4gZm9yIFwiRnJlZSBTbGlkZXJcIilcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IDAsXG4gICAgICBwb3NpdGlvbjogMFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBuZXh0IHZhbHVlIGluIHRoZSBnaXZlbiBkaXJlY3Rpb24gd2l0aCByZWdhcmRzIHRvIHNuYXBwaW5nLlxuICAgKiBAcGFyYW0ge3ZhbHVlfSBUaGUgY3VycmVudCB2YWx1ZS5cbiAgICogQHBhcmFtIHtkaXJlY3Rpb259IFRoZSBkaXJlY3Rpb24gKHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIpLlxuICAgKiBAcmV0dXJucyBUaGUgbmV4dCB2YWx1ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfZ2V0TmV4dFZhbHVlKHZhbHVlOiBudW1iZXIsIGRpcmVjdGlvbjogbnVtYmVyKSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLl90aWNrc1dyYXBwZXIuZWxlbWVudC5jaGlsZHJlblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3VycmVudEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudCh0aWNrc1tpXSlcbiAgICAgIGxldCBjdXJyZW50VmFsID0gcGFyc2VGbG9hdChjdXJyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpISlcblxuICAgICAgaWYgKHZhbHVlID09PSBjdXJyZW50VmFsKSB7XG4gICAgICAgIGxldCBpbmRleCA9IGNsYW1wKGkgKyBkaXJlY3Rpb24sIDAsIHRpY2tzLmxlbmd0aCAtIDEpXG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh0aWNrc1tpbmRleF0uZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKSEpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBwcm90ZWN0ZWQgX3VwZGF0ZVRpY2tTdGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fdGlja3NXcmFwcGVyLmVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICBsZXQgYWN0aXZlVGljayA9IHRoaXMuX3RpY2tzV3JhcHBlci5maW5kKGAuJHtDTEFTU19USUNLX0FDVElWRX1gKVxuICAgICAgaWYgKGFjdGl2ZVRpY2spIHtcbiAgICAgICAgYWN0aXZlVGljay5yZW1vdmVDbGFzcyhDTEFTU19USUNLX0FDVElWRSlcbiAgICAgIH1cbiAgICAgIGxldCBuZXdBY3RpdmVUaWNrID0gdGhpcy5fdGlja3NXcmFwcGVyLmZpbmQoYC4ke0NMQVNTX1RJQ0t9W2RhdGEtdmFsdWU9JyR7dGhpcy52YWx1ZX0nXWApXG4gICAgICBpZiAobmV3QWN0aXZlVGljaykge1xuICAgICAgICBuZXdBY3RpdmVUaWNrLmFkZENsYXNzKENMQVNTX1RJQ0tfQUNUSVZFKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfYWRqdXN0VGlja0xhYmVsUG9zaXRpb24oXG4gICAgdGlja0l0ZW06IEVsZW1lbnQsXG4gICAgbGVmdDogYm9vbGVhblxuICApIHtcbiAgICBjb25zdCBsYWJlbCA9IG5ldyBEb21FbGVtZW50KHRpY2tJdGVtLnF1ZXJ5U2VsZWN0b3IoYC4ke0NMQVNTX1RJQ0tfTEFCRUx9YCkhKVxuXG4gICAgbGV0IGR1bW15RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwic3BhblwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX1RJQ0tfTEFCRUwpXG4gICAgICAuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJ2aXNpYmlsaXR5OiBoaWRkZW47IGRpc3BsYXk6IGlubGluZS1ibG9jaztcIilcbiAgICAgIC5zZXRIdG1sKGxhYmVsLmlubmVyVGV4dClcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmFwcGVuZENoaWxkKGR1bW15RWxlbWVudClcblxuICAgIGxldCB3aWR0aCA9IGR1bW15RWxlbWVudC5lbGVtZW50LmNsaWVudFdpZHRoIC8gMlxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLnJlbW92ZUNoaWxkKGR1bW15RWxlbWVudClcblxuICAgIGNvbnN0IGZsb2F0UG9zaXRpb24gPSBsZWZ0ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCJcblxuICAgIGlmICh3aWR0aCA8IE1BUkdJTl9USUNLKSB7XG4gICAgICAvLyBjZW50ZXIgc21hbGwgaXRlbXMgb24gdGhlIHRpY2tcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGAke2Zsb2F0UG9zaXRpb259OiAke01BUkdJTl9USUNLIC0gTWF0aC5mbG9vcih3aWR0aCl9cHg7IHRleHQtYWxpZ246ICR7ZmxvYXRQb3NpdGlvbn07YClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2Zvcm1hdE91dHB1dCh2YWx1ZTogbnVtYmVyLCBzaG9ydDogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLl9mb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mb3JtYXR0ZXIodmFsdWUsIHNob3J0KVxuICAgIH1cblxuICAgIGNvbnN0IHN0ciA9IHBhcnNlRmxvYXQodmFsdWUudG9GaXhlZCgyKSlcbiAgICByZXR1cm4gc3RyLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYW5kIHVwZGF0ZXMgdGhlIHJhbmdlIHZhbHVlLlxuICAgKiBAcGFyYW0ge3ZhbHVlfSB0aGUgbmV3IHZhbHVlIHRvIHNldC5cbiAgICogQHBhcmFtIHt1cGRhdGV9IHRydWUgaWYgdGhlIFVJIHNob3VsZCBiZSB1cGRhdGVkOyBvdGhlcndpc2UgZmFsc2UuXG4gICAqIEBwYXJhbSB7YW5pbWF0ZX0gdHJ1ZSBpZiB0aGUgVUkgdXBkYXRlIHNob3VsZCBiZSBhbmltYXRlZDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9zZXRWYWx1ZShcbiAgICB2YWx1ZTogbnVtYmVyLFxuICAgIHVwZGF0ZSA9IHRydWUsXG4gICAgYW5pbWF0ZSA9IGZhbHNlXG4gICkge1xuICAgIGxldCB2YWwgPSBjbGFtcCh2YWx1ZSwgdGhpcy5fbWluVmFsdWUsIHRoaXMuX21heFZhbHVlKVxuICAgIGxldCBwb3NpdGlvblxuXG4gICAgaWYgKHRoaXMuX3RpY2tzV3JhcHBlci5lbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMSkgeyAvLyBhdCBsZWFzdCAyIHRpY2tzIHByZXNlbnRcbiAgICAgIGNvbnN0IHNuYXBWYWx1ZSA9IHRoaXMuX2dldFNuYXBWYWx1ZSh2YWwpXG4gICAgICBwb3NpdGlvbiA9IHNuYXBWYWx1ZS5wb3NpdGlvblxuICAgICAgdmFsID0gc25hcFZhbHVlLnZhbHVlXG4gICAgfSBlbHNlIGlmICh0aGlzLl90aWNrc1dyYXBwZXIuZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkgeyAvLyBvbmx5IDEgdGljayBwcmVzZW50XG4gICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gKGJ1dCBpdCBkb2VzLCBlLmcuIHdoZW4gZ2VuZXJhdGluZyBTbGlkZXJzIGJhc2VkIG9uIGluY29tcGxldGUgZGF0YSkuXG4gICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIGZpcnN0IHRpY2sgcG9zaXRpb24gYW5kIGRpc2FibGUgdGhlIGNvbXBvbmVudC5cbiAgICAgIHBvc2l0aW9uID0gdGhpcy5fZ2V0U25hcFBvc2l0aW9uKHZhbCkucG9zaXRpb25cbiAgICAgIHRoaXMuZGlzYWJsZSgpXG4gICAgfSBlbHNlIHsgLy8gbm8gdGlja3MgcHJlc2VudCwgZS5nLiBcIkZyZWUgU2xpZGVyXCJcbiAgICAgIHBvc2l0aW9uID0gKHRoaXMuX3RyYWNrV2lkdGggLyB0aGlzLl90cmFja1ZhbHVlVG90YWwpICogKHZhbHVlIC0gdGhpcy5fbWluVmFsdWUpXG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LnZhbHVlID0gU3RyaW5nKHZhbClcblxuICAgIGlmICh0aGlzLl90aHVtYlZhbHVlKSB7XG4gICAgICB0aGlzLl90aHVtYlZhbHVlLnNldEh0bWwodGhpcy5fZm9ybWF0T3V0cHV0KHZhbCwgdHJ1ZSkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX291dHB1dExhYmVsKSB7XG4gICAgICB0aGlzLl9vdXRwdXRMYWJlbC5zZXRIdG1sKHRoaXMuX2Zvcm1hdE91dHB1dCh2YWwsIGZhbHNlKSlcbiAgICB9XG5cbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbihwb3NpdGlvbiwgZmFsc2UsIGZhbHNlLCBhbmltYXRlKVxuICAgICAgdGhpcy5fdXBkYXRlVGlja1N0YXRlKClcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJpbnB1dFwiKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSByYW5nZSBzbGlkZXIuXG4gICAqL1xuICBzZXQgdmFsdWUodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuX3NldFZhbHVlKHZhbHVlLCB0cnVlLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5lbGVtZW50LnZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlIHRoZSBjb21wb25lbnQgdG8gcmUtbGF5b3V0IGl0c2VsZi5cbiAgICovXG4gIHB1YmxpYyBsYXlvdXQoKSB7XG4gICAgdGhpcy5fZ3JhYlBvc2l0aW9uID0gTWF0aC5yb3VuZCh0aGlzLl9yYW5nZVRodW1iLmVsZW1lbnQub2Zmc2V0V2lkdGggLyAyKVxuICAgIGNvbnN0IHRpY2tJdGVtcyA9IHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7Q0xBU1NfVElDS31gKVxuICAgIGNvbnN0IHRpY2tzT2Zmc2V0ID0gdGlja0l0ZW1zICYmIHRpY2tJdGVtcy5sZW5ndGggPiAwID8gKDIgKiBNQVJHSU5fVElDSykgOiBNQVJHSU5fVElDS1xuXG4gICAgdGhpcy5fdHJhY2tXaWR0aCA9IHRoaXMuX3JhbmdlVHJhY2suZWxlbWVudC5vZmZzZXRXaWR0aCAtIHRpY2tzT2Zmc2V0XG5cbiAgICB0aGlzLl90cmFja1Bvc2l0aW9uTWluID0gMFxuICAgIHRoaXMuX3RyYWNrUG9zaXRpb25NYXggPSB0aGlzLl9yYW5nZVRyYWNrLmVsZW1lbnQuY2xpZW50V2lkdGggLSB0aGlzLl9yYW5nZVRodW1iLmVsZW1lbnQub2Zmc2V0V2lkdGggKyAxXG4gICAgdGhpcy5fdHJhY2tMZWZ0UG9zaXRpb24gPSB0aGlzLl9yYW5nZVRyYWNrLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIE1BUkdJTl9USUNLXG5cbiAgICBsZXQgaXRlbUNvdW50ID0gdGlja0l0ZW1zLmxlbmd0aCAtIDFcblxuICAgIHRoaXMuX2l0ZW1XaWR0aCA9IHRoaXMuX3RyYWNrV2lkdGggLyBpdGVtQ291bnRcbiAgICBjb25zdCBvdXRlckl0ZW1zV2lkdGggPSAodGhpcy5faXRlbVdpZHRoICogMC41KSArIE1BUkdJTl9USUNLXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpdGVtQ291bnQ7IGkrKykge1xuICAgICAgbGV0IHdpZHRoID0gdGhpcy5faXRlbVdpZHRoXG5cbiAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGl0ZW1Db3VudCkge1xuICAgICAgICB3aWR0aCA9IG91dGVySXRlbXNXaWR0aFxuICAgICAgfVxuXG4gICAgICBsZXQgaXRlbSA9IG5ldyBEb21FbGVtZW50KHRpY2tJdGVtc1tpXSlcbiAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYHdpZHRoOiAke01hdGguZmxvb3Iod2lkdGgpfXB4O2ApXG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IGZpcnN0IGFuZCBsYXN0IGxhYmVsIHBvc2l0aW9uc1xuICAgIGlmICh0aWNrSXRlbXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5fYWRqdXN0VGlja0xhYmVsUG9zaXRpb24odGlja0l0ZW1zWzBdLCB0cnVlKVxuICAgICAgdGhpcy5fYWRqdXN0VGlja0xhYmVsUG9zaXRpb24odGlja0l0ZW1zW3RpY2tJdGVtcy5sZW5ndGggLSAxXSwgZmFsc2UpXG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHRoZSB2YWx1ZVxuICAgIHRoaXMuX3NldFZhbHVlKHBhcnNlRmxvYXQodGhpcy5lbGVtZW50LnZhbHVlKSwgdHJ1ZSwgZmFsc2UpXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudHMgYW5kIGZyZWVzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpO1xuXG4gICAgKHRoaXMgYXMgYW55KS5fZG93bkhhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX21vdmVIYW5kbGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9lbmRIYW5kbGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9mb2N1c0hhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX2JsdXJIYW5kbGVyID0gbnVsbDtcblxuICAgICh0aGlzIGFzIGFueSkuZWxlbWVudCA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fcmFuZ2VDb250YWluZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX3dyYXBwZXJFbGVtZW50ID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBkZXN0cm95KCkgaW5zdGVhZC5cbiAgICogQHRvZG8gcmVtb3ZlIGluIHZlcnNpb24gMi4wLjBcbiAgICovXG4gIHB1YmxpYyBkZXN0b3koKSB7XG4gICAgdGhpcy5kZXN0cm95KClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb21wb25lbnQgdG8gdGhlIGVuYWJsZWQgc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgZW5hYmxlKCkge1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnJlbW92ZUNsYXNzKENMQVNTX0RJU0FCTEVEKVxuXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX2Rvd25IYW5kbGVyKVxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fZG93bkhhbmRsZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0hhbmRsZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9ibHVySGFuZGxlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb21wb25lbnQgdG8gdGhlIGRpc2FibGVkIHN0YXRlLlxuICAgKi9cbiAgcHVibGljIGRpc2FibGUoKSB7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5fZG93bkhhbmRsZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9lbmRIYW5kbGVyKVxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9tb3ZlSGFuZGxlcilcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fZG93bkhhbmRsZXIpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0hhbmRsZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9ibHVySGFuZGxlcilcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZTxIVE1MSW5wdXRFbGVtZW50PihcImlucHV0W3R5cGU9J3JhbmdlJ11cIiwgKGUpID0+IHtcbiAgICBuZXcgUmFuZ2UoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmFuZ2VcbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIHByZXZlbnREZWZhdWx0LCBmaW5kLCByZW1vdmUsIGludGVybmV0RXhwbG9yZXJPckVkZ2VWZXJzaW9uLCBzY3JvbGxJbnRvVmlldyB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgKiBhcyBJbnB1dHMgZnJvbSBcIi4uL0lucHV0c1wiXG5pbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IENMQVNTX1BMQUNFSE9MREVSID0gXCJzZWxlY3RfX3BsYWNlaG9sZGVyXCJcbmNvbnN0IENMQVNTX1RIVU1CID0gXCJzZWxlY3RfX3RodW1iXCJcbmNvbnN0IENMQVNTX0JVVFRPTiA9IFwic2VsZWN0X19idXR0b25cIlxuY29uc3QgQ0xBU1NfRFJPUERPV04gPSBcInNlbGVjdF9fZHJvcGRvd25cIlxuXG5jb25zdCBDTEFTU19PUEVOID0gXCJzZWxlY3QtLW9wZW5cIlxuY29uc3QgQ0xBU1NfQ0xPU0VEID0gXCJzZWxlY3QtLWNsb3NlZFwiXG5jb25zdCBDTEFTU19ESVNBQkxFRCA9IFwic2VsZWN0LS1kaXNhYmxlZFwiXG5jb25zdCBDTEFTU19GSUxURVJBQkxFID0gXCJzZWxlY3QtLWZpbHRlcmFibGVcIlxuXG5jb25zdCBDTEFTU19JVEVNID0gXCJkcm9wZG93bi1pdGVtXCJcbmNvbnN0IENMQVNTX0lURU1fU0VMRUNURUQgPSBcImRyb3Bkb3duLWl0ZW0tLXNlbGVjdGVkXCJcbmNvbnN0IENMQVNTX0lURU1fRk9DVVNFRCA9IFwiZHJvcGRvd24taXRlbS0tZm9jdXNlZFwiXG5jb25zdCBDTEFTU19JVEVNX0RJU0FCTEVEID0gXCJkcm9wZG93bi1pdGVtLS1kaXNhYmxlZFwiXG5cbmNvbnN0IENMQVNTX0dST1VQX0lURU0gPSBcImRyb3Bkb3duLWdyb3VwXCJcbmNvbnN0IENMQVNTX0dST1VQX0hFQURFUiA9IFwiZHJvcGRvd24tZ3JvdXBfX2l0ZW1cIlxuXG5jb25zdCBRVUVSWV9NRVNTQUdFID0gXCIubWVzc2FnZVwiXG5cbmNvbnN0IFRJTUVPVVRfQ0xPU0UgPSAxNTBcbmNvbnN0IFRJTUVPVVRfQkxVUiA9IDQwMFxuXG4vKipcbiAqIFRoZSBzZWxlY3QgY29tcG9uZW50IEFQSS5cbiAqL1xuY2xhc3MgU2VsZWN0IGV4dGVuZHMgRG9tRWxlbWVudDxIVE1MU2VsZWN0RWxlbWVudD4ge1xuICBwcml2YXRlIF9vcGVuQnlGb2N1czogYm9vbGVhblxuICBwcml2YXRlIF9tdWx0aXNlbGVjdGlvbjogYm9vbGVhblxuICBwcml2YXRlIF9jbGlja0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9oYW5kbGVEcm9wZG93bkNsaWNrOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfa2V5ZG93bkhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9mb2N1c0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9ibHVySGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3dpbmRvd0NsaWNrSGFuZGxlcjogKGU6IE1vdXNlRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfZmlsdGVyS2V5ZG93bkhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9maWx0ZXJLZXl1cEhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9maWx0ZXJGb2N1c0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX3dyYXBwZXJFbGVtZW50ITogRG9tRWxlbWVudFxuICBwcml2YXRlIF9kcm9wZG93bkVsZW1lbnQhOiBEb21FbGVtZW50PEhUTUxFbGVtZW50PlxuXG4gIHByaXZhdGUgX3NlbGVjdEJ1dHRvbkVsZW1lbnQhOiBEb21FbGVtZW50XG4gIHByaXZhdGUgX3RodW1iRWxlbWVudCE6IERvbUVsZW1lbnRcblxuICBwcml2YXRlIF9wbGFjZWhvbGRlck9wdGlvbj86IEhUTUxPcHRpb25FbGVtZW50XG4gIHByaXZhdGUgX3BsYWNlaG9sZGVyRWxlbWVudCE6IERvbUVsZW1lbnRcbiAgcHJpdmF0ZSBfcGxhY2Vob2xkZXJUZXh0ITogc3RyaW5nXG5cbiAgcHJpdmF0ZSBfbGFzdEhhbmRsZWRFdmVudD86IEV2ZW50XG4gIHByaXZhdGUgX2xhc3RTZWxlY3RlZE9wdGlvbj86IEhUTUxPcHRpb25FbGVtZW50XG5cbiAgLy8gTWluaW11bSBmaWx0ZXIgbGVuZ3RoXG4gIHByaXZhdGUgX21pbkZpbHRlckxlbmd0aCA9IDJcblxuICAvLyBUaGUga2V5d29yZCB0aGUgU2VsZWN0IGlzIGN1cnJlbnRseSBmaWx0ZXJlZCBieVxuICBwcml2YXRlIF9hY3RpdmVGaWx0ZXI/OiBzdHJpbmdcblxuICAvLyBUaGUgb3B0aW9ucyB0aGUgU2VsZWN0IHdhcyBpbml0aWFsbHkgY3JlYXRlZCB1cG9uXG4gIC8vIFRoZXNlIHdpbGwgYmUgdXNlZCBhcyBhIGJhc2lzIGZvciBmaWx0ZXJpbmdcbiAgcHJpdmF0ZSBfaW5pdGlhbE9wdGlvbnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmVsZW1lbnQuY2hpbGRyZW4pXG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTFNlbGVjdEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fb3BlbkJ5Rm9jdXMgPSBmYWxzZVxuXG4gICAgLy8gQ2hlY2sgZm9yIG11bHRpLXNlbGVjdGlvblxuICAgIHRoaXMuX211bHRpc2VsZWN0aW9uID0gdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZShcIm11bHRpcGxlXCIpID09PSB0cnVlXG5cbiAgICAvLyBTZXR1cCBldmVudCBjb250ZXh0XG4gICAgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2sgPSB0aGlzLl9oYW5kbGVDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fa2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcylcbiAgICB0aGlzLl9mb2N1c0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVGb2N1cy5iaW5kKHRoaXMpXG4gICAgdGhpcy5fYmx1ckhhbmRsZXIgPSB0aGlzLl9oYW5kbGVCbHVyLmJpbmQodGhpcylcbiAgICB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVXaW5kb3dDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fZmlsdGVyS2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVGaWx0ZXJLZXlkb3duLmJpbmQodGhpcylcbiAgICB0aGlzLl9maWx0ZXJLZXl1cEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVGaWx0ZXJLZXl1cC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fZmlsdGVyRm9jdXNIYW5kbGVyID0gdGhpcy5faGFuZGxlRmlsdGVyRm9jdXMuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHNlbGVjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGluc3BlY3RzIHRoZSBzZWxlY3QgZGVmaW5pdGlvbiBhbmQgaXRzIG9wdGlvbnMgYW5kXG4gICAqIGdlbmVyYXRlcyBuZXcgc3R5bGFibGUgRE9NIGVsZW1lbnRzIGFyb3VuZCB0aGUgb3JpZ2luYWwgc2VsZWN0LWVsZW1lbnRcbiAgICogZGVmaW5pdGlvbnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRPcHRpb24gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIm9wdGlvbltzZWxlY3RlZF1cIikgYXMgSFRNTE9wdGlvbkVsZW1lbnRcbiAgICBjb25zdCBmaXJzdE9wdGlvbiA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwib3B0aW9uXCIpIGFzIEhUTUxPcHRpb25FbGVtZW50XG5cbiAgICAvLyBQZXIgZGVmYXVsdCwgc2V0IHRoZSBsYXN0IHNlbGVjdGVkIG9wdGlvbiB0byBlaXRoZXIgdGhlIG9wdGlvbiB3aXRoIGEgXCJzZWxlY3RlZFwiIGF0dHJpYnV0ZSxcbiAgICAvLyBvciwgaWYgbm90IGZvdW5kLCB0byB0aGUgZmlyc3QgYXZhaWxhYmxlIG9wdGlvblxuICAgIHRoaXMuX2xhc3RTZWxlY3RlZE9wdGlvbiA9IHNlbGVjdGVkT3B0aW9uIHx8IGZpcnN0T3B0aW9uXG5cbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50ISlcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19DTE9TRUQpXG5cbiAgICBmb3IgKGxldCBjbHMgb2YgdGhpcy5jbGFzc2VzKSB7XG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hZGRDbGFzcyhjbHMpXG4gICAgfVxuXG4gICAgdGhpcy5fZHJvcGRvd25FbGVtZW50ID0gbmV3IERvbUVsZW1lbnQ8SFRNTEVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfRFJPUERPV04pXG5cbiAgICBpZiAoaW50ZXJuZXRFeHBsb3Jlck9yRWRnZVZlcnNpb24oKSA+IDAgJiYgaW50ZXJuZXRFeHBsb3Jlck9yRWRnZVZlcnNpb24oKSA8IDEyKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgSUUgYnJvd3NlcnMgMTEgYW5kIGVhcmxpZXIgd2hlcmUgZm9jdXNpbmdcbiAgICAgIC8vIGEgc2Nyb2xsYWJsZSBkcm9wZG93biBsaXN0IHdpbGwgY2xvc2UgdGhlIGRyb3Bkb3duIHByZW1hdHVyZWx5LlxuICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCkpXG4gICAgfVxuXG4gICAgdGhpcy5fc2V0dXBUYXJnZXQoKVxuICAgIHRoaXMuX3NldHVwUGxhY2Vob2xkZXIoKVxuXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fZHJvcGRvd25FbGVtZW50KVxuXG4gICAgdGhpcy5fY3JlYXRlT3B0aW9ucyh0aGlzLmVsZW1lbnQpXG5cbiAgICB0aGlzLl91cGRhdGVTaXplKClcbiAgICB0aGlzLl91cGRhdGVNZXNzYWdlKClcblxuICAgIGlmICh0aGlzLmVsZW1lbnQuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlKClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX3NldHVwVGFyZ2V0KCkge1xuICAgIC8vIG1vdmUgdGhlIGlkIGZyb20gdGhlIHNlbGVjdCBlbGVtZW50IHRvIHRoZSB3cmFwcGVyXG4gICAgY29uc3QgaWQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaWRcIilcbiAgICBpZiAoaWQpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKVxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpXG4gICAgfVxuXG4gICAgLy8gQXBwbHkgdGhlIHRhYiBpbmRleFxuICAgIGNvbnN0IHRhYkluZGV4ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpXG4gICAgaWYgKHRhYkluZGV4KSB7XG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLCB0YWJJbmRleClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX3NldHVwUGxhY2Vob2xkZXIoKSB7XG4gICAgaWYgKCF0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX0JVVFRPTilcblxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fc2VsZWN0QnV0dG9uRWxlbWVudClcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3RodW1iRWxlbWVudCkge1xuICAgICAgdGhpcy5fdGh1bWJFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX1RIVU1CKVxuXG4gICAgICBsZXQgdGh1bWJJY29uID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKFwidGh1bWItaWNvblwiKVxuXG4gICAgICBsZXQgbG9hZGVyID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKFwibG9hZGVyLXNwaW5uZXJcIilcbiAgICAgICAgLmFkZENsYXNzKFwibG9hZGVyLXNwaW5uZXItLXNtYWxsXCIpXG5cbiAgICAgIHRoaXMuX3RodW1iRWxlbWVudC5hcHBlbmRDaGlsZChsb2FkZXIpXG4gICAgICB0aGlzLl90aHVtYkVsZW1lbnQuYXBwZW5kQ2hpbGQodGh1bWJJY29uKVxuICAgICAgdGhpcy5fc2VsZWN0QnV0dG9uRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl90aHVtYkVsZW1lbnQpXG4gICAgfVxuXG4gICAgbGV0IHBsYWNlaG9sZGVyVGV4dCA9IFwiXCJcblxuICAgIHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJvcHRpb25bc2VsZWN0ZWRdW2Rpc2FibGVkXVwiKSBhcyBIVE1MT3B0aW9uRWxlbWVudCB8fCB1bmRlZmluZWRcblxuICAgIGlmICh0aGlzLl9wbGFjZWhvbGRlck9wdGlvbikge1xuICAgICAgcGxhY2Vob2xkZXJUZXh0ID0gRG9tLnRleHQodGhpcy5fcGxhY2Vob2xkZXJPcHRpb24pXG5cbiAgICAgIGlmICh0aGlzLl9tdWx0aXNlbGVjdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlck9wdGlvbi5zZWxlY3RlZCA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHNlbGVjdGVkT3B0aW9uID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJvcHRpb25bc2VsZWN0ZWRdOm5vdChbZGlzYWJsZWRdKVwiKVxuXG4gICAgaWYgKHNlbGVjdGVkT3B0aW9uKSB7XG4gICAgICBwbGFjZWhvbGRlclRleHQgPSBEb20udGV4dChzZWxlY3RlZE9wdGlvbilcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudCkge1xuICAgICAgLy8gV2hlbiB0aGUgU2VsZWN0IGlzIGZpbHRlcmFibGUsIGNyZWF0ZSBhbiBcImlucHV0XCIgYXMgdGhlIHBsYWNlaG9sZGVyIGVsZW1lbnQsIG90aGVyd2lzZSBhIFwic3BhblwiXG4gICAgICBpZiAodGhpcy5faXNGaWx0ZXJhYmxlKCkpIHtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJpbnB1dFwiKVxuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIChlKSA9PiB0aGlzLl9oYW5kbGVGaWx0ZXJLZXl1cChlKSlcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChlKSA9PiB0aGlzLl9oYW5kbGVGaWx0ZXJLZXlkb3duKGUpKVxuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIChlKSA9PiB0aGlzLl9oYW5kbGVGaWx0ZXJGb2N1cyhlKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwic3BhblwiKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfUExBQ0VIT0xERVIpXG4gICAgICB0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudClcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRQbGFjZWhvbGRlcihwbGFjZWhvbGRlclRleHQpXG4gICAgdGhpcy5fcGxhY2Vob2xkZXJUZXh0ID0gcGxhY2Vob2xkZXJUZXh0XG5cbiAgICBpZiAoc2VsZWN0ZWRPcHRpb24gJiYgc2VsZWN0ZWRPcHRpb24gIT09IHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uKSB7XG4gICAgICB0aGlzLl91cGRhdGVQbGFjZWhvbGRlcih0cnVlKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfdXBkYXRlTWVzc2FnZSgpIHtcbiAgICBjb25zdCBtZXNzYWdlTm9kZSA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9NRVNTQUdFKVxuICAgIGlmIChtZXNzYWdlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3IERvbUVsZW1lbnQobWVzc2FnZU5vZGUpKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2lzT3B0R3JvdXAoZWxlbWVudDogRWxlbWVudCk6IGVsZW1lbnQgaXMgSFRNTE9wdEdyb3VwRWxlbWVudCB7XG4gICAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIk9QVEdST1VQXCJcbiAgfVxuXG4gIHByaXZhdGUgX2lzT3B0aW9uKGVsZW1lbnQ6IEVsZW1lbnQpOiBlbGVtZW50IGlzIEhUTUxPcHRpb25FbGVtZW50IHtcbiAgICByZXR1cm4gZWxlbWVudC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiT1BUSU9OXCJcbiAgfVxuXG4gIHByb3RlY3RlZCBfY3JlYXRlT3B0aW9ucyhlbGVtZW50OiBIVE1MU2VsZWN0RWxlbWVudCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGNoaWxkID0gZWxlbWVudC5jaGlsZHJlbltpXVxuXG4gICAgICBpZiAodGhpcy5faXNPcHRHcm91cChjaGlsZCkpIHtcbiAgICAgICAgdGhpcy5fYXBwZW5kR3JvdXAoY2hpbGQgYXMgSFRNTE9wdEdyb3VwRWxlbWVudClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzT3B0aW9uKGNoaWxkKSkge1xuICAgICAgICBsZXQgb3B0aW9uID0gdGhpcy5fY3JlYXRlT3B0aW9uKGNoaWxkIGFzIEhUTUxPcHRpb25FbGVtZW50KVxuXG4gICAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgICB0aGlzLl9kcm9wZG93bkVsZW1lbnQuYXBwZW5kQ2hpbGQob3B0aW9uKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jcmVhdGVPcHRpb24ob3B0aW9uOiBIVE1MT3B0aW9uRWxlbWVudCkge1xuICAgIGxldCBodG1sID0gb3B0aW9uLmlubmVySFRNTFxuXG4gICAgaWYgKHRoaXMuX2FjdGl2ZUZpbHRlcikge1xuICAgICAgY29uc3Qgc2FuaXRpemVkQWN0aXZlRmlsdGVyID0gdGhpcy5fYWN0aXZlRmlsdGVyLnJlcGxhY2UoL1stXFxcXF4kKis/LigpfFtcXF17fV0vZywgXCJcXFxcJCZcIilcbiAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UobmV3IFJlZ0V4cChgKCR7c2FuaXRpemVkQWN0aXZlRmlsdGVyfSlgLCBcImdpXCIpLCBcIjxzdHJvbmc+JDE8L3N0cm9uZz5cIilcbiAgICB9XG5cbiAgICBsZXQgb3B0ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19JVEVNKVxuICAgICAgLnNldEh0bWwoaHRtbClcblxuICAgIGlmIChvcHRpb24uc2VsZWN0ZWQpIHtcbiAgICAgIG9wdC5hZGRDbGFzcyhDTEFTU19JVEVNX1NFTEVDVEVEKVxuICAgIH1cblxuICAgIGlmIChvcHRpb24uZGlzYWJsZWQpIHtcbiAgICAgIG9wdC5hZGRDbGFzcyhDTEFTU19JVEVNX0RJU0FCTEVEKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5faXNQbGFjZWhvbGRlcihvcHRpb24pKSB7XG4gICAgICBvcHQuc2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiLCBvcHRpb24udmFsdWUpXG4gICAgICByZXR1cm4gb3B0XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgcHJvdGVjdGVkIF9hcHBlbmRHcm91cChvcHRncm91cDogSFRNTE9wdEdyb3VwRWxlbWVudCkge1xuICAgIGxldCBsYWJlbCA9IG9wdGdyb3VwLmdldEF0dHJpYnV0ZShcImxhYmVsXCIpIVxuXG4gICAgbGV0IGdyb3VwID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19HUk9VUF9JVEVNKVxuXG4gICAgbGV0IGdyb3VwSGVhZGVyID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19HUk9VUF9IRUFERVIpXG4gICAgICAuc2V0SHRtbChsYWJlbClcblxuICAgIGdyb3VwLmFwcGVuZENoaWxkKGdyb3VwSGVhZGVyKVxuXG4gICAgbGV0IG9wdGlvbnMgPSBvcHRncm91cC5xdWVyeVNlbGVjdG9yQWxsKFwib3B0aW9uXCIpXG4gICAgZm9yIChsZXQgZW50cnkgb2Ygb3B0aW9ucykge1xuICAgICAgbGV0IG9wdGlvbiA9IHRoaXMuX2NyZWF0ZU9wdGlvbihlbnRyeSlcbiAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQob3B0aW9uKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5hcHBlbmRDaGlsZChncm91cClcbiAgICByZXR1cm4gZ3JvdXBcbiAgfVxuXG4gIHByb3RlY3RlZCBfdXBkYXRlU2l6ZSgpIHtcbiAgICAvLyBOb3RlOiBNaXJyb3JpbmcgdGhlIERPTSBhbmQgbWVhc3VyaW5nIHRoZSBpdGVtcyB1c2luZyB0aGVpciBjbGllbnRXaWR0aCB3YXMgdmVyeVxuICAgIC8vIHVucmVsaWFibGUsIHRoZXJlZm9yZSBtZWFzdXJpbmcgd2FzIHN3aXRjaGVkIHRvIHRoZSBuZXcgSFRNTDUgbWVhc3VyZVRleHQgbWV0aG9kXG4gICAgLy8gbWFyZ2lucyBhbmQgcGFkZGluZ3MgYXJyb3VuZCB0aGUgdGV4dCBhcmUgY29waWVkIGZyb20gdGhlIG9yaWdpbmFsIHBsYWNlaG9sZGVyIGl0ZW1zXG4gICAgLy8gZGltZW5zaW9uXG4gICAgY29uc3QgcGxhY2Vob2xkZXJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudC5lbGVtZW50KVxuXG4gICAgbGV0IHBhZGRpbmdSaWdodCA9IHBhcnNlRmxvYXQocGxhY2Vob2xkZXJTdHlsZS5wYWRkaW5nUmlnaHQhKVxuICAgIGxldCBwYWRkaW5nTGVmdCA9IHBhcnNlRmxvYXQocGxhY2Vob2xkZXJTdHlsZS5wYWRkaW5nTGVmdCEpXG5cbiAgICBsZXQgZm9udCA9IHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudC5jc3MoXCJmb250XCIpXG4gICAgbGV0IHRleHRXaWR0aCA9IERvbS50ZXh0V2lkdGgodGhpcy5fcGxhY2Vob2xkZXJUZXh0LCBmb250KVxuICAgIGxldCBtYXhXaWR0aCA9IHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0ICsgdGV4dFdpZHRoXG5cbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7Q0xBU1NfSVRFTX1gKVxuICAgIGZvciAobGV0IGVudHJ5IG9mIG9wdGlvbnMpIHtcbiAgICAgIGxldCB3aWR0aCA9IERvbS50ZXh0V2lkdGgoRG9tLnRleHQoZW50cnkpLCBmb250KSArIHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0XG5cbiAgICAgIGlmICh3aWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgIG1heFdpZHRoID0gd2lkdGhcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHByb3RlY3RlZCBfaXNCdXR0b25UYXJnZXQodGFyZ2V0OiBFdmVudFRhcmdldCkge1xuICAgIHJldHVybiAodGFyZ2V0ID09PSB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50IHx8XG4gICAgICB0YXJnZXQgPT09IHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudC5lbGVtZW50IHx8XG4gICAgICB0YXJnZXQgPT09IHRoaXMuX3NlbGVjdEJ1dHRvbkVsZW1lbnQuZWxlbWVudCB8fFxuICAgICAgdGFyZ2V0ID09PSB0aGlzLl90aHVtYkVsZW1lbnQuZWxlbWVudClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaXNEcm9wZG93blRhcmdldCh0YXJnZXQ6IEV2ZW50VGFyZ2V0KSB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQgYXMgSFRNTEVsZW1lbnRcbiAgICB3aGlsZSAoY3VycmVudCAhPT0gdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQgJiYgY3VycmVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnRFbGVtZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnQgPT09IHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgVUkgaWYgdGhlIHNlbGVjdGlvbiBoYXMgY2hhbmdlZCBhbmQgbWFrZXMgc3VyZSB0aGVcbiAgICogc2VsZWN0IGNvbnRyb2wgYW5kIHRoZSBnZW5lcmF0ZWQgbWFya3VwIGFyZSBzeW5jaHJvbml6ZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX3NlbGVjdGVkSXRlbUNoYW5nZWQoXG4gICAgbmV3SXRlbTogRWxlbWVudCxcbiAgICBhdXRvQ2xvc2UgPSB0cnVlLFxuICAgIG11bHRpc2VsZWN0ID0gZmFsc2VcbiAgKSB7XG4gICAgY29uc3Qgb2xkSXRlbXMgPSB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19JVEVNX1NFTEVDVEVEfWApXG5cbiAgICBpZiAoIW5ld0l0ZW0pIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5jbG9zZSgpLCBUSU1FT1VUX0NMT1NFKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKERvbS5oYXNDbGFzcyhuZXdJdGVtLCBDTEFTU19JVEVNX0RJU0FCTEVEKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKChvbGRJdGVtcy5sZW5ndGggPT09IDApICYmICFuZXdJdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHNlbGVjdCB1bmRlZmluZWQgZWxlbWVudHNcIilcbiAgICB9XG5cbiAgICBsZXQgb2xkSXRlbSA9IG9sZEl0ZW1zWzBdXG5cbiAgICBpZiAobXVsdGlzZWxlY3QgPT09IHRydWUpIHtcbiAgICAgIG9sZEl0ZW0gPSBmaW5kKG9sZEl0ZW1zLCAoeCkgPT4geC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpID09PSBuZXdJdGVtLmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIikpIVxuICAgIH1cblxuICAgIGxldCBpc0Rlc2VsZWN0ID0gZmFsc2VcblxuICAgIGlmIChuZXdJdGVtICYmIG9sZEl0ZW0gJiYgb2xkSXRlbSA9PT0gbmV3SXRlbSkge1xuICAgICAgLy8gQ2xpY2sgb24gYSBwcmV2aW91c2x5IHNlbGVjdGVkIGVsZW1lbnQgLT4gZGVzZWxlY3RcbiAgICAgIGlzRGVzZWxlY3QgPSB0cnVlXG5cbiAgICAgIGlmICghdGhpcy5fcGxhY2Vob2xkZXJPcHRpb24gJiYgIW11bHRpc2VsZWN0KSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHBsYWNlaG9sZGVyIG9wdGlvbiwgbm9uIG11bHRpc2VsZWN0IG9wdGlvbnMgY2Fubm90IGJlIGRlc2VsZWN0ZWRcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLl9sYXN0U2VsZWN0ZWRPcHRpb25cbiAgICB9XG5cbiAgICBpZiAob2xkSXRlbSkge1xuICAgICAgLy8gUmVtb3ZlIHNlbGVjdGlvbiBvbiB0aGUgZWxlbWVudFxuICAgICAgbGV0IG9sZFZhbHVlID0gb2xkSXRlbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpXG4gICAgICBsZXQgb3B0RWxlbWVudCA9IGZpbmQodGhpcy5lbGVtZW50Lm9wdGlvbnMsICh4KSA9PiAheC5kaXNhYmxlZCAmJiB4LnZhbHVlID09PSBvbGRWYWx1ZSlcblxuICAgICAgaWYgKCFvcHRFbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG9wdGlvbiB3aXRoIHZhbHVlICR7b2xkVmFsdWV9IGRvZXMgbm90IGV4aXN0YClcbiAgICAgIH1cblxuICAgICAgLy8gVW5zZXQgU2VsZWN0IHZhbHVlXG4gICAgICBvcHRFbGVtZW50LnNlbGVjdGVkID0gZmFsc2VcbiAgICAgIERvbS5yZW1vdmVDbGFzcyhvbGRJdGVtLCBDTEFTU19JVEVNX1NFTEVDVEVEKVxuICAgIH1cblxuICAgIGlmICghaXNEZXNlbGVjdCkgeyAvLyBTZWxlY3QgYW4gb3B0aW9uXG4gICAgICAvLyBTZWxlY3QgYSBuZXcgaXRlbVxuICAgICAgbGV0IG5ld1ZhbHVlID0gbmV3SXRlbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpXG4gICAgICBsZXQgb3B0RWxlbWVudCA9IGZpbmQodGhpcy5lbGVtZW50Lm9wdGlvbnMsICh4KSA9PiAheC5kaXNhYmxlZCAmJiB4LnZhbHVlID09PSBuZXdWYWx1ZSlcblxuICAgICAgaWYgKCFvcHRFbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG9wdGlvbiB3aXRoIHZhbHVlICR7bmV3VmFsdWV9IGRvZXMgbm90IGV4aXN0YClcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IFNlbGVjdCB2YWx1ZVxuICAgICAgb3B0RWxlbWVudC5zZWxlY3RlZCA9IHRydWVcbiAgICAgIERvbS5hZGRDbGFzcyhuZXdJdGVtLCBDTEFTU19JVEVNX1NFTEVDVEVEKVxuXG4gICAgICAvLyBQcmVzZXJ2ZSBzZWxlY3Rpb25cbiAgICAgIHRoaXMuX2xhc3RTZWxlY3RlZE9wdGlvbiA9IG9wdEVsZW1lbnRcblxuICAgIH0gZWxzZSB7IC8vIERlc2VsZWN0IGFuIG9wdGlvblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiBmYWxsaW5nIGJhY2sgdG8gdGhlIHBsYWNlaG9sZGVyIChpZiBhbnkpXG4gICAgICBpZiAodGhpcy5fcGxhY2Vob2xkZXJPcHRpb24pIHtcbiAgICAgICAgdGhpcy5fbGFzdFNlbGVjdGVkT3B0aW9uID0gdGhpcy5fcGxhY2Vob2xkZXJPcHRpb25cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgaGFzU2VsZWN0ZWRJdGVtcyA9IHRydWVcblxuICAgIGlmICh0aGlzLl9tdWx0aXNlbGVjdGlvbiA9PT0gZmFsc2UgJiYgaXNEZXNlbGVjdCkge1xuICAgICAgLy8gSGFuZGxlIG5vIHNlbGVjdGlvbiBmb3Igbm9uLW11bHRpc2VsZWN0IHN0YXRlc1xuICAgICAgdGhpcy5fcGxhY2Vob2xkZXJPcHRpb24hLnNlbGVjdGVkID0gdHJ1ZVxuICAgICAgaGFzU2VsZWN0ZWRJdGVtcyA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX211bHRpc2VsZWN0aW9uID09PSB0cnVlICYmIHRoaXMuX2dldFNlbGVjdGVkT3B0aW9ucygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaGFzU2VsZWN0ZWRJdGVtcyA9IGZhbHNlXG4gICAgfVxuXG4gICAgLy8gUmVzZXQgdGhlIGZpbHRlciBpZiBmaWx0ZXJhYmxlXG4gICAgaWYgKHRoaXMuX2FjdGl2ZUZpbHRlcikge1xuICAgICAgdGhpcy5fY2xlYXJGaWx0ZXIoKVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVBsYWNlaG9sZGVyKGhhc1NlbGVjdGVkSXRlbXMpXG5cbiAgICAvLyBEaXNwYXRjaCB0aGUgY2hhbmdlZCBldmVudFxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNoYW5nZVwiKVxuXG4gICAgaWYgKGF1dG9DbG9zZSAmJiAhbXVsdGlzZWxlY3QpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgIH0sIFRJTUVPVVRfQ0xPU0UpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF91cGRhdGVQbGFjZWhvbGRlcihoYXNTZWxlY3RlZEl0ZW1zOiBib29sZWFuKSB7XG4gICAgbGV0IHRleHQgPSB0aGlzLl9wbGFjZWhvbGRlck9wdGlvbiA/IERvbS50ZXh0KHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uKSA6IFwiIFwiXG5cbiAgICBpZiAoaGFzU2VsZWN0ZWRJdGVtcyA9PT0gdHJ1ZSkge1xuICAgICAgbGV0IHNlbGVjdGVkSXRlbXMgPSB0aGlzLl9nZXRTZWxlY3RlZE9wdGlvbnMoKVxuXG4gICAgICBpZiAoc2VsZWN0ZWRJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRleHQgPSBcIlwiXG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2Ygc2VsZWN0ZWRJdGVtcykge1xuICAgICAgICAgIHRleHQgKz0gYCR7RG9tLnRleHQoaXRlbSl9LCBgXG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHRleHQubGVuZ3RoIC0gMilcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zZXRQbGFjZWhvbGRlcih0ZXh0KVxuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXRTZWxlY3RlZE9wdGlvbnMoKSB7XG4gICAgbGV0IHNlbGVjdGVkT3B0aW9uczogSFRNTE9wdGlvbkVsZW1lbnRbXSA9IFtdXG4gICAgaWYgKHRoaXMuZWxlbWVudC5vcHRpb25zKSB7XG4gICAgICBbXS5mb3JFYWNoLmNhbGwodGhpcy5lbGVtZW50Lm9wdGlvbnMsICgob3B0aW9uOiBIVE1MT3B0aW9uRWxlbWVudCkgPT4ge1xuICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICYmICFvcHRpb24uZGlzYWJsZWQpIHtcbiAgICAgICAgICBzZWxlY3RlZE9wdGlvbnMucHVzaChvcHRpb24pXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRPcHRpb25zXG4gIH1cblxuICAvKipcbiAgICogQ2xvbmUgYWxsIG9mIHRoZSBpbml0aWFsbHkgc2V0IG9wdGlvbnMgKGFuZCBvcHRncm91cHMpIGFuZCByZXR1cm5zIHRoZW0gaW4gYSBuZXcgYXJyYXkuXG4gICAqIFRoaXMgc2VydmVzIGFzIHRoZSBiYXNpcyBmb3IgZmlsdGVyaW5nLiBJZiBhIGZpbHRlciBpcyBwcmVzZW50LCBpdCB3aWxsIGJlIHJlc3BlY3RlZC5cbiAgICovXG4gIHByaXZhdGUgZ2V0SW5pdGlhbE9wdGlvbnMoKTogRWxlbWVudFtdIHtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9hY3RpdmVGaWx0ZXIgfHwgXCJcIlxuICAgIGNvbnN0IGZpbHRlcmVkOiBFbGVtZW50W10gPSBbXVxuICAgIGNvbnN0IGluaXRpYWxPcHRpb25zID0gdGhpcy5faW5pdGlhbE9wdGlvbnNcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5pdGlhbE9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkOiBFbGVtZW50ID0gaW5pdGlhbE9wdGlvbnNbaV0gYXMgRWxlbWVudFxuXG4gICAgICBpZiAodGhpcy5faXNPcHRHcm91cChjaGlsZCkpIHsgLy8gaGFuZGxlIDxvcHRncm91cD5cbiAgICAgICAgY29uc3Qgb3B0R3JvdXBDbG9uZTogRWxlbWVudCA9IGNoaWxkLmNsb25lTm9kZShmYWxzZSkgYXMgRWxlbWVudFxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZVxuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBvcHRpb25DbG9uZTogRWxlbWVudCA9IGNoaWxkLmNoaWxkcmVuW2pdLmNsb25lTm9kZSh0cnVlKSBhcyBFbGVtZW50XG5cbiAgICAgICAgICAvLyBBcHBlbmQgb24gbWF0Y2hcbiAgICAgICAgICBpZiAodGhpcy5fY29udGFpbnNXb3JkKG9wdGlvbkNsb25lLmlubmVySFRNTCwgZmlsdGVyKSkge1xuICAgICAgICAgICAgb3B0R3JvdXBDbG9uZS5hcHBlbmRDaGlsZChvcHRpb25DbG9uZSlcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1c2ggaWYgYW55IG1hdGNoZXMgZm91bmRcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgZmlsdGVyZWQucHVzaChvcHRHcm91cENsb25lKVxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNPcHRpb24oY2hpbGQpKSB7IC8vIGhhbmRsZSA8b3B0aW9uPlxuICAgICAgICBjb25zdCBvcHRpb25DbG9uZTogRWxlbWVudCA9IGNoaWxkLmNsb25lTm9kZSh0cnVlKSBhcyBFbGVtZW50XG5cbiAgICAgICAgLy8gUHVzaCBvbiBtYXRjaFxuICAgICAgICBpZiAodGhpcy5fY29udGFpbnNXb3JkKG9wdGlvbkNsb25lLmlubmVySFRNTCwgZmlsdGVyKSkge1xuICAgICAgICAgIGZpbHRlcmVkLnB1c2gob3B0aW9uQ2xvbmUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmlsdGVyZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSB0ZXh0IGNvbnRhaW5zIGEgZ2l2ZW4ga2V5d29yZCwgZS5nLiBpbiBcImNhXCIgaW4gXCJDYXJcIlxuICAgKi9cbiAgcHJpdmF0ZSBfY29udGFpbnNXb3JkKHRleHQ6IHN0cmluZywga2V5d29yZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRleHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKGtleXdvcmQudG9Mb3dlckNhc2UoKSkgPiAtMVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVGb2N1cygpIHtcbiAgICB0aGlzLm9wZW4oKVxuICAgIHRoaXMuX29wZW5CeUZvY3VzID0gdHJ1ZVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9vcGVuQnlGb2N1cyA9IGZhbHNlXG4gICAgfSwgVElNRU9VVF9CTFVSKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVCbHVyKCkge1xuICAgIHRoaXMuY2xvc2UoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVDbGljayhldmVudDogRXZlbnQpIHtcbiAgICBsZXQgaGFuZGxlZCA9IGZhbHNlXG5cbiAgICBpZiAodGhpcy5fbGFzdEhhbmRsZWRFdmVudCA9PT0gZXZlbnQpIHtcbiAgICAgIHRoaXMuX2xhc3RIYW5kbGVkRXZlbnQgPSB1bmRlZmluZWRcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc0J1dHRvblRhcmdldChldmVudC50YXJnZXQhKSAmJiB0aGlzLl9vcGVuQnlGb2N1cyA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIGhhbmRsZSBoZWFkZXIgaXRlbSBjbGlja3MgYW5kIHRvZ2dsZSBkcm9wZG93blxuICAgICAgdGhpcy50b2dnbGUoKVxuICAgICAgaGFuZGxlZCA9IHRydWVcbiAgICB9XG5cbiAgICBsZXQgbmV3SXRlbSA9IGV2ZW50LnRhcmdldCBhcyBFbGVtZW50XG5cbiAgICBpZiAoIWhhbmRsZWQgJiYgRG9tLmhhc0NsYXNzKG5ld0l0ZW0sIENMQVNTX0lURU0pKSB7XG4gICAgICAvLyBoYW5kbGUgY2xpY2tzIG9uIGRyb3Bkb3duIGl0ZW1zXG4gICAgICB0aGlzLl9zZWxlY3RlZEl0ZW1DaGFuZ2VkKG5ld0l0ZW0sIHRydWUsIHRoaXMuX211bHRpc2VsZWN0aW9uKVxuICAgICAgaGFuZGxlZCA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgdGhpcy5fbGFzdEhhbmRsZWRFdmVudCA9IGV2ZW50XG4gICAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVdpbmRvd0NsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2lzRHJvcGRvd25UYXJnZXQoZXZlbnQudGFyZ2V0ISkgfHwgdGhpcy5faXNCdXR0b25UYXJnZXQoZXZlbnQudGFyZ2V0ISkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY2xvc2UoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9mb2N1c09wdGlvblN0YXJ0aW5nV2l0aChrZXljb2RlOiBudW1iZXIsIHN0YXJ0SW5kZXg6IG51bWJlciwgb3B0aW9uczogTm9kZUxpc3RPZjxIVE1MRWxlbWVudD4pIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7IGluZGV4IDwgb3B0aW9ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGxldCBpdGVtID0gbmV3IERvbUVsZW1lbnQob3B0aW9uc1tpbmRleF0pXG4gICAgICBsZXQgdmFsdWUgPSBpdGVtLmlubmVyVGV4dC50b0xvd2VyQ2FzZSgpXG5cbiAgICAgIGlmIChpbmRleCA+IG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGluZGV4ID0gMFxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChJbnB1dHMuZ2V0S2V5VmFsdWUoa2V5Y29kZSkpKSB7XG4gICAgICAgIGxldCBuZXdPcHRpb24gPSBuZXcgRG9tRWxlbWVudChvcHRpb25zW2luZGV4XSlcblxuICAgICAgICBpZiAoIW5ld09wdGlvbi5oYXNDbGFzcyhDTEFTU19JVEVNX0RJU0FCTEVEKSkge1xuICAgICAgICAgIHNjcm9sbEludG9WaWV3KG9wdGlvbnNbaW5kZXhdKVxuICAgICAgICAgIG5ld09wdGlvbi5hZGRDbGFzcyhDTEFTU19JVEVNX0ZPQ1VTRUQpXG4gICAgICAgICAgcmV0dXJuIG5ld09wdGlvblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlS2V5ZG93bihldmVudDogRXZlbnQpIHtcbiAgICBjb25zdCBrZXlib2FyZEV2ZW50ID0gZXZlbnQgYXMgS2V5Ym9hcmRFdmVudFxuICAgIGxldCBldnQgPSBrZXlib2FyZEV2ZW50IHx8IHdpbmRvdy5ldmVudFxuICAgIGxldCBrZXljb2RlID0ga2V5Ym9hcmRFdmVudC53aGljaCB8fCBrZXlib2FyZEV2ZW50LmtleUNvZGVcblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0VTQ0FQRSkge1xuICAgICAgLy8gaGFuZGxlIEVzY2FwZSBrZXkgKEVTQylcbiAgICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgfVxuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX1VQIHx8IGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfRE9XTikge1xuICAgICAgLy8gVXAgYW5kIGRvd24gYXJyb3dzXG5cbiAgICAgIGxldCBvcHRpb25zID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19JVEVNfWApIGFzIE5vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+XG4gICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgbGV0IG5ld0luZGV4ID0gMFxuICAgICAgICBsZXQgb2xkT3B0aW9uXG5cbiAgICAgICAgbGV0IGZvY3VzZWRFbGVtZW50ID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZmluZChgLiR7Q0xBU1NfSVRFTV9GT0NVU0VEfWApXG4gICAgICAgIGxldCBzZWFyY2hGb3IgPSBmb2N1c2VkRWxlbWVudCA/IENMQVNTX0lURU1fRk9DVVNFRCA6IENMQVNTX0lURU1fU0VMRUNURURcblxuICAgICAgICBsZXQgbmV3RWxlbWVudFxuXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBvcHRpb25zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSBrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX0RPV04gPyAxIDogLTFcblxuICAgICAgICAgIGxldCBpdGVtID0gbmV3IERvbUVsZW1lbnQob3B0aW9uc1tpbmRleF0pXG5cbiAgICAgICAgICAvLyBzZWFyY2ggZm9yIHNlbGVjdGVkIG9yIGZvY3VzZWRFbGVtZW50IGVsZW1lbnRzXG4gICAgICAgICAgaWYgKGl0ZW0uaGFzQ2xhc3Moc2VhcmNoRm9yKSkge1xuICAgICAgICAgICAgb2xkT3B0aW9uID0gaXRlbVxuICAgICAgICAgICAgbmV3SW5kZXggPSBpbmRleFxuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIG5leHQgbm90IGRpc2FibGVkIGVsZW1lbnQgaW4gdGhlIGFwcHJvcHJpYXRlIGRpcmVjdGlvblxuICAgICAgICAgICAgZm9yIChsZXQgY291bnQgPSAwOyBjb3VudCA8IG9wdGlvbnMubGVuZ3RoOyBjb3VudCsrKSB7XG4gICAgICAgICAgICAgIG5ld0luZGV4ICs9IGRpcmVjdGlvblxuICAgICAgICAgICAgICBuZXdJbmRleCAlPSBvcHRpb25zLmxlbmd0aFxuXG4gICAgICAgICAgICAgIGlmIChuZXdJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBuZXdJbmRleCA9IG9wdGlvbnMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbmV3RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KG9wdGlvbnNbbmV3SW5kZXhdKVxuICAgICAgICAgICAgICBpZiAoIW5ld0VsZW1lbnQuaGFzQ2xhc3MoQ0xBU1NfSVRFTV9ESVNBQkxFRCkpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSBuZXcgZWxlbWVudCBmb2N1c2VkXG4gICAgICAgIHNjcm9sbEludG9WaWV3KG9wdGlvbnNbbmV3SW5kZXhdKVxuICAgICAgICBsZXQgbmV3T3B0aW9uID0gbmV3IERvbUVsZW1lbnQob3B0aW9uc1tuZXdJbmRleF0pXG4gICAgICAgIG5ld09wdGlvbi5hZGRDbGFzcyhDTEFTU19JVEVNX0ZPQ1VTRUQpXG5cbiAgICAgICAgaWYgKG9sZE9wdGlvbikge1xuICAgICAgICAgIG9sZE9wdGlvbi5yZW1vdmVDbGFzcyhDTEFTU19JVEVNX0ZPQ1VTRUQpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChJbnB1dHMuZ2V0S2V5VmFsdWUoa2V5Y29kZSkgJiYgIXRoaXMuX2lzRmlsdGVyYWJsZSgpKSB7XG4gICAgICAvLyBLZXlib2FyZCBrZXlzXG5cbiAgICAgIGxldCBvcHRpb25zID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19JVEVNfWApIGFzIE5vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+XG4gICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgbGV0IG9sZEZvY3VzSW5kZXggPSAwXG4gICAgICAgIGxldCBoYXNGb2N1c2VkT3B0aW9uID0gZmFsc2VcblxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgb3B0aW9ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBsZXQgaXRlbSA9IG5ldyBEb21FbGVtZW50KG9wdGlvbnNbaW5kZXhdKVxuXG4gICAgICAgICAgaWYgKGl0ZW0uaGFzQ2xhc3MoQ0xBU1NfSVRFTV9GT0NVU0VEKSkge1xuICAgICAgICAgICAgaXRlbS5yZW1vdmVDbGFzcyhDTEFTU19JVEVNX0ZPQ1VTRUQpXG5cbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGl0ZW0uaW5uZXJUZXh0LnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKElucHV0cy5nZXRLZXlWYWx1ZShrZXljb2RlKSkpIHtcbiAgICAgICAgICAgICAgaGFzRm9jdXNlZE9wdGlvbiA9IHRydWVcbiAgICAgICAgICAgICAgb2xkRm9jdXNJbmRleCA9IGluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5ld09wdGlvbiA9IHRoaXMuX2ZvY3VzT3B0aW9uU3RhcnRpbmdXaXRoKGtleWNvZGUsIGhhc0ZvY3VzZWRPcHRpb24gPyBvbGRGb2N1c0luZGV4ICsgMSA6IDAsIG9wdGlvbnMpXG4gICAgICAgIGlmIChuZXdPcHRpb24gPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgdGhpcy5fZm9jdXNPcHRpb25TdGFydGluZ1dpdGgoa2V5Y29kZSwgMCwgb3B0aW9ucylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfRU5URVIgfHwga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9UQUIpIHtcbiAgICAgIC8vIEhhbmRsZSBlbnRlciBhbmQgdGFiIGtleSBieSBzZWxlY3RpbmcgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgIGxldCBuZXdJdGVtID0gdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQucXVlcnlTZWxlY3RvcihgLiR7Q0xBU1NfSVRFTV9GT0NVU0VEfWApIVxuICAgICAgdGhpcy5fc2VsZWN0ZWRJdGVtQ2hhbmdlZChuZXdJdGVtLCB0cnVlLCB0aGlzLl9tdWx0aXNlbGVjdGlvbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGluIHRoZSBmaWx0ZXIgZmllbGRcbiAgICovXG4gIHByaXZhdGUgX2hhbmRsZUZpbHRlcktleWRvd24oZTogRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBrZXlib2FyZEV2ZW50ID0gZSBhcyBLZXlib2FyZEV2ZW50XG4gICAgY29uc3Qga2V5Y29kZSA9IGtleWJvYXJkRXZlbnQud2hpY2ggfHwga2V5Ym9hcmRFdmVudC5rZXlDb2RlXG5cbiAgICAvLyBJZiB0aGUgdXNlciBoaXRzIHRoZSBlbnRlciBrZXkgd2hpbGUgZmlsdGVyaW5nIGFuZCB0aGVyZSdzIGEgc2luZ2xlIG1hdGNoLCBzZWxlY3QgaXRcbiAgICBpZiAoa2V5Y29kZSA9PT0gSW5wdXRzLktFWV9FTlRFUikge1xuICAgICAgY29uc3QgZHJvcGRvd25FbGVtZW50cyA9IHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NMQVNTX0lURU19YClcblxuICAgICAgaWYgKGRyb3Bkb3duRWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkSXRlbUNoYW5nZWQoZHJvcGRvd25FbGVtZW50c1swXSwgdHJ1ZSwgdGhpcy5fbXVsdGlzZWxlY3Rpb24pXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyBhIGtleSBpbiB0aGUgZmlsdGVyIGZpZWxkXG4gICAqL1xuICBwcml2YXRlIF9oYW5kbGVGaWx0ZXJLZXl1cChlOiBFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnRcblxuICAgIC8vIEZpbHRlciBoYXMgY2hhbmdlZFxuICAgIGlmICh0YXJnZXQudmFsdWUgIT09IHRoaXMuX2FjdGl2ZUZpbHRlciAmJiB0YXJnZXQudmFsdWUgIT09IHRoaXMuX3BsYWNlaG9sZGVyVGV4dCAmJiB0YXJnZXQudmFsdWUgIT09IHRoaXMuX2xhc3RTZWxlY3RlZE9wdGlvbiEuaW5uZXJIVE1MKSB7XG4gICAgICB0aGlzLl9zZXRGaWx0ZXIodGFyZ2V0LnZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGZvY3Vzc2VzIHRoZSBmaWx0ZXIgaW5wdXQgZmllbGRcbiAgICovXG4gIHByaXZhdGUgX2hhbmRsZUZpbHRlckZvY3VzKGU6IEV2ZW50KTogdm9pZCB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudFxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0YXJnZXQuc2VsZWN0KClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIFNlbGVjdCBieSBhIGdpdmVuIGZpbHRlciBrZXl3b3JkXG4gICAqIEBwYXJhbSBmaWx0ZXIgS2V5d29yZCB0byBmaWx0ZXIgYnlcbiAgICovXG4gIHByaXZhdGUgX3NldEZpbHRlcihmaWx0ZXI6IHN0cmluZyA9IFwiXCIpOiB2b2lkIHtcbiAgICB0aGlzLl9hY3RpdmVGaWx0ZXIgPSAoZmlsdGVyLmxlbmd0aCA+PSB0aGlzLl9taW5GaWx0ZXJMZW5ndGgpID8gZmlsdGVyIDogXCJcIlxuICAgIHRoaXMuc2V0T3B0aW9ucyh0aGlzLmdldEluaXRpYWxPcHRpb25zKCkpXG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBmaWx0ZXJcbiAgICovXG4gIHByaXZhdGUgX2NsZWFyRmlsdGVyKCk6IHZvaWQge1xuICAgIGRlbGV0ZSB0aGlzLl9hY3RpdmVGaWx0ZXJcbiAgICB0aGlzLnNldE9wdGlvbnModGhpcy5nZXRJbml0aWFsT3B0aW9ucygpKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBuZXcgY29udGVudCBhbmQgcmVsb2FkIHRoZSBTZWxlY3RcbiAgICogQHBhcmFtIGVsZW1lbnRzIEFycmF5IG9mIG5ldyBvcHRpb24gKG9yIG9wdGdyb3VwKSBlbGVtZW50cyB0byBkaXNwbGF5XG4gICAqL1xuICBwcml2YXRlIHNldE9wdGlvbnMob3B0aW9uczogRWxlbWVudFtdKTogdm9pZCB7XG4gICAgdGhpcy5fZW1wdHlOb2RlKHRoaXMuZWxlbWVudClcblxuICAgIG9wdGlvbnMuZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQob3B0aW9uKVxuICAgIH0pXG5cbiAgICAvLyBQcmVzZXJ2ZSBzZWxlY3RlZCB2YWx1ZSBpZiB0aGUgc2VsZWN0ZWRcbiAgICB0aGlzLmVsZW1lbnQudmFsdWUgPSB0aGlzLl9sYXN0U2VsZWN0ZWRPcHRpb24hLnZhbHVlXG5cbiAgICB0aGlzLnJlbG9hZCgpXG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGNoaWxkcmVuIG9mIGEgZ2l2ZW4gbm9kZVxuICAgKiBAcGFyYW0gbm9kZSBOb2RlXG4gICAqL1xuICBwcml2YXRlIF9lbXB0eU5vZGUobm9kZTogTm9kZSk6IHZvaWQge1xuICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYW4gb3B0aW9uIGlzIGEgcGxhY2Vob2xkZXIgb3B0aW9uXG4gICAqL1xuICBwcml2YXRlIF9pc1BsYWNlaG9sZGVyKG9wdGlvbjogSFRNTE9wdGlvbkVsZW1lbnQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gb3B0aW9uLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpICYmIG9wdGlvbi5oYXNBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBwbGFjZWhvbGRlciB2YWx1ZVxuICAgKiBAcGFyYW0gdGV4dCBDb250ZW50IG9mIHRoZSBwbGFjZWhvbGRlclxuICAgKi9cbiAgcHJvdGVjdGVkIF9zZXRQbGFjZWhvbGRlcih0ZXh0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50ICYmIHRleHQpIHtcbiAgICAgIGlmICh0aGlzLl9pc0ZpbHRlcmFibGUoKSkge1xuICAgICAgICAodGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50IGFzIERvbUVsZW1lbnQ8SFRNTElucHV0RWxlbWVudD4pLmVsZW1lbnQudmFsdWUgPSB0ZXh0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQuc2V0SHRtbCh0ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG9wdGlvbi5cbiAgICogSWYgbXVsdGlwbGUgc2VsZWN0aW9uIGlzIGVuYWJsZWQgdGhpcyBwcm9wZXJ0eSByZXR1cm5zIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAodGhpcy5fbXVsdGlzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZE9wdGlvbnMoKS5tYXAoKHgpID0+IHgudmFsdWUpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWxlbWVudC52YWx1ZSA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnZhbHVlXG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2VsZWN0IGNvbXBvbmVudCBkZXBlbmRpbmcgb24gdGhlXG4gICAqICd2YWx1ZScgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge3ZhbHVlfSBJZiB0cnVlIGRpc2FibGVzIHRoZSBjb250cm9sOyBmYWxzZSBlbmFibGVzIGl0LlxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmRpc2FibGUoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuYWJsZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbG9hZHMgdGhlIGRyb3Bkb3duJ3Mgb3B0aW9uIGRhdGEgZGVmaW5pdGlvbnMgZnJvbSB0aGUgRE9NIGFuZCB1cGRhdGVzXG4gICAqIHRoZSBnZW5lcmF0ZWQgZHJvcGRvd24gZGlzcGxheSBpdGVtcy5cbiAgICovXG4gIHB1YmxpYyByZWxvYWQoKSB7XG4gICAgLy8gUmVtb3ZlIGFsbCBleGlzdGluZyBjaGlsZCBlbGVtZW50c1xuICAgIHRoaXMuX2VtcHR5Tm9kZSh0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudClcblxuICAgIGlmICh0aGlzLl9hY3RpdmVGaWx0ZXIgPT09IHVuZGVmaW5lZCkgeyAvLyBJZiB0aGUgdXNlciBpcyBmaWx0ZXJpbmcsIGxldCB0aGUgcGxhY2Vob2xkZXIgXCJpbnB1dFwiIGFsaXZlXG4gICAgICB0aGlzLl9zZXR1cFBsYWNlaG9sZGVyKClcbiAgICB9XG5cbiAgICB0aGlzLl9jcmVhdGVPcHRpb25zKHRoaXMuZWxlbWVudClcblxuICAgIHRoaXMuX3VwZGF0ZVNpemUoKVxuICAgIHRoaXMuX3VwZGF0ZU1lc3NhZ2UoKVxuXG4gICAgaWYgKCF0aGlzLl9pc0ZpbHRlcmFibGUoKSkge1xuICAgICAgdGhpcy5fdXBkYXRlUGxhY2Vob2xkZXIoISF0aGlzLnZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZWxlY3QgY29udHJvbCB0byB0aGUgZW5hYmxlZCBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBlbmFibGUoKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQucmVtb3ZlQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcblxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzSGFuZGxlcilcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdCBjb250cm9sIHRvIHRoZSBkaXNhYmxlZCBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBkaXNhYmxlKCkge1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFkZENsYXNzKENMQVNTX0RJU0FCTEVEKVxuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG5cbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0hhbmRsZXIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9ibHVySGFuZGxlcilcblxuICAgIHRoaXMuY2xvc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIG9wZW4vY2xvc2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QgZHJvcGRvd24uXG4gICAqL1xuICBwdWJsaWMgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcGVuKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBpZiB0aGUgc2VsZWN0IGRyb3Bkb3duIGlzIG9wZW4gb3IgY2xvc2VkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG9wZW47IG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIHB1YmxpYyBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZXJFbGVtZW50Lmhhc0NsYXNzKENMQVNTX09QRU4pXG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIHNlbGVjdCBkcm9wZG93bi5cbiAgICovXG4gIHB1YmxpYyBvcGVuKCkge1xuICAgIGlmICghdGhpcy5pc09wZW4oKSkge1xuICAgICAgdGhpcy5fb3BlbkJ5Rm9jdXMgPSBmYWxzZVxuXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5yZW1vdmVDbGFzcyhDTEFTU19DTE9TRUQpXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hZGRDbGFzcyhDTEFTU19PUEVOKVxuXG4gICAgICB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5faGFuZGxlRHJvcGRvd25DbGljaylcbiAgICAgIHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0YXBcIiwgdGhpcy5faGFuZGxlRHJvcGRvd25DbGljaylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBzZWxlY3QgZHJvcGRvd24uXG4gICAqL1xuICBwdWJsaWMgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgIHRoaXMuX29wZW5CeUZvY3VzID0gZmFsc2VcblxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQucmVtb3ZlQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFkZENsYXNzKENMQVNTX0NMT1NFRClcblxuICAgICAgLy8gSWYgdGhlIFNlbGVjdCBpcyBmaWx0ZXJhYmxlIGFuZCB0aGVyZWZvcmUgaGFzIGFuIGlucHV0IGZpZWxkLFxuICAgICAgLy8gcmVzZXQgdGhlIHZhbHVlIG9mIGl0IHRvIHRoZSBjaG9zZW4gb3B0aW9uXG4gICAgICBpZiAodGhpcy5faXNGaWx0ZXJhYmxlKCkpIHtcbiAgICAgICAgLy8gVW5mb2N1cyBpbnB1dCBmaWVsZFxuICAgICAgICAodGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50LmVsZW1lbnQgYXMgSFRNTElucHV0RWxlbWVudCkuYmx1cigpXG5cbiAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmVGaWx0ZXIgfHwgdGhpcy5fYWN0aXZlRmlsdGVyID09PSB0aGlzLl9sYXN0U2VsZWN0ZWRPcHRpb24hLmlubmVySFRNTCkge1xuICAgICAgICAgIHRoaXMuX3NldFBsYWNlaG9sZGVyKHRoaXMuX2xhc3RTZWxlY3RlZE9wdGlvbiEuaW5uZXJIVE1MKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9oYW5kbGVEcm9wZG93bkNsaWNrKVxuICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRhcFwiLCB0aGlzLl9oYW5kbGVEcm9wZG93bkNsaWNrKVxuXG4gICAgICBsZXQgZm9jdXNlZEl0ZW0gPSB0aGlzLl93cmFwcGVyRWxlbWVudC5maW5kKGAuJHtDTEFTU19JVEVNX0ZPQ1VTRUR9YClcblxuICAgICAgaWYgKGZvY3VzZWRJdGVtKSB7XG4gICAgICAgIGZvY3VzZWRJdGVtLnJlbW92ZUNsYXNzKENMQVNTX0lURU1fRk9DVVNFRClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIGVsZW1lbnQgaGFzIHRoZSBmaWx0ZXIgbW9kaWZpZXIgY2xhc3NcbiAgICovXG4gIHByaXZhdGUgX2lzRmlsdGVyYWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlckVsZW1lbnQuaGFzQ2xhc3MoQ0xBU1NfRklMVEVSQUJMRSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgY29tcG9uZW50IGFuZCBjbGVhcnMgYWxsIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcblxuICAgIGlmICh0aGlzLl9kcm9wZG93bkVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9oYW5kbGVEcm9wZG93bkNsaWNrKVxuICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRhcFwiLCB0aGlzLl9oYW5kbGVEcm9wZG93bkNsaWNrKVxuXG4gICAgICByZW1vdmUodGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQpO1xuICAgICAgKHRoaXMgYXMgYW55KS5fZHJvcGRvd25FbGVtZW50ID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudCkge1xuICAgICAgdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2ZpbHRlcktleWRvd25IYW5kbGVyKVxuICAgICAgdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLl9maWx0ZXJLZXl1cEhhbmRsZXIpXG4gICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZpbHRlckZvY3VzSGFuZGxlcilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fd3JhcHBlckVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0hhbmRsZXIpXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKTtcblxuICAgICAgKHRoaXMgYXMgYW55KS5fd3JhcHBlckVsZW1lbnQgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc2VsZWN0QnV0dG9uRWxlbWVudCkge1xuICAgICAgcmVtb3ZlKHRoaXMuX3NlbGVjdEJ1dHRvbkVsZW1lbnQuZWxlbWVudCk7XG4gICAgICAodGhpcyBhcyBhbnkpLl9zZWxlY3RCdXR0b25FbGVtZW50ID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVDbGFzcyhDTEFTU19DTE9TRUQpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemU8SFRNTFNlbGVjdEVsZW1lbnQ+KFwic2VsZWN0XCIsIChlKSA9PiB7XG4gICAgbmV3IFNlbGVjdChlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3RcbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0ICogYXMgRG9tIGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBRVUVSWV9URVhUQVJFQSA9IFwidGV4dGFyZWFcIlxuY29uc3QgQ0xBU1NfSEFTX1ZBTFVFID0gXCJpcy1maXhlZFwiXG5cbi8qKlxuICogVGV4dGFyZWEgY29tcG9uZW50XG4gKi9cbmNsYXNzIFRleHRhcmVhIGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgX2FyZWE6IEhUTUxUZXh0QXJlYUVsZW1lbnRcblxuICBwcml2YXRlIF9mb2N1c0NoYW5nZWRIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfdmFsdWVDaGFuZ2VkSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3Jlc2l6ZUhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX21pblJvd3MhOiBudW1iZXJcbiAgcHJpdmF0ZSBfbWF4Um93cyE6IG51bWJlclxuICBwcml2YXRlIF9saW5lSGVpZ2h0ITogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfdXBkYXRlQmFzZUhlaWdodCE6IGJvb2xlYW5cblxuICBwcml2YXRlIF9iYXNlSGVpZ2h0ITogbnVtYmVyXG4gIHByaXZhdGUgX2Jhc2VTY3JvbGxIZWlnaHQhOiBudW1iZXJcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX2FyZWEgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9URVhUQVJFQSkhXG5cbiAgICB0aGlzLl9mb2N1c0NoYW5nZWRIYW5kbGVyID0gdGhpcy5fZm9jdXNDaGFuZ2VkLmJpbmQodGhpcylcbiAgICB0aGlzLl92YWx1ZUNoYW5nZWRIYW5kbGVyID0gdGhpcy5fb25WYWx1ZUNoYW5nZWQuYmluZCh0aGlzKVxuICAgIHRoaXMuX3Jlc2l6ZUhhbmRsZXIgPSB0aGlzLl91cGRhdGVIZWlnaHQuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHRleHRhcmVhIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9taW5Sb3dzID0gcGFyc2VJbnQodGhpcy5fYXJlYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1pbi1yb3dzXCIpIHx8IFwiM1wiLCAxMClcbiAgICB0aGlzLl9tYXhSb3dzID0gcGFyc2VJbnQodGhpcy5fYXJlYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1heC1yb3dzXCIpISwgMTApIHx8IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG5cbiAgICAvLyBNYWtlIHN1cmUgbWluIGFuIG1heCBhcmUgcHJvcGVydHkgc3BlY2lmaWVkXG4gICAgdGhpcy5fbWluUm93cyA9IE1hdGgubWluKHRoaXMuX21pblJvd3MsIHRoaXMuX21heFJvd3MpXG4gICAgdGhpcy5fbWF4Um93cyA9IE1hdGgubWF4KHRoaXMuX21pblJvd3MsIHRoaXMuX21heFJvd3MpXG5cbiAgICB0aGlzLl9saW5lSGVpZ2h0ID0gcGFyc2VJbnQoRG9tLmNzcyh0aGlzLl9hcmVhLCBcImxpbmUtaGVpZ2h0XCIpLCAxMClcblxuICAgIHRoaXMuX3VwZGF0ZUJhc2VIZWlnaHQgPSBEb20uaXNIaWRkZW4odGhpcy5fYXJlYSwgdHJ1ZSlcbiAgICB0aGlzLl9jYWxjdWxhdGVCYXNlSGVpZ2h0KClcblxuICAgIC8vIGFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9hcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0NoYW5nZWRIYW5kbGVyKVxuICAgIHRoaXMuX2FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fZm9jdXNDaGFuZ2VkSGFuZGxlcilcbiAgICB0aGlzLl9hcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLl92YWx1ZUNoYW5nZWRIYW5kbGVyKVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG5cbiAgICB0aGlzLl9vblZhbHVlQ2hhbmdlZCgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2NhbGN1bGF0ZUJhc2VIZWlnaHQoKSB7XG4gICAgLy8gdGVtcG9yYXJ5IGNsZWFyIHRoZSBjb250ZW50IHRvIHRha2UgbWVhc3VyZW1lbnRzXG4gICAgbGV0IHZhbHVlID0gdGhpcy5fYXJlYS52YWx1ZVxuICAgIHRoaXMuX2FyZWEudmFsdWUgPSBcIlwiXG5cbiAgICB0aGlzLl9iYXNlSGVpZ2h0ID0gdGhpcy5fYXJlYS5vZmZzZXRIZWlnaHQgLSB0aGlzLl9saW5lSGVpZ2h0XG4gICAgdGhpcy5fYmFzZVNjcm9sbEhlaWdodCA9IHRoaXMuX2FyZWEuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fbGluZUhlaWdodFxuXG4gICAgLy8gcmVzdG9yZSBpbml0aWFsIGNvbnRlbnRcbiAgICB0aGlzLl9hcmVhLnZhbHVlID0gdmFsdWVcbiAgfVxuXG4gIHByb3RlY3RlZCBfZm9jdXNDaGFuZ2VkKCkge1xuICAgIHRoaXMuX3VwZGF0ZUhlaWdodCgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX3VwZGF0ZUhlaWdodCgpIHtcbiAgICBsZXQgaGFzRm9jdXMgPSB0aGlzLl9hcmVhID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgbGV0IG1heFJvd3MsIHJvd3MgPSAwXG5cbiAgICBpZiAodGhpcy5fdXBkYXRlQmFzZUhlaWdodCA9PT0gdHJ1ZSAmJiBEb20uaXNIaWRkZW4odGhpcy5fYXJlYSwgdHJ1ZSkgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9jYWxjdWxhdGVCYXNlSGVpZ2h0KClcbiAgICAgIHRoaXMuX3VwZGF0ZUJhc2VIZWlnaHQgPSBmYWxzZVxuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYXByb3ByaWF0ZSBzaXplIGZvciB0aGUgY29udHJvbFxuICAgIGlmICghdGhpcy5faGFzVmFsdWUoKSkge1xuICAgICAgLy8gSGFuZGxlIGVtcHR5IHN0YXRlc1xuICAgICAgcm93cyA9IGhhc0ZvY3VzID09PSB0cnVlID8gdGhpcy5fbWluUm93cyA6IDFcbiAgICAgIG1heFJvd3MgPSByb3dzXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBoZWlnaHQgZm9yIGNhbGN1bGF0aW9uIG9mIHRoZSByb3cgY291bnRcbiAgICAgIHRoaXMuX2FyZWEuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCJcblxuICAgICAgLy8gR2V0IHRoZSBuZXcgaGVpZ2h0XG4gICAgICByb3dzID0gTWF0aC5jZWlsKCh0aGlzLl9hcmVhLnNjcm9sbEhlaWdodCAtIHRoaXMuX2Jhc2VTY3JvbGxIZWlnaHQpIC8gdGhpcy5fbGluZUhlaWdodCkgKyAxXG4gICAgICBtYXhSb3dzID0gTWF0aC5tYXgoTWF0aC5taW4odGhpcy5fbWF4Um93cywgcm93cyksIHRoaXMuX21pblJvd3MpXG4gICAgfVxuXG4gICAgaWYgKHJvd3MgPiB0aGlzLl9tYXhSb3dzKSB7XG4gICAgICB0aGlzLl9hcmVhLnN0eWxlLm92ZXJmbG93ID0gXCJhdXRvXCJcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYXJlYS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCJcbiAgICB9XG5cbiAgICBjb25zdCBoZWlnaHQgPSAoKG1heFJvd3MgLSAxKSAqIHRoaXMuX2xpbmVIZWlnaHQpICsgdGhpcy5fYmFzZUhlaWdodFxuICAgIHRoaXMuX2FyZWEuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YFxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYXNWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJlYS52YWx1ZSAmJiB0aGlzLl9hcmVhLnZhbHVlLmxlbmd0aCA+IDBcbiAgfVxuXG4gIHByb3RlY3RlZCBfb25WYWx1ZUNoYW5nZWQoKSB7XG4gICAgaWYgKHRoaXMuX2hhc1ZhbHVlKCkpIHtcbiAgICAgIERvbS5hZGRDbGFzcyh0aGlzLl9hcmVhLCBDTEFTU19IQVNfVkFMVUUpXG4gICAgfSBlbHNlIHtcbiAgICAgIERvbS5yZW1vdmVDbGFzcyh0aGlzLl9hcmVhLCBDTEFTU19IQVNfVkFMVUUpXG4gICAgICB0aGlzLl9hcmVhLnZhbHVlID0gXCJcIlxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUhlaWdodCgpXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudCBhbmQgY2xlYXJzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG5cbiAgICB0aGlzLl9hcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0NoYW5nZWRIYW5kbGVyKVxuICAgIHRoaXMuX2FyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fZm9jdXNDaGFuZ2VkSGFuZGxlcilcbiAgICB0aGlzLl9hcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLl92YWx1ZUNoYW5nZWRIYW5kbGVyKTtcblxuICAgICh0aGlzIGFzIGFueSkuX2ZvY3VzQ2hhbmdlZEhhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX3ZhbHVlQ2hhbmdlZEhhbmRlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fYXJlYSA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fbWluUm93cyA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fbWF4Um93cyA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fbGluZUhlaWdodCA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fYmFzZUhlaWdodCA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fYmFzZVNjcm9sbEhlaWdodCA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5lbGVtZW50ID0gbnVsbFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLmlucHV0LW11bHRpbGluZSwgLmlucHV0LWZpZWxkLS1tdWx0aWxpbmVcIiwgKGUpID0+IHtcbiAgICBuZXcgVGV4dGFyZWEoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dGFyZWFcbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuXG4vKipcbiAqIExvYWRlciBiYXIgY29tcG9uZW50XG4gKi9cbmNsYXNzIExvYWRlckJhciBleHRlbmRzIERvbUVsZW1lbnQge1xuICBwcml2YXRlIHByb2dyZXNzRWxlbWVudCE6IERvbUVsZW1lbnRcbiAgcHJpdmF0ZSBmaWxlTmFtZUVsZW1lbnQhOiBEb21FbGVtZW50XG4gIHByaXZhdGUgcHJvZ3Jlc3NMYWJlbEVsZW1lbnQhOiBEb21FbGVtZW50XG4gIHByaXZhdGUgdG90YWxQcm9ncmVzc0VsZW1lbnQhOiBEb21FbGVtZW50XG5cbiAgcHJpdmF0ZSB2YWx1ZSE6IG51bWJlclxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyB0aGUgTG9hZGVyQmFyIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSAtIFRoZSByb290IGVsZW1lbnQgb2YgdGhlIExvYWRlckJhciBjb21wb25lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbG9hZGVyIGJhciBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5wcm9ncmVzc0VsZW1lbnQgPSB0aGlzLmZpbmQoXCIuaW5kaWNhdG9yXCIpIHx8IHRoaXNcbiAgICB0aGlzLmZpbGVOYW1lRWxlbWVudCA9IHRoaXMuZmluZChcIi5kZXRhaWwgPiAubmFtZVwiKSFcbiAgICB0aGlzLnByb2dyZXNzTGFiZWxFbGVtZW50ID0gdGhpcy5maW5kKFwiLnByb2dyZXNzXCIpIVxuICAgIHRoaXMudG90YWxQcm9ncmVzc0VsZW1lbnQgPSB0aGlzLmZpbmQoXCIucHJvZ3Jlc3MgPiAuZmlsZS1zaXplXCIpIVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MgdmFsdWUgaW4gdGhlIHJhbmdlIG9mIDAuLjEuXG4gICAqL1xuICBnZXQgcHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHByb2dyZXNzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gLSBUaGUgcHJvZ3Jlc3MgaW4gdGhlIHJhbmdlIG9mIDAuLjEuXG4gICAqL1xuICBzZXQgcHJvZ3Jlc3ModmFsKSB7XG4gICAgLy8gdmFsID0gY2xhbXAodmFsLCAwLCAxKVxuXG4gICAgbGV0IHBlcmNlbnRhZ2UgPSAodmFsICogMTAwKS50b0ZpeGVkKDApXG5cbiAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgICh0aGlzLmVsZW1lbnQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPSBTdHJpbmcodmFsKVxuXG4gICAgdGhpcy5wcm9ncmVzc0VsZW1lbnQuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYHdpZHRoOiAke3ZhbCAqIDEwMH0lYClcblxuICAgIGlmICh0aGlzLnByb2dyZXNzTGFiZWxFbGVtZW50KSB7XG4gICAgICB0aGlzLnByb2dyZXNzTGFiZWxFbGVtZW50LmVsZW1lbnQudGV4dENvbnRlbnQgPSBgJHtwZXJjZW50YWdlfSVgXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGZpbGVuYW1lLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBmaWxlbmFtZS5cbiAgICovXG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICBpZiAoIXRoaXMuZmlsZU5hbWVFbGVtZW50KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmlsZU5hbWVFbGVtZW50LmVsZW1lbnQuaW5uZXJIVE1MXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZmlsZW5hbWUuXG4gICAqL1xuICBzZXQgZmlsZW5hbWUodmFsOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAoIXRoaXMuZmlsZU5hbWVFbGVtZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHRoZSBmaWxlbmFtZSwgbWlzc2luZyBkZXRhaWwgZWxlbWVudFwiKVxuICAgIH1cblxuICAgIHRoaXMuZmlsZU5hbWVFbGVtZW50LnNldEh0bWwodmFsIHx8IFwiXCIpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZmlsZSBzaXplIGxhYmVsLlxuICAgKi9cbiAgc2V0IGZpbGVTaXplKHZhbDogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLnRvdGFsUHJvZ3Jlc3NFbGVtZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHRoZSBmaWxlU2l6ZSwgbWlzc2luZyBkZXRhaWwgZWxlbWVudFwiKVxuICAgIH1cblxuICAgIHRoaXMudG90YWxQcm9ncmVzc0VsZW1lbnQuc2V0SHRtbCh2YWwpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIubG9hZGVyLWJhclwiLCAoZSkgPT4ge1xuICAgIG5ldyBMb2FkZXJCYXIoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgTG9hZGVyQmFyXG4iLCJpbXBvcnQgYW5pbWUgZnJvbSBcImFuaW1lanNcIlxuaW1wb3J0IFBvcHBlciBmcm9tIFwicG9wcGVyLmpzXCJcblxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0IHsgYWRkQ2xhc3MsIGhhc0NsYXNzLCByZW1vdmVDbGFzcywgaXNIaWRkZW4sIHBhcmVudFdpdGhDbGFzcyB9IGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBDTEFTU19PUEVOID0gXCJpcy1vcGVuXCJcbmNvbnN0IENMQVNTX01FTlUgPSBcImpzLWZseW91dFwiXG5jb25zdCBDTEFTU19UQUJTID0gXCJ0YWJzXCJcblxuY29uc3QgQU5JTUFUSU9OX09QRU4gPSAzMDBcblxuLyoqXG4gKiBBIGNvbXBvbmVudCBmb3IgdGhlIGZseW91dCBtZW51LlxuICovXG5jbGFzcyBNZW51Rmx5b3V0IGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgX2NsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3dpbmRvd0NsaWNrSGFuZGxlcjogKGU6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfYW5pbWF0aW9uRHVyYXRpb24gPSBBTklNQVRJT05fT1BFTlxuXG4gIHByaXZhdGUgX2R5bmFtaWNQbGFjZW1lbnQgPSBmYWxzZVxuXG4gIHByaXZhdGUgX2hpZGRlbkluZGljYXRvcj86IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX2ZseW91dEVsZW1lbnQhOiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX3BvcHBlckluc3RhbmNlPzogUG9wcGVyXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBmbHlvdXQgY29tcG9uZW50LlxuICAgKiBAcGFyYW0gZWxlbWVudCAtIFRoZSByb290IGVsZW1lbnQgb2YgdGhlIGZseW91dCBtZW51IGNvbXBvbmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZVdpbmRvd0NsaWNrLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBmbHlvdXQgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIGxldCBkYXRhVGFyZ2V0ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdGFyZ2V0XCIpXG4gICAgaWYgKGRhdGFUYXJnZXQgPT09IG51bGwgfHwgZGF0YVRhcmdldCA9PT0gXCJcIikge1xuXG4gICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICBjb25zb2xlLmVycm9yKFwiQSBmbHlvdXQgbWVudSBlbGVtZW50IHJlcXVpcmVzIGEgJ2RhdGEtdGFyZ2V0JyB0aGF0IHNwZWNpZmllcyB0aGUgZWxlbWVudCB0byBjb2xsYXBzZVwiKVxuICAgICAgY29uc29sZS5pbmZvKHRoaXMuZWxlbWVudClcbiAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdXNlRHluYW1pY1BsYWNlbWVudCgpKSB7XG4gICAgICB0aGlzLl9keW5hbWljUGxhY2VtZW50ID0gdHJ1ZVxuICAgIH1cblxuICAgIGxldCBoaWRkZW5UYXJnZXQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1oaWRkZW5cIilcbiAgICBpZiAoaGlkZGVuVGFyZ2V0ICE9PSBudWxsICYmIGhpZGRlblRhcmdldCAhPT0gXCJcIikge1xuICAgICAgdGhpcy5faGlkZGVuSW5kaWNhdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihoaWRkZW5UYXJnZXQpIGFzIEhUTUxFbGVtZW50IHx8IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHRoaXMuX2luaXRGbHlvdXRFbGVtZW50KGRhdGFUYXJnZXQpXG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gIH1cblxuICBwcml2YXRlIF9pbml0Rmx5b3V0RWxlbWVudChkYXRhVGFyZ2V0OiBzdHJpbmcpIHtcbiAgICB0aGlzLl9mbHlvdXRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihkYXRhVGFyZ2V0KSEgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl9mbHlvdXRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBcIjBcIlxuICAgIHRoaXMuX2ZseW91dEVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVZKC0yMHB4KVwiXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUNsaWNrKCkge1xuICAgIHRoaXMudG9nZ2xlKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlV2luZG93Q2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSB7XG4gICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudFxuXG4gICAgaWYgKHBhcmVudFdpdGhDbGFzcyh0YXJnZXQsIENMQVNTX01FTlUpID09PSB0aGlzLl9mbHlvdXRFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB3aGlsZSAodGFyZ2V0ICE9PSB0aGlzLmVsZW1lbnQgJiYgdGFyZ2V0LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldCAhPT0gdGhpcy5lbGVtZW50KSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBwcm90ZWN0ZWQgX3VzZUR5bmFtaWNQbGFjZW1lbnQoKSB7XG4gICAgcmV0dXJuIHBhcmVudFdpdGhDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX1RBQlMpXG4gIH1cblxuICBwcm90ZWN0ZWQgX29wZW5NZW51KGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGFuaW1lLnJlbW92ZShlbClcblxuICAgIGlmICh0aGlzLl9keW5hbWljUGxhY2VtZW50ID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBwb3BwZXJPcHRpb25zOiBQb3BwZXIuUG9wcGVyT3B0aW9ucyA9IHtcbiAgICAgICAgcGxhY2VtZW50OiBcImJvdHRvbVwiLFxuICAgICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgICBmbGlwOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnRzRW5hYmxlZDogZmFsc2VcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2UgPSBuZXcgUG9wcGVyKHRoaXMuZWxlbWVudCwgdGhpcy5fZmx5b3V0RWxlbWVudCwgcG9wcGVyT3B0aW9ucylcbiAgICB9XG5cbiAgICBhbmltZSh7XG4gICAgICB0YXJnZXRzOiBlbCxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLl9hbmltYXRpb25EdXJhdGlvbixcbiAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHRyYW5zbGF0ZVk6IFwiMHB4XCIsXG4gICAgICBiZWdpbjogKCkgPT4ge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiXG4gICAgICB9LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgYWRkQ2xhc3MoZWwsIENMQVNTX09QRU4pXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIHNldCBhcmlhIGV4cGFuZGVkXG4gICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIilcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcIm9wZW5lZFwiKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jbG9zZU1lbnUoZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgYW5pbWUucmVtb3ZlKGVsKVxuXG4gICAgaWYgKHRoaXMuX3BvcHBlckluc3RhbmNlKSB7XG4gICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZS5kZXN0cm95KClcbiAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgYW5pbWUoe1xuICAgICAgdGFyZ2V0czogZWwsXG4gICAgICBkdXJhdGlvbjogdGhpcy5fYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICBlYXNpbmc6IFwiY3ViaWNCZXppZXIoMC41NTAsIDAuMDg1LCAwLjMyMCwgMSlcIixcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICB0cmFuc2xhdGVZOiBcIi0yMHB4XCIsXG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCJcbiAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsIENMQVNTX09QRU4pXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIHNldCBhcmlhIGV4cGFuZGVkXG4gICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpXG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjbG9zZWRcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvcGVuaW5nIGFuaW1hdGlvbiBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtkdXJhdGlvbkluU2Vjb25kc30gLSBUaGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIHNlY29uZHMuXG4gICAqL1xuICBzZXQgYW5pbWF0aW9uRHVyYXRpb24oZHVyYXRpb25JblNlY29uZHM6IG51bWJlcikge1xuICAgIHRoaXMuX2FuaW1hdGlvbkR1cmF0aW9uID0gZHVyYXRpb25JblNlY29uZHNcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgZmx5b3V0IG1lbnUuXG4gICAqIEBmaXJlcyBNb2RhbCNvcGVuZWRcbiAgICovXG4gIHB1YmxpYyBvcGVuKCkge1xuICAgIGlmICh0aGlzLl9oaWRkZW5JbmRpY2F0b3IgJiYgaXNIaWRkZW4odGhpcy5faGlkZGVuSW5kaWNhdG9yLCBmYWxzZSkgPT09IHRydWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChoYXNDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX09QRU4pID09PSB0cnVlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX09QRU4pXG4gICAgdGhpcy5fb3Blbk1lbnUodGhpcy5fZmx5b3V0RWxlbWVudClcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICB9LCA1MClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGZseW91dCBtZW51LlxuICAgKiBAZmlyZXMgTW9kYWwjY2xvc2VkXG4gICAqL1xuICBwdWJsaWMgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2hpZGRlbkluZGljYXRvciAmJiBpc0hpZGRlbih0aGlzLl9oaWRkZW5JbmRpY2F0b3IsIGZhbHNlKSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX09QRU4pXG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcblxuICAgIHRoaXMuX2Nsb3NlTWVudSh0aGlzLl9mbHlvdXRFbGVtZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGZseW91dCBtZW51LlxuICAgKiBAZmlyZXMgTW9kYWwjb3BlbmVkXG4gICAqIEBmaXJlcyBNb2RhbCNjbG9zZWRcbiAgICovXG4gIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgaWYgKGhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTikgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLm9wZW4oKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZXZlbnQgaGFuZGxlcnMgYW5kIGNsZWFycyByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgKHRoaXMgYXMgYW55KS5fZmx5b3V0RWxlbWVudCA9IG51bGxcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuXG4gICAgaWYgKHRoaXMuX2NsaWNrSGFuZGxlcikge1xuICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BvcHBlckluc3RhbmNlKSB7XG4gICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZS5kZXN0cm95KClcbiAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgKHRoaXMgYXMgYW55KS5fY2xpY2tIYW5kbGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl93aW5kb3dDbGlja0hhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuZWxlbWVudCA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBmbHlvdXQgbWVudSBpcyBvcGVuZWQgYnkgdGhlIGFuY2hvciBsaW5rIG9yIHVzaW5nIHRoZVxuICAgKiB7QGxpbmsgTWVudUZseW91dCNvcGVufSBtZXRob2QuXG4gICAqIEBldmVudCBNZW51Rmx5b3V0I29wZW5lZFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKi9cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgZmx5b3V0IG1lbnUgaXMgY2xvc2VkIGJ5IHRoZSB1c2VyIG9yIHVzaW5nIHRoZVxuICAgKiB7QGxpbmsgTWVudUZseW91dCNjbG9zZX0gbWV0aG9kLlxuICAgKiBAZXZlbnQgTWVudUZseW91dCNjbG9zZWRcbiAgICogQHR5cGUge29iamVjdH1cbiAgICovXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBsZXQgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtdG9nZ2xlPSdmbHlvdXQnXVwiKVxuICBmb3IgKGxldCBlIG9mIGVsZW1lbnRzKSB7XG4gICAgaWYgKGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1pbml0XCIpID09PSBcImF1dG9cIikge1xuICAgICAgbmV3IE1lbnVGbHlvdXQoZSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWVudUZseW91dFxuIiwiaW1wb3J0IHsgZGlzYWJsZUJvZHlTY3JvbGwsIGVuYWJsZUJvZHlTY3JvbGwgfSBmcm9tIFwiYm9keS1zY3JvbGwtbG9ja1wiXG5pbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCBwcmV2ZW50RGVmYXVsdCB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgKiBhcyBJbnB1dHMgZnJvbSBcIi4uL0lucHV0c1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgeyBnZXRSb290RWxlbWVudCB9IGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBDTEFTU19CQUNLRFJPUCA9IFwiYmFja2Ryb3BcIlxuY29uc3QgQ0xBU1NfQkFDS0RST1BfT1BFTiA9IFwiYmFja2Ryb3AtLW9wZW5cIlxuXG5jb25zdCBDTEFTU19PUEVOID0gXCJtb2RhbC0tb3BlblwiXG5jb25zdCBDTEFTU19UUklHR0VSID0gXCJtb2RhbC10cmlnZ2VyXCJcblxuY29uc3QgQ0xBU1NfQk9EWSA9IFwibW9kYWxfX2JvZHlcIlxuXG5jb25zdCBDTEFTU19CVVRUT05TX09LQVkgPSBcIi5tb2RhbC1jbG9zZVwiXG5jb25zdCBDTEFTU19CVVRUT05TX0NMT1NFID0gXCIubW9kYWwtY2FuY2VsXCJcblxuLyoqXG4gKiBBIGNvbXBvbmVudCB0byBvcGVuIGFuZCBjbG9zZSBtb2RhbCBkaWFsb2dzLiBJdCBhbHNvIGhhbmRsZXMgY2FuY2VsbGF0aW9uIGFuZCBtYWtlc1xuICogc3VyZSB0aGF0IHRoZSBtb2RhbCBiYWNrZ3JvdW5kIGlzIHByZXNlbnQgaW4gdGhlIERPTS5cbiAqL1xuY2xhc3MgTW9kYWwgZXh0ZW5kcyBEb21FbGVtZW50PEhUTUxFbGVtZW50PiB7XG4gIHByaXZhdGUgX29rYXlIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfY2FuY2VsSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2tleWRvd25IYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfd2luZG93Q2xpY2tIYW5kbGVyPzogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3RyaWdnZXJDbGlja0hhbmRsZXI/OiAoZTogRXZlbnQpID0+IHZvaWRcblxuICBwcml2YXRlIF9iYWNrZHJvcCE6IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+XG4gIHByaXZhdGUgX2JhY2tkcm9wUGFyZW50ITogRWxlbWVudFxuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX29rYXlIYW5kbGVyID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fY2FuY2VsSGFuZGxlciA9IHRoaXMuX2hhbmRsZUNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9rZXlkb3duSGFuZGxlciA9IHRoaXMuX2hhbmRsZUtleWRvd24uYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHJhbmdlIG1vZGFsIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcblxuICAgIC8vIENyZWF0ZSB0aGUgYmFja2Ryb3BcbiAgICB0aGlzLl9iYWNrZHJvcCA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0JBQ0tEUk9QKVxuXG4gICAgdGhpcy5fYmFja2Ryb3BQYXJlbnQgPSBnZXRSb290RWxlbWVudCgpXG4gICAgdGhpcy5fc3Vic2NyaWJlVG9UcmlnZ2VyKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlVG9UcmlnZ2VyKCkge1xuICAgIGNvbnN0IHRyaWdnZXJJZCA9IHRoaXMuZWxlbWVudC5pZFxuICAgIGlmICghdHJpZ2dlcklkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl90cmlnZ2VyQ2xpY2tIYW5kbGVyID0gdGhpcy5vcGVuLmJpbmQodGhpcylcblxuICAgIGxldCB0cmlnZ2VyRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19UUklHR0VSfVtocmVmPSR7dHJpZ2dlcklkfV1gKVxuICAgIGZvciAobGV0IHRyaWdnZXJFbGVtZW50IG9mIHRyaWdnZXJFbGVtZW50cykge1xuICAgICAgdHJpZ2dlckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3RyaWdnZXJDbGlja0hhbmRsZXIhKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfdW5zdWJzY3JpYmVGcm9tVHJpZ2dlcigpIHtcbiAgICBjb25zdCB0cmlnZ2VySWQgPSB0aGlzLmVsZW1lbnQuaWRcbiAgICBpZiAoIXRyaWdnZXJJZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHRyaWdnZXJFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NMQVNTX1RSSUdHRVJ9W2hyZWY9JHt0cmlnZ2VySWR9XWApXG4gICAgZm9yIChsZXQgdHJpZ2dlckVsZW1lbnQgb2YgdHJpZ2dlckVsZW1lbnRzKSB7XG4gICAgICB0cmlnZ2VyRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyISlcbiAgICB9XG5cbiAgICB0aGlzLl90cmlnZ2VyQ2xpY2tIYW5kbGVyID0gdW5kZWZpbmVkXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUtleWRvd24oZXZlbnQ6IEV2ZW50KSB7XG4gICAgY29uc3Qga2V5Ym9hcmRFdmVudCA9IGV2ZW50IGFzIEtleWJvYXJkRXZlbnRcbiAgICBsZXQga2V5Y29kZSA9IGtleWJvYXJkRXZlbnQud2hpY2ggfHwga2V5Ym9hcmRFdmVudC5rZXlDb2RlXG5cbiAgICBpZiAoa2V5Y29kZSA9PT0gSW5wdXRzLktFWV9FU0NBUEUpIHtcbiAgICAgIC8vIGhhbmRsZSBFc2NhcGUga2V5IChFU0MpXG4gICAgICB0aGlzLmNhbmNlbCgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUNsaWNrKGV2ZW50OiBFdmVudCkge1xuICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgIHRoaXMuY2FuY2VsKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xvc2UoKSB7XG4gICAgZW5hYmxlQm9keVNjcm9sbCh0aGlzLmVsZW1lbnQpXG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgICB0aGlzLl9iYWNrZHJvcC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jYW5jZWxIYW5kbGVyKVxuXG4gICAgdGhpcy5fYmFja2Ryb3AucmVtb3ZlQ2xhc3MoQ0xBU1NfQkFDS0RST1BfT1BFTilcbiAgICB0aGlzLnJlbW92ZUNsYXNzKENMQVNTX09QRU4pXG5cbiAgICBmb3IgKGxldCBjbG9zZUJ1dHRvbiBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19CVVRUT05TX0NMT1NFKSkge1xuICAgICAgY2xvc2VCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NhbmNlbEhhbmRsZXIpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgb2theUJ1dHRvbiBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19CVVRUT05TX09LQVkpKSB7XG4gICAgICBva2F5QnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9va2F5SGFuZGxlcilcbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIHJlbW92ZSB0aGUgYmFja2Ryb3AgZnJvbSB0aGUgYm9keVxuICAgICAgdGhpcy5fYmFja2Ryb3BQYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5fYmFja2Ryb3AuZWxlbWVudClcbiAgICB9LCAzMDApXG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIG1vZGFsIGRpYWxvZy5cbiAgICogQGZpcmVzIE1vZGFsI29wZW5lZFxuICAgKi9cbiAgcHVibGljIG9wZW4oKSB7XG4gICAgZGlzYWJsZUJvZHlTY3JvbGwodGhpcy5lbGVtZW50LCB7XG4gICAgICBhbGxvd1RvdWNoTW92ZTogKGVsKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50RWwgPSBlbFxuXG4gICAgICAgIHdoaWxlIChjdXJyZW50RWwgJiYgY3VycmVudEVsICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHVzZXIgaXMgc2Nyb2xsaW5nIHRoZSBtb2RhbCBib2R5XG4gICAgICAgICAgaWYgKGN1cnJlbnRFbC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfQk9EWSkpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IG92ZXJmbG93c1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRFbC5zY3JvbGxIZWlnaHQgPiBjdXJyZW50RWwuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudEVsID0gY3VycmVudEVsLnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBhZGQgdGhlIGJhY2tkcm9wIHRvIHRoZSBib2R5XG4gICAgdGhpcy5fYmFja2Ryb3BQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5fYmFja2Ryb3AuZWxlbWVudClcblxuICAgIC8vIHNldCB0aGUgZWxlbWVudCB0byBmbGV4IGFzIGl0IGlzIGluaXRpYWxseSBoaWRkZW5cbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiXG5cbiAgICAvLyByZW1vdmUgdGhlIHN0eWxlIGFmdGVyIHRoZSBhbmltYXRpb24gY29tcGxldGVzXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiXCJcbiAgICB9LCA4MDApXG5cbiAgICAvLyB3YWl0IGEgYml0IHRvIGFsbG93IHRoZSBicm93c2VyIHRvIGNhdGNoIHVwIGFuZCBzaG93IHRoZSBhbmltYXRpb25cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmFkZENsYXNzKENMQVNTX0JBQ0tEUk9QX09QRU4pXG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuXG4gICAgICB0aGlzLl9iYWNrZHJvcC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jYW5jZWxIYW5kbGVyKVxuXG4gICAgICBmb3IgKGxldCBjbG9zZUJ1dHRvbiBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19CVVRUT05TX0NMT1NFKSkge1xuICAgICAgICBjbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2FuY2VsSGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgb2theUJ1dHRvbiBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19CVVRUT05TX09LQVkpKSB7XG4gICAgICAgIG9rYXlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29rYXlIYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlOiBFdmVudCkgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSlcblxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwib3BlbmVkXCIpXG4gICAgfSwgNTApXG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyAoYW5kIGNsb3NlcykgdGhlIG1vZGFsIGRpYWxvZy5cbiAgICogQGZpcmVzIE1vZGFsI2NhbmNlbGxlZFxuICAgKiBAZmlyZXMgTW9kYWwjY2xvc2VkXG4gICAqL1xuICBwdWJsaWMgY2FuY2VsKCkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNhbmNlbGxlZFwiKVxuICAgIHRoaXMuX2Nsb3NlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG1vZGFsIGRpYWxvZy5cbiAgICogQGZpcmVzIE1vZGFsI2Nsb3NlZFxuICAgKi9cbiAgcHVibGljIGNsb3NlKCkge1xuICAgIHRoaXMuX2Nsb3NlKClcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjbG9zZWRcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgY29tcG9uZW50IGFuZCBmcmVlcyBhbGwgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMuY2FuY2VsKClcbiAgICB0aGlzLl91bnN1YnNjcmliZUZyb21UcmlnZ2VyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBtb2RhbCBkaWFsb2cgaXMgb3BlbmVkIGJ5IHRoZSBhbmNob3IgbGluayBvciB1c2luZyB0aGVcbiAgICoge0BsaW5rIE1vZGFsI29wZW59IG1ldGhvZC5cbiAgICogQGV2ZW50IE1vZGFsI29wZW5lZFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKi9cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgbW9kYWwgZGlhbG9nIGlzIGNsb3NlZCBieSB0aGUgdXNlciBvciB1c2luZyB0aGVcbiAgICoge0BsaW5rIE1vZGFsI2Nsb3NlfSBtZXRob2QuXG4gICAqIEBldmVudCBNb2RhbCNjbG9zZWRcbiAgICogQHR5cGUge29iamVjdH1cbiAgICovXG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIG1vZGFsIGRpYWxvZyBpcyBjYW5jZWxsZWQgYnkgdGhlIHVzZXIgb3IgdXNpbmcgdGhlXG4gICAqIHtAbGluayBNb2RhbCNjYW5jZWx9IG1ldGhvZC5cbiAgICogQGV2ZW50IE1vZGFsI2NhbmNlbGxlZFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKi9cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemU8SFRNTEVsZW1lbnQ+KFwiLm1vZGFsXCIsIChlKSA9PiB7XG4gICAgbmV3IE1vZGFsKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1vZGFsXG4iLCJpbXBvcnQgYW5pbWUsIHsgQW5pbWVUaW1lbGluZUluc3RhbmNlIH0gZnJvbSBcImFuaW1lanNcIlxuaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5pbXBvcnQgU2VhcmNoSW5wdXQgZnJvbSBcIi4uL3NlYXJjaC9TZWFyY2hJbnB1dFwiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcImlzLW9wZW5cIlxuY29uc3QgQ0xBU1NfQUNUSVZFID0gXCJpcy1hY3RpdmVcIlxuXG5jb25zdCBRVUVSWV9OQVZfSEFNQlVSR0VSID0gXCIubmF2LWhhbWJ1cmdlclwiXG5jb25zdCBRVUVSWV9OQVZfSEJfQk9EWSA9IFwiLm5hdl9fcHJpbWFyeVwiXG5cbmNvbnN0IENMQVNTX05BVl9MSU5LID0gXCJuYXYtbGluay0taGVhZGVyXCJcbmNvbnN0IFFVRVJZX05BVl9MSU5LX0FDVElWRSA9IFwiLm5hdi1saW5rLS1oZWFkZXIuaXMtYWN0aXZlXCJcblxuY29uc3QgUVVFUllfTkFWX01PQklMRSA9IFwiLm5hdl9fbGV2ZWwxIC5uYXZfX21haW5uYXYgLm5hdl9fcHJpbWFyeVwiXG5jb25zdCBRVUVSWV9OQVZfTEVWRUwwID0gXCIubmF2X19sZXZlbDBcIlxuY29uc3QgUVVFUllfTkFWX0xFVkVMMF9DT05UQUlORVIgPSBcIi5uYXZfX2xldmVsMCAubmF2X19zdWJuYXZcIlxuY29uc3QgUVVFUllfU0VDVElPTl9PUEVOID0gXCIubmF2LXNlY3Rpb24uaXMtb3BlblwiXG5cbmNvbnN0IFFVRVJZX05BVl9MRVZFTDEgPSBcIi5uYXZfX2xldmVsMSAubmF2X19tYWlubmF2XCJcblxuY29uc3QgUVVFUllfTkFWX0xFVkVMMF9MSU5LID0gXCIubmF2LWxpbmsubmF2LWxpbmstLWhlYWRlclwiXG5jb25zdCBRVUVSWV9OQVZfTEVWRUwxX0xJTksgPSBcIi5uYXYtbGluay0taGVhZGVyXCJcblxuY29uc3QgUVVFUllfTkFWX0NPTFVNTiA9IFwiLm5hdi1jb2xcIlxuY29uc3QgUVVFUllfTkFWX0NPTFVNTl9BQ1RJVkUgPSBcIi5uYXYtY29sLmlzLWFjdGl2ZVwiXG5cbmNvbnN0IFFVRVJZX05BVl9CT0RZID0gXCIubmF2LWJvZHlcIlxuY29uc3QgUVVFUllfTkFWX0ZPT1RFUiA9IFwiLm5hdi1mb290ZXJcIlxuXG5jb25zdCBRVUVSWV9TRUFSQ0hfSUNPTiA9IFwiLm5hdi1zZWFyY2hcIlxuY29uc3QgUVVFUllfU0VBUkNIX0ZJRUxEID0gXCIuc2VhcmNoX19pbnB1dFwiXG5jb25zdCBDTEFTU19TRUFSQ0hfREVTS1RPUCA9IFwic2VhcmNoLS1kZXNrdG9wXCJcblxuY29uc3QgQU5JTUFUSU9OX1NUQVJUX0RFTEFZID0gMjAwXG5jb25zdCBBTklNQVRJT05fT0ZGU0VUID0gNTBcblxuY29uc3QgQU5JTUFUSU9OX0JPRFlfRFVSQVRJT04gPSAzMDBcbmNvbnN0IEFOSU1BVElPTl9GT09URVJfRFVSQVRJT04gPSAxMDBcblxuLyoqXG4gKiBUaGUgbmF2aWdhdGlvbiBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xuY2xhc3MgTmF2aWdhdGlvbiBleHRlbmRzIERvbUVsZW1lbnQge1xuICBwdWJsaWMgX25hdkxldmVsMDogSFRNTEVsZW1lbnRcbiAgcHVibGljIF9uYXZMZXZlbDBCb2R5OiBIVE1MRWxlbWVudFxuICBwdWJsaWMgX25hdkxldmVsMTogSFRNTEVsZW1lbnRcblxuICBwdWJsaWMgX2hhbWJ1cmdlckVsZW1lbnQ6IEhUTUxFbGVtZW50XG5cbiAgcHJpdmF0ZSBfbmF2TW9iaWxlOiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX3NlYXJjaENvbXBvbmVudHM6IFNlYXJjaElucHV0W11cblxuICBwcml2YXRlIF9sZXZlbDBDbGlja0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9sZXZlbDFDbGlja0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF93aW5kb3dDbGlja0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9zZWFyY2hDbGlja0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgYW5pbWF0aW9uOiBBbmltZVRpbWVsaW5lSW5zdGFuY2UgPSBhbmltZS50aW1lbGluZSgpXG4gIHByaXZhdGUgX3NlYXJjaERlc2t0b3A/OiBTZWFyY2hJbnB1dFxuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fbmF2TGV2ZWwwID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0xFVkVMMCkgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgIHRoaXMuX25hdkxldmVsMEJvZHkgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfTEVWRUwwX0NPTlRBSU5FUikgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgIHRoaXMuX25hdkxldmVsMSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9MRVZFTDEpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcblxuICAgIHRoaXMuX25hdk1vYmlsZSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9NT0JJTEUpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICBpZiAoIXRoaXMuX25hdk1vYmlsZS5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBsZXQgZHVtbXlQYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgICBkdW1teVBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLl9uYXZNb2JpbGUpXG4gICAgfVxuXG4gICAgdGhpcy5faGFtYnVyZ2VyRWxlbWVudCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9IQU1CVVJHRVIpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICB0aGlzLl9zZWFyY2hDb21wb25lbnRzID0gW11cblxuICAgIHRoaXMuX2xldmVsMENsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUxldmVsMENsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9sZXZlbDFDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVMZXZlbDFDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlV2luZG93Q2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX3NlYXJjaENsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZVNlYXJjaENsaWNrLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9yZXNldE1haW5UaW1lbGluZSguLi5lbGVtZW50czogSFRNTEVsZW1lbnRbXSkge1xuICAgIHRoaXMuYW5pbWF0aW9uLnBhdXNlKClcbiAgICBmb3IgKGxldCBlbCBvZiBlbGVtZW50cykge1xuICAgICAgYW5pbWUucmVtb3ZlKGVsISlcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb24gPSBhbmltZS50aW1lbGluZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2lzTW9iaWxlKCkge1xuICAgIHJldHVybiBEb20uaXNIaWRkZW4odGhpcy5faGFtYnVyZ2VyRWxlbWVudCwgdHJ1ZSkgPT09IGZhbHNlXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUxldmVsMENsaWNrKGV2ZW50OiBFdmVudCkge1xuICAgIGNvbnN0IGlzRGVza3RvcCA9ICF0aGlzLl9pc01vYmlsZSgpXG5cbiAgICBpZiAoaXNEZXNrdG9wKSB7XG4gICAgICBsZXQgbmF2SXRlbXMgPSBuZXcgTmF2aWdhdGlvbkl0ZW1zKHRoaXMpXG4gICAgICAgIC5mcm9tTGV2ZWwwKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudClcblxuICAgICAgaWYgKCFuYXZJdGVtcy5zZWN0aW9uKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsZXQgcHJldmlvdXNOYXZMaW5rID0gdGhpcy5fbmF2TGV2ZWwwLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0xJTktfQUNUSVZFKSEgYXMgSFRNTEVsZW1lbnRcbiAgICAgIGxldCBwcmV2aW91c05hdlNlY3Rpb24gPSB0aGlzLl9uYXZMZXZlbDAucXVlcnlTZWxlY3RvcihRVUVSWV9TRUNUSU9OX09QRU4pISBhcyBIVE1MRWxlbWVudFxuXG4gICAgICB0aGlzLl90b2dnbGVDb250YWluZXIoXG4gICAgICAgIG5hdkl0ZW1zLmxpbmssXG4gICAgICAgIHRoaXMuX25hdkxldmVsMEJvZHksXG4gICAgICAgIG5hdkl0ZW1zLnNlY3Rpb24sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgcHJldmlvdXNOYXZMaW5rLFxuICAgICAgICB0aGlzLl9uYXZMZXZlbDBCb2R5LFxuICAgICAgICBwcmV2aW91c05hdlNlY3Rpb24sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdHJ1ZVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlTGV2ZWwxQ2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgbGV0IG5hdkl0ZW1zID0gbmV3IE5hdmlnYXRpb25JdGVtcyh0aGlzKVxuICAgICAgLmZyb21MZXZlbDEoZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KVxuXG4gICAgbGV0IHByZXZJdGVtcyA9IG5hdkl0ZW1zLnByZXZpb3VzTGV2ZWwxKClcblxuICAgIHRoaXMuX3RvZ2dsZUNvbnRhaW5lcihcbiAgICAgIG5hdkl0ZW1zLmxpbmssXG4gICAgICBuYXZJdGVtcy5jb250YWluZXIsXG4gICAgICBuYXZJdGVtcy5zZWN0aW9uLFxuICAgICAgbmF2SXRlbXMuZm9vdGVyLFxuICAgICAgcHJldkl0ZW1zLmxpbmssXG4gICAgICBwcmV2SXRlbXMuY29udGFpbmVyLFxuICAgICAgcHJldkl0ZW1zLnNlY3Rpb24sXG4gICAgICBwcmV2SXRlbXMuZm9vdGVyLFxuICAgICAgZmFsc2VcbiAgICApXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHByb3RlY3RlZCBfdG9nZ2xlQ29udGFpbmVyKFxuICAgIG5hdkxpbms6IEhUTUxFbGVtZW50LFxuICAgIG5hdkNvbnRhaW5lcj86IEhUTUxFbGVtZW50LFxuICAgIG5hdlNlY3Rpb24/OiBIVE1MRWxlbWVudCxcbiAgICBuYXZGb290ZXI/OiBIVE1MRWxlbWVudCxcbiAgICBwcmV2aW91c05hdkxpbms/OiBIVE1MRWxlbWVudCxcbiAgICBwcmV2aW91c05hdkNvbnRhaW5lcj86IEhUTUxFbGVtZW50LFxuICAgIHByZXZpb3VzTmF2U2VjdGlvbj86IEhUTUxFbGVtZW50LFxuICAgIHByZXZpb3VzTmF2Rm9vdGVyPzogSFRNTEVsZW1lbnQsXG4gICAgYW5pbWF0ZUNvbnRhaW5lciA9IGZhbHNlXG4gICkge1xuICAgIGNvbnN0IGlzRGVza3RvcCA9ICF0aGlzLl9pc01vYmlsZSgpXG5cbiAgICBpZiAocHJldmlvdXNOYXZMaW5rICYmIHByZXZpb3VzTmF2TGluayAhPT0gbmF2TGluayAmJiBuYXZMaW5rICE9PSB0aGlzLl9oYW1idXJnZXJFbGVtZW50KSB7XG4gICAgICBEb20ucmVtb3ZlQ2xhc3MocHJldmlvdXNOYXZMaW5rLCBDTEFTU19BQ1RJVkUpXG4gICAgfVxuXG4gICAgdGhpcy5fcmVzZXRNYWluVGltZWxpbmUobmF2Q29udGFpbmVyISwgbmF2U2VjdGlvbiEsIG5hdkZvb3RlciEsIHByZXZpb3VzTmF2Q29udGFpbmVyISwgcHJldmlvdXNOYXZTZWN0aW9uISwgcHJldmlvdXNOYXZGb290ZXIhKVxuXG4gICAgaWYgKERvbS5oYXNDbGFzcyhuYXZMaW5rLCBDTEFTU19BQ1RJVkUpKSB7XG4gICAgICBEb20ucmVtb3ZlQ2xhc3MobmF2TGluaywgQ0xBU1NfQUNUSVZFKVxuXG4gICAgICBpZiAoaXNEZXNrdG9wKSB7XG4gICAgICAgIHRoaXMuX29uTmF2aWdhdGlvbkNsb3NlZCgpXG5cbiAgICAgICAgdGhpcy5fY2xvc2VTZWN0aW9uKG5hdkNvbnRhaW5lciwgbmF2U2VjdGlvbiwgbmF2Rm9vdGVyLCB0cnVlLCBhbmltYXRlQ29udGFpbmVyKVxuICAgICAgfSBlbHNlIGlmIChuYXZMaW5rID09PSB0aGlzLl9oYW1idXJnZXJFbGVtZW50KSB7XG4gICAgICAgIC8vIENsb3NlIG1vYmlsZSBuYXZpZ2F0aW9uXG4gICAgICAgIHRoaXMuX29uTmF2aWdhdGlvbkNsb3NlZCgpXG5cbiAgICAgICAgdGhpcy5fY2xvc2VTZWN0aW9uKG5hdkNvbnRhaW5lciwgbmF2U2VjdGlvbiwgdW5kZWZpbmVkLCBmYWxzZSwgZmFsc2UpXG4gICAgICB9IGVsc2UgaWYgKCFpc0Rlc2t0b3ApIHtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIHNlY3Rpb25cbiAgICAgICAgdGhpcy5fY2xvc2VTZWN0aW9uKG5hdkNvbnRhaW5lciwgbmF2U2VjdGlvbiwgbmF2Rm9vdGVyLCB0cnVlLCBhbmltYXRlQ29udGFpbmVyKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBEb20uYWRkQ2xhc3MobmF2TGluaywgQ0xBU1NfQUNUSVZFKVxuXG4gICAgICBpZiAoaXNEZXNrdG9wKSB7XG4gICAgICAgIERvbS5hZGRDbGFzcyh0aGlzLl9uYXZNb2JpbGUsIENMQVNTX09QRU4pXG4gICAgICAgIHRoaXMuX29uTmF2aWdhdGlvbk9wZW5lZCgpXG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmF2Q29udGFpbmVyICYmIHByZXZpb3VzTmF2U2VjdGlvbikge1xuICAgICAgICAgIHRoaXMuX2Nsb3NlU2VjdGlvbihwcmV2aW91c05hdkNvbnRhaW5lciwgcHJldmlvdXNOYXZTZWN0aW9uLCBwcmV2aW91c05hdkZvb3RlciwgdHJ1ZSwgYW5pbWF0ZUNvbnRhaW5lcilcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vcGVuU2VjdGlvbihuYXZDb250YWluZXIsIG5hdlNlY3Rpb24sIG5hdkZvb3RlciwgdHJ1ZSwgYW5pbWF0ZUNvbnRhaW5lcilcbiAgICAgIH0gZWxzZSBpZiAobmF2TGluayA9PT0gdGhpcy5faGFtYnVyZ2VyRWxlbWVudCkge1xuICAgICAgICAvLyBPcGVuIG1vYmlsZSBuYXZpZ2F0aW9uXG4gICAgICAgIHRoaXMuX29uTmF2aWdhdGlvbk9wZW5lZCgpXG5cbiAgICAgICAgdGhpcy5fb3BlblNlY3Rpb24obmF2Q29udGFpbmVyLCBuYXZTZWN0aW9uLCB1bmRlZmluZWQsIGZhbHNlLCBmYWxzZSlcbiAgICAgIH0gZWxzZSBpZiAoIWlzRGVza3RvcCkge1xuICAgICAgICAvLyBPcGVuIHNlY3Rpb25cbiAgICAgICAgaWYgKHByZXZpb3VzTmF2Q29udGFpbmVyICYmIHByZXZpb3VzTmF2U2VjdGlvbikge1xuICAgICAgICAgIHRoaXMuX2Nsb3NlU2VjdGlvbihwcmV2aW91c05hdkNvbnRhaW5lciwgcHJldmlvdXNOYXZTZWN0aW9uLCBwcmV2aW91c05hdkZvb3RlciwgdHJ1ZSwgYW5pbWF0ZUNvbnRhaW5lcilcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IGFuaW1lLnRpbWVsaW5lKClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vcGVuU2VjdGlvbihuYXZDb250YWluZXIsIG5hdlNlY3Rpb24sIG5hdkZvb3RlciwgdHJ1ZSwgYW5pbWF0ZUNvbnRhaW5lcilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX29uTmF2aWdhdGlvbk9wZW5lZCgpIHtcbiAgICBEb20uYWRkQ2xhc3ModGhpcy5fbmF2TW9iaWxlLCBDTEFTU19PUEVOKVxuICAgIERvbS5hZGRDbGFzcyh0aGlzLl9uYXZNb2JpbGUucGFyZW50RWxlbWVudCEsIENMQVNTX09QRU4pXG4gICAgRG9tLmFkZENsYXNzKHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQsIENMQVNTX0FDVElWRSlcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9vbk5hdmlnYXRpb25DbG9zZWQoKSB7XG4gICAgRG9tLnJlbW92ZUNsYXNzKHRoaXMuX25hdk1vYmlsZSwgQ0xBU1NfT1BFTilcbiAgICBEb20ucmVtb3ZlQ2xhc3ModGhpcy5fbmF2TW9iaWxlLnBhcmVudEVsZW1lbnQhLCBDTEFTU19PUEVOKVxuICAgIERvbS5yZW1vdmVDbGFzcyh0aGlzLl9oYW1idXJnZXJFbGVtZW50LCBDTEFTU19BQ1RJVkUpXG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlV2luZG93Q2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudFxuXG4gICAgd2hpbGUgKHRhcmdldCAhPT0gdGhpcy5lbGVtZW50ICYmIHRhcmdldC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudFxuICAgIH1cblxuICAgIGlmICh0YXJnZXQgIT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcHJvdGVjdGVkIF9vcGVuU2VjdGlvbihcbiAgICBuYXZDb250YWluZXI/OiBIVE1MRWxlbWVudCxcbiAgICBuYXZTZWN0aW9uPzogSFRNTEVsZW1lbnQsXG4gICAgbmF2Rm9vdGVyPzogSFRNTEVsZW1lbnQsXG4gICAgYW5pbWF0ZUNvbHVtbnMgPSB0cnVlLFxuICAgIGFuaW1hdGVDb250YWluZXIgPSBmYWxzZVxuICApIHtcbiAgICBpZiAoIW5hdlNlY3Rpb24gfHwgIW5hdkNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGFjdGl2ZUl0ZW1zID0gbmF2U2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX05BVl9DT0xVTU4pXG5cbiAgICBpZiAoYW5pbWF0ZUNvbnRhaW5lciA9PT0gdHJ1ZSkge1xuICAgICAgbGV0IGNvbnRhaW5lciA9IG5hdkNvbnRhaW5lclxuICAgICAgbmF2Q29udGFpbmVyID0gbmF2U2VjdGlvblxuICAgICAgbmF2U2VjdGlvbiA9IGNvbnRhaW5lclxuICAgIH1cblxuICAgIERvbS5hZGRDbGFzcyhuYXZDb250YWluZXIhLCBDTEFTU19PUEVOKVxuXG4gICAgbmF2U2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiXG5cbiAgICB0aGlzLmFuaW1hdGlvbi5hZGQoe1xuICAgICAgdGFyZ2V0czogbmF2U2VjdGlvbixcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fQk9EWV9EVVJBVElPTixcbiAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgaGVpZ2h0OiBhbmltYXRlQ29udGFpbmVyID8gbmF2Q29udGFpbmVyLnNjcm9sbEhlaWdodCA6IG5hdlNlY3Rpb24uc2Nyb2xsSGVpZ2h0LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgRG9tLmFkZENsYXNzKG5hdlNlY3Rpb24hLCBDTEFTU19PUEVOKVxuICAgICAgICBuZXcgRG9tRWxlbWVudChuYXZTZWN0aW9uISkuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKG5hdkZvb3Rlcikge1xuICAgICAgY29uc3QgbmF2SXRlbXMgPSBuYXZGb290ZXIucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfQ09MVU1OKVxuICAgICAgZm9yIChsZXQgaXRlbSBvZiBuYXZJdGVtcykge1xuICAgICAgICBEb20uYWRkQ2xhc3MoaXRlbSwgQ0xBU1NfQUNUSVZFKVxuICAgICAgfVxuXG4gICAgICBuYXZGb290ZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuXG4gICAgICB0aGlzLmFuaW1hdGlvbi5hZGQoe1xuICAgICAgICB0YXJnZXRzOiBuYXZGb290ZXIsXG4gICAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fRk9PVEVSX0RVUkFUSU9OLFxuICAgICAgICBlYXNpbmc6IFwiY3ViaWNCZXppZXIoMC41NTAsIDAuMDg1LCAwLjMyMCwgMSlcIixcbiAgICAgICAgaGVpZ2h0OiBuYXZGb290ZXIuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICBvZmZzZXQ6IGAtPSR7QU5JTUFUSU9OX0ZPT1RFUl9EVVJBVElPTn1gLFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIERvbS5hZGRDbGFzcyhuYXZGb290ZXIhLCBDTEFTU19PUEVOKVxuICAgICAgICAgIG5ldyBEb21FbGVtZW50KG5hdkZvb3RlciEpLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGFuaW1hdGVDb2x1bW5zID09PSB0cnVlKSB7XG4gICAgICBsZXQgZGVsYXkgPSBBTklNQVRJT05fU1RBUlRfREVMQVlcblxuICAgICAgZm9yIChsZXQgaXRlbSBvZiBhY3RpdmVJdGVtcykge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGQoe1xuICAgICAgICAgIHRhcmdldHM6IGl0ZW0sXG4gICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgb2Zmc2V0OiBkZWxheSxcbiAgICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgRG9tLmFkZENsYXNzKGl0ZW0sIENMQVNTX0FDVElWRSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGRlbGF5ICs9IEFOSU1BVElPTl9PRkZTRVRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2Nsb3NlU2VjdGlvbihcbiAgICBuYXZDb250YWluZXI/OiBIVE1MRWxlbWVudCxcbiAgICBuYXZTZWN0aW9uPzogSFRNTEVsZW1lbnQsXG4gICAgbmF2Rm9vdGVyPzogSFRNTEVsZW1lbnQsXG4gICAgYW5pbWF0ZUNvbHVtbnMgPSB0cnVlLFxuICAgIGFuaW1hdGVDb250YWluZXIgPSBmYWxzZVxuICApIHtcbiAgICBpZiAoIW5hdlNlY3Rpb24gfHwgIW5hdkNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGFjdGl2ZUl0ZW1zID0gbmF2U2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX05BVl9DT0xVTU5fQUNUSVZFKVxuXG4gICAgaWYgKGFuaW1hdGVDb250YWluZXIgPT09IHRydWUpIHtcbiAgICAgIGxldCBjb250YWluZXIgPSBuYXZDb250YWluZXJcbiAgICAgIG5hdkNvbnRhaW5lciA9IG5hdlNlY3Rpb25cbiAgICAgIG5hdlNlY3Rpb24gPSBjb250YWluZXJcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0ZUNvbHVtbnMgPT09IHRydWUpIHtcbiAgICAgIGZvciAobGV0IGFjdGl2ZSBvZiBhY3RpdmVJdGVtcykge1xuICAgICAgICBEb20ucmVtb3ZlQ2xhc3MoYWN0aXZlLCBDTEFTU19BQ1RJVkUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hbmltYXRpb24uYWRkKHtcbiAgICAgIHRhcmdldHM6IG5hdlNlY3Rpb24sXG4gICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX0JPRFlfRFVSQVRJT04sXG4gICAgICBlYXNpbmc6IFwiY3ViaWNCZXppZXIoMC41NTAsIDAuMDg1LCAwLjMyMCwgMSlcIixcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhuYXZDb250YWluZXIhLCBDTEFTU19PUEVOKVxuICAgICAgICBEb20ucmVtb3ZlQ2xhc3MobmF2U2VjdGlvbiEsIENMQVNTX09QRU4pXG4gICAgICAgIG5hdlNlY3Rpb24hLnN0eWxlLmhlaWdodCA9IFwiXCJcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKG5hdkZvb3Rlcikge1xuICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIG5hdkZvb3Rlci5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX05BVl9DT0xVTU5fQUNUSVZFKSkge1xuICAgICAgICBEb20ucmVtb3ZlQ2xhc3MoYWN0aXZlLCBDTEFTU19BQ1RJVkUpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuYW5pbWF0aW9uLmFkZCh7XG4gICAgICAgIHRhcmdldHM6IG5hdkZvb3RlcixcbiAgICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9GT09URVJfRFVSQVRJT04sXG4gICAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBEb20ucmVtb3ZlQ2xhc3MobmF2Rm9vdGVyISwgQ0xBU1NfT1BFTilcbiAgICAgICAgICBuYXZGb290ZXIhLnN0eWxlLmhlaWdodCA9IFwiXCJcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVNlYXJjaENsaWNrKCkge1xuICAgIGlmICh0aGlzLl9zZWFyY2hEZXNrdG9wKSB7XG4gICAgICB0aGlzLl9zZWFyY2hEZXNrdG9wLm9wZW4oKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbmF2aWdhdGlvbiBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgZm9yIChsZXQgbmF2TGluayBvZiB0aGlzLl9uYXZMZXZlbDAucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfTEVWRUwwX0xJTkspKSB7XG4gICAgICBuYXZMaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9sZXZlbDBDbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgbmF2TGluayBvZiB0aGlzLl9uYXZMZXZlbDEucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfTEVWRUwxX0xJTkspKSB7XG4gICAgICBuYXZMaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9sZXZlbDFDbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgdGhpcy5faGFtYnVyZ2VyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fbGV2ZWwxQ2xpY2tIYW5kbGVyKVxuXG4gICAgLy8gRGVza3RvcCBzZWFyY2ggaWNvblxuICAgIGxldCBzZWFyY2hJY29uID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfU0VBUkNIX0lDT04pXG4gICAgaWYgKHNlYXJjaEljb24pIHtcbiAgICAgIHNlYXJjaEljb24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3NlYXJjaENsaWNrSGFuZGxlcilcbiAgICB9XG5cbiAgICBmb3IgKGxldCBzZWFyY2ggb2YgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfU0VBUkNIX0ZJRUxEKSkge1xuICAgICAgbGV0IHNlYXJjaENvbXBvbmVudCA9IG5ldyBTZWFyY2hJbnB1dChzZWFyY2ggYXMgSFRNTEVsZW1lbnQpXG5cbiAgICAgIGlmIChEb20uaGFzQ2xhc3Moc2VhcmNoLCBDTEFTU19TRUFSQ0hfREVTS1RPUCkgfHwgRG9tLmhhc0NsYXNzKHNlYXJjaC5wYXJlbnRFbGVtZW50ISwgQ0xBU1NfU0VBUkNIX0RFU0tUT1ApKSB7XG4gICAgICAgIHRoaXMuX3NlYXJjaERlc2t0b3AgPSBzZWFyY2hDb21wb25lbnRcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VhcmNoQ29tcG9uZW50cy5wdXNoKHNlYXJjaENvbXBvbmVudClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBuYXZpZ2F0aW9uLlxuICAgKi9cbiAgcHVibGljIGNsb3NlKCkge1xuICAgIGxldCBpc01vYmxlID0gdGhpcy5faXNNb2JpbGUoKVxuXG4gICAgbGV0IGxldmVsMSA9IHRoaXMuX25hdkxldmVsMS5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9MSU5LX0FDVElWRSkgYXMgSFRNTEVsZW1lbnRcbiAgICBsZXQgbGV2ZWwwID0gdGhpcy5fbmF2TGV2ZWwwLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0xJTktfQUNUSVZFKSBhcyBIVE1MRWxlbWVudFxuXG4gICAgaWYgKCFsZXZlbDEgJiYgaXNNb2JsZSAmJiBEb20uaGFzQ2xhc3ModGhpcy5faGFtYnVyZ2VyRWxlbWVudCwgQ0xBU1NfQUNUSVZFKSkge1xuICAgICAgbGV2ZWwxID0gdGhpcy5faGFtYnVyZ2VyRWxlbWVudFxuICAgIH1cblxuICAgIGxldCBuYXZJdGVtc1xuXG4gICAgaWYgKGxldmVsMSkge1xuICAgICAgbmF2SXRlbXMgPSBuZXcgTmF2aWdhdGlvbkl0ZW1zKHRoaXMpLmZyb21MZXZlbDEobGV2ZWwxKVxuICAgIH0gZWxzZSBpZiAobGV2ZWwwKSB7XG4gICAgICBuYXZJdGVtcyA9IG5ldyBOYXZpZ2F0aW9uSXRlbXModGhpcykuZnJvbUxldmVsMChsZXZlbDApXG4gICAgfVxuXG4gICAgaWYgKG5hdkl0ZW1zKSB7XG4gICAgICB0aGlzLl9yZXNldE1haW5UaW1lbGluZShuYXZJdGVtcy5jb250YWluZXIhLCBuYXZJdGVtcy5zZWN0aW9uISwgbmF2SXRlbXMuZm9vdGVyISlcbiAgICAgIERvbS5yZW1vdmVDbGFzcyhuYXZJdGVtcy5saW5rLCBDTEFTU19BQ1RJVkUpXG4gICAgICB0aGlzLl9vbk5hdmlnYXRpb25DbG9zZWQoKVxuICAgICAgdGhpcy5fY2xvc2VTZWN0aW9uKG5hdkl0ZW1zLmNvbnRhaW5lciEsIG5hdkl0ZW1zLnNlY3Rpb24hLCBuYXZJdGVtcy5mb290ZXIsICFpc01vYmxlLCBmYWxzZSlcbiAgICB9XG5cbiAgfVxufVxuXG5jbGFzcyBOYXZpZ2F0aW9uSXRlbXMge1xuICBwcml2YXRlIF9uYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uXG4gIHByaXZhdGUgX2xpbmshOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9jb250YWluZXI/OiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9zZWN0aW9uPzogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfZm9vdGVyPzogSFRNTEVsZW1lbnRcbiAgY29uc3RydWN0b3IobmF2OiBOYXZpZ2F0aW9uKSB7XG4gICAgdGhpcy5fbmF2aWdhdGlvbiA9IG5hdlxuICB9XG5cbiAgZ2V0IGxpbmsoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmtcbiAgfVxuXG4gIGdldCBjb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lclxuICB9XG5cbiAgZ2V0IHNlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25cbiAgfVxuXG4gIGdldCBmb290ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Zvb3RlclxuICB9XG5cbiAgcHVibGljIGZyb21MZXZlbDAobmF2TGluazogSFRNTEVsZW1lbnQpIHtcbiAgICB3aGlsZSAoIURvbS5oYXNDbGFzcyhuYXZMaW5rLCBDTEFTU19OQVZfTElOSykgJiYgbmF2TGluay5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBuYXZMaW5rID0gbmF2TGluay5wYXJlbnRFbGVtZW50XG4gICAgfVxuXG4gICAgdGhpcy5fbGluayA9IG5hdkxpbmtcblxuICAgIGxldCB0b2dnbGVJZCA9IG5hdkxpbmsuZ2V0QXR0cmlidXRlKFwiZGF0YS10b2dnbGVcIilcbiAgICB0aGlzLl9jb250YWluZXIgPSB0aGlzLl9uYXZpZ2F0aW9uLl9uYXZMZXZlbDBCb2R5XG4gICAgdGhpcy5fc2VjdGlvbiA9IHRoaXMuX25hdmlnYXRpb24uX25hdkxldmVsMC5xdWVyeVNlbGVjdG9yKGAjJHt0b2dnbGVJZH1gKSEgYXMgSFRNTEVsZW1lbnRcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgZnJvbUxldmVsMShuYXZMaW5rOiBIVE1MRWxlbWVudCkge1xuICAgIHdoaWxlIChuYXZMaW5rLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGlmICgobmF2TGluayA9PT0gdGhpcy5fbmF2aWdhdGlvbi5faGFtYnVyZ2VyRWxlbWVudCkgfHwgRG9tLmhhc0NsYXNzKG5hdkxpbmssIENMQVNTX05BVl9MSU5LKSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBuYXZMaW5rID0gbmF2TGluay5wYXJlbnRFbGVtZW50XG4gICAgfVxuXG4gICAgdGhpcy5fbGluayA9IG5hdkxpbmtcbiAgICB0aGlzLl9jb250YWluZXIgPSBuYXZMaW5rLnBhcmVudEVsZW1lbnQhIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fc2VjdGlvbiA9IHRoaXMuX2NvbnRhaW5lciEucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfQk9EWSkhIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fZm9vdGVyID0gdGhpcy5fY29udGFpbmVyIS5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9GT09URVIpISBhcyBIVE1MRWxlbWVudFxuXG4gICAgaWYgKG5hdkxpbmsgPT09IHRoaXMuX25hdmlnYXRpb24uX2hhbWJ1cmdlckVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuX25hdmlnYXRpb24uX25hdkxldmVsMVxuICAgICAgdGhpcy5fc2VjdGlvbiA9IHRoaXMuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9IQl9CT0RZKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHVibGljIHByZXZpb3VzTGV2ZWwxKCkge1xuICAgIGxldCBwcmV2ID0gbmV3IE5hdmlnYXRpb25JdGVtcyh0aGlzLl9uYXZpZ2F0aW9uKVxuXG4gICAgcHJldi5fbGluayA9IHRoaXMuX25hdmlnYXRpb24uX25hdkxldmVsMS5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9MSU5LX0FDVElWRSkhIGFzIEhUTUxFbGVtZW50XG4gICAgcHJldi5fY29udGFpbmVyID0gcHJldi5fbGluayA/IHByZXYuX2xpbmsucGFyZW50RWxlbWVudCEgOiB1bmRlZmluZWRcbiAgICBwcmV2Ll9zZWN0aW9uID0gcHJldi5fY29udGFpbmVyID8gcHJldi5fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0JPRFkpISBhcyBIVE1MRWxlbWVudCA6IHVuZGVmaW5lZFxuICAgIHByZXYuX2Zvb3RlciA9IHByZXYuX2NvbnRhaW5lciA/IHByZXYuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9GT09URVIpISBhcyBIVE1MRWxlbWVudCA6IHVuZGVmaW5lZFxuXG4gICAgcmV0dXJuIHByZXZcbiAgfVxuXG4gIHB1YmxpYyBpc0hhbWJ1cmdlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGluayA9PT0gdGhpcy5fbmF2aWdhdGlvbi5faGFtYnVyZ2VyRWxlbWVudFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLm5hdlwiLCAoZSkgPT4ge1xuICAgIG5ldyBOYXZpZ2F0aW9uKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IE5hdmlnYXRpb25cbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIHByZXZlbnREZWZhdWx0IH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5pbXBvcnQgeyBoYXNDbGFzcywgYWRkQ2xhc3MsIHJlbW92ZUNsYXNzIH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcImlzLW9wZW5cIlxuY29uc3QgQ0xBU1NfQUNUSVZFID0gXCJpcy1hY3RpdmVcIlxuXG5jb25zdCBRVUVSWV9TSVRFX1dSQVBQRVIgPSBcIi5qcy1zaXRlLXdyYXBwZXJcIlxuY29uc3QgUVVFUllfTkFWX0hBTUJVUkdFUiA9IFwiLmpzLXNpdGUtd3JhcHBlciAuanMtaGFtYnVyZ2VyXCJcblxuY29uc3QgUVVFUllfTkFWX0lURU0gPSBcIi5qcy1uYXYtaXRlbVwiXG5cbmNvbnN0IE5BVl9MSU5LX0lOSVRJQUxfU0NBTEUgPSAwLjlcbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTl9MSU5LUyA9IDEwMFxuY29uc3QgQU5JTUFUSU9OX0RVUkFUSU9OX05BViA9IDMwMFxuXG5jb25zdCBBTklNQVRJT05fU1RBR0dFUl9ERUxBWSA9IDUwXG5cbi8qKlxuICogVGhlIG5hdmlnYXRpb24gc2lkZSBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xuY2xhc3MgTmF2aWdhdGlvblNpZGUgZXh0ZW5kcyBEb21FbGVtZW50IHtcbiAgcHJpdmF0ZSBfY2xpY2tIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3dpbmRvd0NsaWNrSGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX3NpdGVXcmFwcGVyOiBFbGVtZW50XG4gIHByaXZhdGUgX2hhbWJ1cmdlckVsZW1lbnQ6IEVsZW1lbnRcbiAgcHJpdmF0ZSBfbmF2SXRlbXM6IE5vZGVMaXN0T2Y8RWxlbWVudD5cblxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX2NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVXaW5kb3dDbGljay5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9zaXRlV3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfU0lURV9XUkFQUEVSKSFcbiAgICB0aGlzLl9oYW1idXJnZXJFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfSEFNQlVSR0VSKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgdGhpcy5fbmF2SXRlbXMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfSVRFTSkhXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9oYW1idXJnZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gICAgdGhpcy5faGFtYnVyZ2VyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVDbGljayhldmVudDogRXZlbnQpIHtcbiAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICB0aGlzLnRvZ2dsZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVdpbmRvd0NsaWNrKGV2ZW50OiBFdmVudCkge1xuICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgRWxlbWVudFxuXG4gICAgd2hpbGUgKHRhcmdldCAhPT0gdGhpcy5lbGVtZW50ICYmIHRhcmdldC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudFxuICAgIH1cblxuICAgIGlmICh0YXJnZXQgIT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHNpZGUgbmF2aWdhdGlvbi5cbiAgICovXG4gIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgaWYgKGhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTikgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLm9wZW4oKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIHNsaWRlIG5hdmlnYXRpb24uXG4gICAqL1xuICBwdWJsaWMgb3BlbigpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgfSwgNTApXG5cbiAgICBhZGRDbGFzcyh0aGlzLl9oYW1idXJnZXJFbGVtZW50LCBDTEFTU19BQ1RJVkUpXG4gICAgYWRkQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKVxuICAgIGFkZENsYXNzKHRoaXMuX3NpdGVXcmFwcGVyLCBDTEFTU19PUEVOKVxuXG4gICAgY29uc3QgeCA9IGFuaW1lLnRpbWVsaW5lKClcbiAgICBsZXQgb2ZmID0gQU5JTUFUSU9OX0RVUkFUSU9OX05BVlxuICAgIHRoaXMuX25hdkl0ZW1zLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGVsID0gZWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICAgICAgZWwuc3R5bGUub3BhY2l0eSA9IFwiMFwiXG4gICAgICBlbC5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHtOQVZfTElOS19JTklUSUFMX1NDQUxFfSlgXG4gICAgICB4LmFkZCh7XG4gICAgICAgIHRhcmdldHM6IGVsLFxuICAgICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX0RVUkFUSU9OX0xJTktTLFxuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBzY2FsZTogMSxcbiAgICAgICAgZWFzaW5nOiBcImxpbmVhclwiLFxuICAgICAgICBvZmZzZXQ6IG9mZlxuICAgICAgfSlcbiAgICAgIG9mZiArPSBBTklNQVRJT05fU1RBR0dFUl9ERUxBWVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBzaWRlIG5hdmlnYXRpb24uXG4gICAqL1xuICBwdWJsaWMgY2xvc2UoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG5cbiAgICByZW1vdmVDbGFzcyh0aGlzLl9oYW1idXJnZXJFbGVtZW50LCBDTEFTU19BQ1RJVkUpXG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKVxuICAgIHJlbW92ZUNsYXNzKHRoaXMuX3NpdGVXcmFwcGVyLCBDTEFTU19PUEVOKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjb21wb25lbnQgYW5kIHJlbW92ZXMgYWxsIGV2ZW50XG4gICAqIHN1YnNjcmlwdGlvbnMgYW5kIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcik7XG5cbiAgICAodGhpcyBhcyBhbnkpLl93aW5kb3dDbGlja0hhbmRsZXIgPSBudWxsO1xuXG4gICAgKHRoaXMgYXMgYW55KS5fY2xpY2tIYW5kbGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9zaXRlV3JhcHBlciA9IG51bGw7XG5cbiAgICAodGhpcyBhcyBhbnkpLl9oYW1idXJnZXJFbGVtZW50ID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9uYXZJdGVtcyA9IG51bGxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5uYXYtc2lkZVwiLCAoZSkgPT4ge1xuICAgIG5ldyBOYXZpZ2F0aW9uU2lkZShlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBOYXZpZ2F0aW9uU2lkZVxuIiwiaW1wb3J0IHsgcHJldmVudERlZmF1bHQgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuXG5jb25zdCBDTEFTU19OT1RJRklDQVRJT04gPSBcIm5vdGlmaWNhdGlvbi1oZWFkZXJcIlxuXG5jb25zdCBDTEFTU19PUEVOID0gXCJub3RpZmljYXRpb24tLW9wZW5cIlxuY29uc3QgQ0xBU1NfQlVUVE9OX0NMT1NFID0gXCJub3RpZmljYXRpb25fX2Nsb3NlXCJcblxuLyoqXG4gKiBOb3RpZmljYXRpb24gY29tcG9uZW50LlxuICogQG5hbWVzcGFjZSBOb3RpZmljYXRpb25cbiAqL1xuXG4vKipcbiAqIFRoZSBtZXNzYWdlIGNsaWNrIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQG1lbWJlcm9mIE5vdGlmaWNhdGlvblxuICogQGNhbGxiYWNrIE5vdGlmaWNhdGlvbn5DbGlja1xuICogQHByb3BlcnR5IHtOb3RpZmljYXRpb25IZWFkZXJ9IGl0ZW0gLSBUaGUgY3VycmVudCBub3RpZmljYXRpb24gaGVhZGVyIGluc3RhbmNlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybiB0cnVlIGlmIHRoZSBub3RpZmljYXRpb24gc2hvdWxkIGJlIGNsb3NlZDsgcmV0dXJuIGZhbHNlIGlmIHRoZVxuICogICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbiBzaG91bGQgcmVtYWluIG9wZW4uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZUNsaWNrQ2FsbGJhY2sge1xuICAoaGVhZGVyOiBOb3RpZmljYXRpb25IZWFkZXIpOiBib29sZWFuIHwgdW5kZWZpbmVkXG59XG5cbi8qKlxuICogVGhlIGNhbmNlbCBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBtZW1iZXJvZiBOb3RpZmljYXRpb25cbiAqIEBjYWxsYmFjayBOb3RpZmljYXRpb25+Q2FuY2VsXG4gKiBAcHJvcGVydHkge05vdGlmaWNhdGlvbkhlYWRlcn0gaXRlbSAtIFRoZSBjdXJyZW50IG5vdGlmaWNhdGlvbiBoZWFkZXIgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FuY2VsQ2FsbGJhY2sge1xuICAoaGVhZGVyOiBOb3RpZmljYXRpb25IZWFkZXIpOiB2b2lkXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgc2hvd3MgYSBub3RpZmljYXRpb24gd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UuXG4gKiBAbWVtYmVyb2YgTm90aWZpY2F0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGFpbmVySWQgLSBUaGUgaWQgb2YgdGhlIGNvbnRhaW5lciBvbiB3aGVyZSB0byBzaG93IHRoZSBub3RpZmljYXRpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIHNob3cuXG4gKiBAcGFyYW0ge05vdGlmaWNhdGlvbn5DbGlja30gbWVzc2FnZUNsaWNrQ2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbm90aWZpY2F0aW9uIG1lc3NhZ2UgdGV4dC5cbiAqIEBwYXJhbSB7Tm90aWZpY2F0aW9ufkNhbmNlbH0gY2FuY2VsQ2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNhbmNlbHMgdGhlIG5vdGlmaWNhdGlvbiBieSBjbG9zaW5nIGl0LlxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyQ2xhc3MgLSBUaGUgY3NzIG1vZGlmaWVyIGNsYXNzIGZvciB0aGUgbm90aWZpY2F0aW9uOyB0aGlzIGlzIGFuIG9wdGlvbmFsIHBhcmFtZXRlclxuICogQHJldHVybnMge05vdGlmaWNhdGlvbkhlYWRlcn0gVGhlIG5vdGlmaWNhdGlvbiBoZWFkZXIgaXRlbSBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3dPbkhlYWRlcihcbiAgY29udGFpbmVySWQ6IHN0cmluZyxcbiAgbWVzc2FnZTogc3RyaW5nLFxuICBtZXNzYWdlQ2xpY2tDYWxsYmFjaz86IE1lc3NhZ2VDbGlja0NhbGxiYWNrLFxuICBjYW5jZWxDYWxsYmFjaz86IENhbmNlbENhbGxiYWNrLFxuICBtb2RpZmllckNsYXNzPzogc3RyaW5nXG4pIHtcblxuICBjb25zdCBjb250YWluZXJFID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7Y29udGFpbmVySWR9YClcbiAgaWYgKCFjb250YWluZXJFKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCB0aGUgY29udGFpbmVyIHdpdGggaWQgJHtjb250YWluZXJJZH1gKVxuICB9XG5cbiAgY29uc3QgY29udGFpbmVyRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KGNvbnRhaW5lckUpXG4gIGNvbnN0IG5vdGlmaWNhdGlvbkVsZW1lbnQgPSBuZXcgTm90aWZpY2F0aW9uSGVhZGVyKClcblxuICBpZiAobW9kaWZpZXJDbGFzcykge1xuICAgIG5vdGlmaWNhdGlvbkVsZW1lbnQuYWRkQ2xhc3MobW9kaWZpZXJDbGFzcylcbiAgfVxuXG4gIG5vdGlmaWNhdGlvbkVsZW1lbnQubWVzc2FnZSA9IG1lc3NhZ2VcbiAgbm90aWZpY2F0aW9uRWxlbWVudC5tZXNzYWdlQ2xpY2tDYWxsYmFjayA9IG1lc3NhZ2VDbGlja0NhbGxiYWNrXG4gIG5vdGlmaWNhdGlvbkVsZW1lbnQuY2FuY2VsQ2FsbGJhY2sgPSBjYW5jZWxDYWxsYmFja1xuXG4gIGNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQobm90aWZpY2F0aW9uRWxlbWVudClcbiAgbm90aWZpY2F0aW9uRWxlbWVudC5fb3BlbigpXG5cbiAgcmV0dXJuIG5vdGlmaWNhdGlvbkVsZW1lbnRcbn1cblxuLyoqXG4gKiBBIGNvbXBvbmVudCBmb3IgZGlzcGxheWluZyBub3RpZmljYXRpb25zIG9uIHRoZSBwYWdlLWhlYWRlci5cbiAqIEBpbm5lclxuICogQG1lbWJlcm9mIE5vdGlmaWNhdGlvblxuICovXG5leHBvcnQgY2xhc3MgTm90aWZpY2F0aW9uSGVhZGVyIGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgX2Nsb3NlSGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9jbGlja0hhbmRsZXI6IChldmVudDogRXZlbnQpID0+IHZvaWRcblxuICBwcml2YXRlIF9jYWxsYmFjaz86IE1lc3NhZ2VDbGlja0NhbGxiYWNrXG4gIHByaXZhdGUgX2NhbmNlbENhbGxiYWNrPzogQ2FuY2VsQ2FsbGJhY2tcblxuICBwcml2YXRlIF9jbG9zZUJ1dHRvbiE6IERvbUVsZW1lbnQ8RWxlbWVudD5cbiAgcHJpdmF0ZSBfbm90aWZpY2F0aW9uQm9keSE6IERvbUVsZW1lbnQ8RWxlbWVudD5cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcImRpdlwiKVxuXG4gICAgdGhpcy5fY2xvc2VIYW5kbGVyID0gdGhpcy5faGFuZGxlQ2xvc2UuYmluZCh0aGlzKVxuICAgIHRoaXMuX2NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUNsaWNrLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSByYW5nZSBtb2RhbCBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5hZGRDbGFzcyhDTEFTU19OT1RJRklDQVRJT04pXG4gICAgdGhpcy5hZGRDbGFzcyhDTEFTU19PUEVOKVxuXG4gICAgY29uc3Qgbm90aWZpY2F0aW9uQ29udGVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoXCJub3RpZmljYXRpb25fX2NvbnRlbnRcIilcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQobm90aWZpY2F0aW9uQ29udGVudClcblxuICAgIHRoaXMuX25vdGlmaWNhdGlvbkJvZHkgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKFwibm90aWZpY2F0aW9uX19ib2R5XCIpXG5cbiAgICBub3RpZmljYXRpb25Db250ZW50LmFwcGVuZENoaWxkKHRoaXMuX25vdGlmaWNhdGlvbkJvZHkpXG5cbiAgICB0aGlzLl9jbG9zZUJ1dHRvbiA9IG5ldyBEb21FbGVtZW50KFwiYnV0dG9uXCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfQlVUVE9OX0NMT1NFKVxuICAgICAgLmFkZENsYXNzKFwibm90aWZpY2F0aW9uLWNhbmNlbFwiKVxuICAgICAgLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJDbG9zZVwiKVxuXG4gICAgY29uc3QgY2xvc2VJY29uID0gbmV3IERvbUVsZW1lbnQoXCJpXCIpXG4gICAgICAuYWRkQ2xhc3MoXCJpY29uXCIpXG4gICAgICAuYWRkQ2xhc3MoXCJpY29uLTAyMi1jbG9zZVwiKVxuICAgICAgLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKVxuXG4gICAgdGhpcy5fY2xvc2VCdXR0b24uYXBwZW5kQ2hpbGQoY2xvc2VJY29uKVxuICAgIG5vdGlmaWNhdGlvbkNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5fY2xvc2VCdXR0b24pXG5cbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQ2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG5cbiAgICBsZXQgY2xvc2VOb3RpZmljYXRpb24gPSB0cnVlXG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrKSB7XG4gICAgICBpZiAodGhpcy5fY2FsbGJhY2sodGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGNsb3NlTm90aWZpY2F0aW9uID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2xvc2VOb3RpZmljYXRpb24gPT09IHRydWUpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQ2xvc2UoZXZlbnQ6IEV2ZW50KSB7XG4gICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIGlmICh0aGlzLl9jYW5jZWxDYWxsYmFjaykge1xuICAgICAgdGhpcy5fY2FuY2VsQ2FsbGJhY2sodGhpcylcbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xvc2UoKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcyhDTEFTU19PUEVOKVxuICAgIHRoaXMuX2Nsb3NlQnV0dG9uLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2Nsb3NlSGFuZGxlcilcblxuICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgZG9tXG4gICAgICBpZiAoZWwgJiYgZWwucGFyZW50RWxlbWVudCkge1xuICAgICAgICBlbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGVsKVxuICAgICAgfVxuICAgIH0sIDMwMClcbiAgfVxuXG4gIC8vIGNhbGxlZCBieSBzaG93T25IZWFkZXJcbiAgcHVibGljIF9vcGVuKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfT1BFTilcblxuICAgIHRoaXMuX2Nsb3NlQnV0dG9uLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2Nsb3NlSGFuZGxlcilcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJvcGVuZWRcIilcbiAgfVxuXG4gIHNldCBtZXNzYWdlQ2xpY2tDYWxsYmFjayhjYWxsYmFjazogTWVzc2FnZUNsaWNrQ2FsbGJhY2sgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY2FuY2VsIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsLlxuICAgKi9cbiAgc2V0IGNhbmNlbENhbGxiYWNrKGNhbGxiYWNrOiBDYW5jZWxDYWxsYmFjayB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX2NhbmNlbENhbGxiYWNrID0gY2FsbGJhY2tcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBub3RpZmljYXRpb24gbWVzc2FnZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IC0gVGhlIG1lc3NhZ2UgdG8gc2V0LlxuICAgKi9cbiAgc2V0IG1lc3NhZ2UodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX25vdGlmaWNhdGlvbkJvZHkuc2V0SHRtbCh2YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG5vdGlmaWNhdGlvbi5cbiAgICovXG4gIHB1YmxpYyBjbG9zZSgpIHtcbiAgICB0aGlzLl9jbG9zZSgpXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY2xvc2VkXCIpXG4gIH1cbn1cbiIsImltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5pbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCBjbGFtcCwgcHJldmVudERlZmF1bHQgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0ICogYXMgSW5wdXRzIGZyb20gXCIuLi9JbnB1dHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuXG5jb25zdCBDTEFTU19IRUFERVIgPSBcIi5wcm9ncmVzcy1mdWxsX19iYXJcIlxuY29uc3QgQ0xBU1NfU0VDVElPTlMgPSBcIi5wcm9ncmVzcy1mdWxsX19zZWN0aW9ucyA+IHNwYW5cIlxuY29uc3QgQ0xBU1NfU0VDVElPTl9BQ1RJVkUgPSBcInNlY3Rpb24tLWFjdGl2ZVwiXG5cbmNvbnN0IENMQVNTX0lORElDQVRPUiA9IFwiaW5kaWNhdG9yXCJcbmNvbnN0IENMQVNTX0lORElDQVRPUl9DVVJSRU5UID0gXCJpbmRpY2F0b3ItLWN1cnJlbnRcIlxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SX0NPTVBMRVRFRCA9IFwiaW5kaWNhdG9yLS1jb21wbGV0ZWRcIlxuXG4vKipcbiAqIEZ1bGwgcHJvZ3Jlc3MgYmFyIGNvbXBvbmVudFxuICovXG5jbGFzcyBQcm9ncmVzc0Z1bGwgZXh0ZW5kcyBEb21FbGVtZW50IHtcbiAgcHJpdmF0ZSBfYnV0dG9uQ2xpY2tIYW5kbGVyITogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2tleWRvd25IYW5kbGVyITogKGU6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfaGVhZGVyRWxlbWVudCE6IERvbUVsZW1lbnQ8RWxlbWVudD5cbiAgcHJpdmF0ZSBfcGFnZXMhOiBOb2RlTGlzdE9mPEVsZW1lbnQ+XG5cbiAgcHJpdmF0ZSBfbWluVmFsdWUhOiBudW1iZXJcbiAgcHJpdmF0ZSBfdmFsdWUhOiBudW1iZXJcbiAgcHJpdmF0ZSBfdG90YWwhOiBudW1iZXJcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIFByb2dyZXNzRnVsbCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gLSBUaGUgcm9vdCBlbGVtZW50IG9mIHRoZSBQcm9ncmVzc0Z1bGwgY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGxvYWRlciBiYXIgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuX2J1dHRvbkNsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUJ1dHRvbkNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9rZXlkb3duSGFuZGxlciA9IHRoaXMuX2hhbmRsZUtleWRvd24uYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faGVhZGVyRWxlbWVudCA9IHRoaXMuZmluZChDTEFTU19IRUFERVIpIVxuXG4gICAgdGhpcy5fcGFnZXMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19TRUNUSU9OUylcblxuICAgIHRoaXMuX21pblZhbHVlID0gMVxuICAgIHRoaXMuX3ZhbHVlID0gMVxuICAgIHRoaXMuX3RvdGFsID0gdGhpcy5fcGFnZXMubGVuZ3RoXG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fcGFnZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAodGhpcy5fcGFnZXNbaW5kZXhdLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19TRUNUSU9OX0FDVElWRSkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBpbmRleCArIDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9hZGRJbmNpY2F0b3JzKClcbiAgICB0aGlzLl91cGRhdGUoLTEsIHRoaXMuX3ZhbHVlLCBmYWxzZSlcblxuICAgIC8vIEFwcGx5IHRoZSB0YWIgaW5kZXhcbiAgICBjb25zdCB0YWJJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIilcbiAgICBpZiAodGFiSW5kZXgpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCJcIilcbiAgICAgIHRoaXMuX2hlYWRlckVsZW1lbnQuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgdGFiSW5kZXgpXG4gICAgfVxuXG4gICAgdGhpcy5faGVhZGVyRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9idXR0b25DbGlja0hhbmRsZXIpXG4gICAgdGhpcy5faGVhZGVyRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9hZGRJbmNpY2F0b3JzKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLl9wYWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGluZGljYXRvckVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImJ1dHRvblwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SKVxuICAgICAgICAuc2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiLCBgJHtpICsgMX1gKVxuICAgICAgICAuc2V0SHRtbCgoaSArIDEpLnRvU3RyaW5nKCkpXG5cbiAgICAgIHRoaXMuX2hlYWRlckVsZW1lbnQucHJlcGVuZENoaWxkKGluZGljYXRvckVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF91cGRhdGUob2xkVmFsdWU6IG51bWJlciwgbmV3VmFsdWU6IG51bWJlciwgYW5pbWF0ZSA9IHRydWUpIHtcbiAgICBsZXQgaW5kaWNhdG9ycyA9IHRoaXMuX2hlYWRlckVsZW1lbnQuZWxlbWVudC5jaGlsZE5vZGVzXG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgaW5kaWNhdG9ycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGxldCBpbmRpY2F0b3JFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoaW5kaWNhdG9yc1tpbmRleF0gYXMgRWxlbWVudClcblxuICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgIGluZGljYXRvckVsZW1lbnRcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0NVUlJFTlQpXG4gICAgICAgICAgLmFkZENsYXNzKENMQVNTX0lORElDQVRPUl9DT01QTEVURUQpXG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCArIDEgPT09IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgIGluZGljYXRvckVsZW1lbnRcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0NPTVBMRVRFRClcbiAgICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0NVUlJFTlQpXG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCArIDEgPiB0aGlzLl92YWx1ZSkge1xuICAgICAgICBpbmRpY2F0b3JFbGVtZW50XG4gICAgICAgICAgLnJlbW92ZUNsYXNzKENMQVNTX0lORElDQVRPUl9DT01QTEVURUQpXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKENMQVNTX0lORElDQVRPUl9DVVJSRU5UKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIGxldCBkaXJlY3Rpb24gPSBNYXRoLnNpZ24ob2xkVmFsdWUgLSBuZXdWYWx1ZSlcblxuICAgICAgaWYgKG9sZFZhbHVlID4gMCAmJiBvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgbGV0IG9sZFNlY3Rpb24gPSBuZXcgRG9tRWxlbWVudCh0aGlzLl9wYWdlc1tvbGRWYWx1ZSAtIDFdKVxuXG4gICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgYW5pbWUoe1xuICAgICAgICAgICAgdGFyZ2V0czogb2xkU2VjdGlvbi5lbGVtZW50LFxuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIGxlZnQ6IDEwMCAqIGRpcmVjdGlvbixcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIixcbiAgICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgIG9sZFNlY3Rpb24ucmVtb3ZlQ2xhc3MoQ0xBU1NfU0VDVElPTl9BQ1RJVkUpXG4gICAgICAgICAgICAgIG9sZFNlY3Rpb24uc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZFNlY3Rpb24ucmVtb3ZlQ2xhc3MoQ0xBU1NfU0VDVElPTl9BQ1RJVkUpXG4gICAgICAgICAgb2xkU2VjdGlvbi5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBuZXdTZWN0aW9uID0gbmV3IERvbUVsZW1lbnQodGhpcy5fcGFnZXNbbmV3VmFsdWUgLSAxXSlcblxuICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgY29uc3QgZWwgPSBuZXdTZWN0aW9uLmVsZW1lbnQgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgZWwuc3R5bGUubGVmdCA9IGAkey0xMDAgKiBkaXJlY3Rpb259cHhgXG4gICAgICAgIGVsLnN0eWxlLm9wYWNpdHkgPSBcIjBcIlxuICAgICAgICBuZXdTZWN0aW9uLmFkZENsYXNzKENMQVNTX1NFQ1RJT05fQUNUSVZFKVxuICAgICAgICBhbmltZSh7XG4gICAgICAgICAgdGFyZ2V0czogbmV3U2VjdGlvbi5lbGVtZW50LFxuICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIGVhc2luZzogXCJlYXNlSW5PdXRRdWludFwiLFxuICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBuZXdTZWN0aW9uLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3U2VjdGlvbi5hZGRDbGFzcyhDTEFTU19TRUNUSU9OX0FDVElWRSlcbiAgICAgICAgbmV3U2VjdGlvbi5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQnV0dG9uQ2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgbGV0IGVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChldmVudC50YXJnZXQgYXMgRWxlbWVudClcbiAgICBpZiAoIWVsZW1lbnQuaGFzQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpXG4gICAgdGhpcy52YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUhKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBFdmVudCkge1xuICAgIGNvbnN0IGtleWJvYXJkRXZlbnQgPSBldmVudCBhcyBLZXlib2FyZEV2ZW50XG4gICAgbGV0IGtleWNvZGUgPSBrZXlib2FyZEV2ZW50LndoaWNoIHx8IGtleWJvYXJkRXZlbnQua2V5Q29kZVxuXG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfUklHSFQpIHtcbiAgICAgIHRoaXMudmFsdWUrK1xuXG4gICAgICBwcmV2ZW50RGVmYXVsdChrZXlib2FyZEV2ZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfTEVGVCkge1xuICAgICAgdGhpcy52YWx1ZS0tXG5cbiAgICAgIHByZXZlbnREZWZhdWx0KGtleWJvYXJkRXZlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoa2V5Y29kZSA+PSBJbnB1dHMuS0VZX05SXzAgJiYga2V5Y29kZSA8PSBJbnB1dHMuS0VZX05SXzkpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBrZXljb2RlIC0gSW5wdXRzLktFWV9OUl8wXG4gICAgICBwcmV2ZW50RGVmYXVsdChrZXlib2FyZEV2ZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MgdmFsdWUgaW4gdGhlIHJhbmdlIG9mIDEuLnRvdGFsLlxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAtIFRoZSBwcm9ncmVzcyBpbiB0aGUgcmFuZ2Ugb2YgMS4udG90YWwuXG4gICAqL1xuICBzZXQgdmFsdWUodmFsOiBudW1iZXIpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX3ZhbHVlXG5cbiAgICB0aGlzLl92YWx1ZSA9IGNsYW1wKHZhbCwgdGhpcy5fbWluVmFsdWUsIHRoaXMuX3RvdGFsKVxuICAgIHRoaXMuX3VwZGF0ZShvbGRWYWx1ZSwgdGhpcy5fdmFsdWUsIHRydWUpXG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VkXCIpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdG90YWwgcHJvZ3Jlc3MgdmFsdWUuXG4gICAqL1xuICBnZXQgdG90YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIucHJvZ3Jlc3MtZnVsbFwiLCAoZSkgPT4ge1xuICAgIG5ldyBQcm9ncmVzc0Z1bGwoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJvZ3Jlc3NGdWxsXG4iLCJpbXBvcnQgYW5pbWUgZnJvbSBcImFuaW1lanNcIlxuaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgY2xhbXAgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuXG5jb25zdCBDTEFTU19CQVIgPSBcIi5wcm9ncmVzcy1saWdodF9fYmFyXCJcbmNvbnN0IENMQVNTX1BST0dSRVNTID0gXCIuYmFyX19wcm9ncmVzc1wiXG5jb25zdCBDTEFTU19QUk9HUkVTU19DT01QTEVURUQgPSBcImJhcl9fcHJvZ3Jlc3MtLWNvbXBsZXRlXCJcbmNvbnN0IENMQVNTX1RJQ0sgPSBcImJhcl9fdGlja1wiXG5jb25zdCBDTEFTU19QQUdFX0NVUlJFTlQgPSBcIi5kZXRhaWxfX2N1cnJlbnRwYWdlXCJcbmNvbnN0IENMQVNTX1BBR0VfVE9UQUwgPSBcIi5kZXRhaWxfX3RvdGFscGFnZVwiXG5cbmNvbnN0IENMQVNTX0RJU0FCTEVEID0gXCJhcnJvdy0tZGlzYWJsZWRcIlxuY29uc3QgQ0xBU1NfQlVUVE9OX0xFRlQgPSBcIi5hcnJvdy0tbGVmdFwiXG5jb25zdCBDTEFTU19CVVRUT05fUklHSFQgPSBcIi5hcnJvdy0tcmlnaHRcIlxuXG4vKipcbiAqIExpZ2h0IHByb2dyZXNzIGJhciBjb21wb25lbnRcbiAqL1xuY2xhc3MgUHJvZ3Jlc3NMaWdodCBleHRlbmRzIERvbUVsZW1lbnQge1xuICBwcml2YXRlIF9idXR0b25DbGlja0hhbmRsZXIhOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2FuaW1hdGlvbkNvbXBsZXRlZEhhbmRsZXIhOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfYmFyRWxlbWVudCE6IERvbUVsZW1lbnQ8RWxlbWVudD5cbiAgcHJpdmF0ZSBfcHJvZ3Jlc3NFbGVtZW50ITogRG9tRWxlbWVudDxFbGVtZW50PlxuICBwcml2YXRlIF9wYWdlQ3VycmVudEVsZW1lbnQhOiBEb21FbGVtZW50PEVsZW1lbnQ+XG4gIHByaXZhdGUgX3BhZ2VUb3RhbEVsZW1lbnQhOiBEb21FbGVtZW50PEVsZW1lbnQ+XG4gIHByaXZhdGUgX2J1dHRvbkxlZnQhOiBEb21FbGVtZW50PEVsZW1lbnQ+XG4gIHByaXZhdGUgX2J1dHRvblJpZ2h0ITogRG9tRWxlbWVudDxFbGVtZW50PlxuXG4gIHByaXZhdGUgX21pblZhbHVlITogbnVtYmVyXG4gIHByaXZhdGUgX3RvdGFsITogbnVtYmVyXG4gIHByaXZhdGUgX3ZhbHVlITogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfaXRlbVdpZHRoPzogbnVtYmVyXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBQcm9ncmVzc0xpZ2h0IGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtEb21FbGVtZW50fSAtIFRoZSByb290IGVsZW1lbnQgb2YgdGhlIFByb2dyZXNzTGlnaHQgY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGxvYWRlciBiYXIgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuXG4gICAgdGhpcy5fYnV0dG9uQ2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlQnV0dG9uQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2FuaW1hdGlvbkNvbXBsZXRlZEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVBbmltYXRpb25Db21wbGV0ZWQuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5fYmFyRWxlbWVudCA9IHRoaXMuZmluZChDTEFTU19CQVIpIVxuICAgIHRoaXMuX3Byb2dyZXNzRWxlbWVudCA9IHRoaXMuZmluZChDTEFTU19QUk9HUkVTUykhXG4gICAgdGhpcy5fcGFnZUN1cnJlbnRFbGVtZW50ID0gdGhpcy5maW5kKENMQVNTX1BBR0VfQ1VSUkVOVCkhXG4gICAgdGhpcy5fcGFnZVRvdGFsRWxlbWVudCA9IHRoaXMuZmluZChDTEFTU19QQUdFX1RPVEFMKSFcbiAgICB0aGlzLl9idXR0b25MZWZ0ID0gdGhpcy5maW5kKENMQVNTX0JVVFRPTl9MRUZUKSFcbiAgICB0aGlzLl9idXR0b25SaWdodCA9IHRoaXMuZmluZChDTEFTU19CVVRUT05fUklHSFQpIVxuXG4gICAgdGhpcy5fbWluVmFsdWUgPSAxXG4gICAgdGhpcy5fdG90YWwgPSBNYXRoLm1heChwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZShcInRvdGFsXCIpIHx8IFwiMTAwXCIsIDEwKSwgdGhpcy5fbWluVmFsdWUpXG4gICAgdGhpcy5fdmFsdWUgPSBjbGFtcChwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIHx8IFwiMVwiLCAxMCksIHRoaXMuX21pblZhbHVlLCB0aGlzLl90b3RhbClcblxuICAgIHRoaXMuX2xheW91dCgpXG5cbiAgICB0aGlzLl9hZGRUaWNrcygpXG4gICAgdGhpcy5fdXBkYXRlKGZhbHNlKVxuXG4gICAgdGhpcy5lbmFibGUoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9hZGRUaWNrcygpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX3RvdGFsOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5faXRlbVdpZHRoISAqIGlcblxuICAgICAgbGV0IHRpY2tFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX1RJQ0spXG4gICAgICAgIC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgbGVmdDogJHtwb3NpdGlvbn0lYClcblxuICAgICAgdGhpcy5fYmFyRWxlbWVudC5wcmVwZW5kQ2hpbGQodGlja0VsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF91cGRhdGUoYW5pbWF0ZSA9IHRydWUpIHtcbiAgICB0aGlzLl9wYWdlQ3VycmVudEVsZW1lbnQuc2V0SHRtbCh0aGlzLl92YWx1ZS50b1N0cmluZygpKVxuICAgIHRoaXMuX3BhZ2VUb3RhbEVsZW1lbnQuc2V0SHRtbCh0aGlzLl90b3RhbC50b1N0cmluZygpKVxuXG4gICAgbGV0IHBvc2l0aW9uID0gdGhpcy5fdmFsdWUgKiB0aGlzLl9pdGVtV2lkdGghXG5cbiAgICAvLyBBZGQgYWRkaXRpb25hbCB3aWR0aCB0byB0aGUgbGFzdCBlbGVtZW50IHRvIG1ha2Ugc3VyZVxuICAgIC8vIHRoZSByb3VuZGVkIGJvcmRlciBvbiB0aGUgbGVmdCBpcyBmaWxsZWQgYXMgd2VsbFxuICAgIGlmICh0aGlzLl92YWx1ZSA9PT0gdGhpcy5fdG90YWwpIHtcbiAgICAgIHBvc2l0aW9uICs9IDVcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdmFsdWUgPj0gdGhpcy5fdG90YWwpIHtcbiAgICAgIHRoaXMuX2J1dHRvblJpZ2h0LmFkZENsYXNzKENMQVNTX0RJU0FCTEVEKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9idXR0b25SaWdodC5yZW1vdmVDbGFzcyhDTEFTU19ESVNBQkxFRClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdmFsdWUgPD0gdGhpcy5fbWluVmFsdWUpIHtcbiAgICAgIHRoaXMuX2J1dHRvbkxlZnQuYWRkQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2J1dHRvbkxlZnQucmVtb3ZlQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG4gICAgfVxuXG4gICAgY29uc3QgZWwgPSB0aGlzLl9wcm9ncmVzc0VsZW1lbnQuZWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICAgIGlmIChhbmltYXRlKSB7XG4gICAgICBhbmltZSh7XG4gICAgICAgIHRhcmdldHM6IHRoaXMuX3Byb2dyZXNzRWxlbWVudC5lbGVtZW50LFxuICAgICAgICBkdXJhdGlvbjogMjAwLFxuICAgICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIixcbiAgICAgICAgd2lkdGg6IHRoaXMuX2JhckVsZW1lbnQuZWxlbWVudC5jbGllbnRXaWR0aCAqIHBvc2l0aW9uIC8gMTAwLFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gYCR7cG9zaXRpb259JWBcbiAgICAgICAgICB0aGlzLl9hbmltYXRpb25Db21wbGV0ZWRIYW5kbGVyKDxFdmVudD57fSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUud2lkdGggPSBgJHtwb3NpdGlvbn0lYFxuICAgICAgdGhpcy5fYW5pbWF0aW9uQ29tcGxldGVkSGFuZGxlcig8RXZlbnQ+e30pXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9sYXlvdXQoKSB7XG4gICAgdGhpcy5faXRlbVdpZHRoID0gTWF0aC5mbG9vcigxMDAgLyB0aGlzLl90b3RhbClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQnV0dG9uQ2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5fYnV0dG9uTGVmdC5lbGVtZW50KSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5fdmFsdWUgLSAxXG4gICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuX2J1dHRvblJpZ2h0LmVsZW1lbnQpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl92YWx1ZSArIDFcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUFuaW1hdGlvbkNvbXBsZXRlZCgpIHtcbiAgICBpZiAodGhpcy5fdmFsdWUgPT09IHRoaXMuX3RvdGFsKSB7XG4gICAgICB0aGlzLl9wcm9ncmVzc0VsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfUFJPR1JFU1NfQ09NUExFVEVEKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wcm9ncmVzc0VsZW1lbnQucmVtb3ZlQ2xhc3MoQ0xBU1NfUFJPR1JFU1NfQ09NUExFVEVEKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHByb2dyZXNzIHZhbHVlIGluIHRoZSByYW5nZSBvZiAxLi50b3RhbC5cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHByb2dyZXNzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gLSBUaGUgcHJvZ3Jlc3MgaW4gdGhlIHJhbmdlIG9mIDEuLnRvdGFsLlxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbCkge1xuICAgIHRoaXMuX3ZhbHVlID0gY2xhbXAodmFsLCB0aGlzLl9taW5WYWx1ZSwgdGhpcy5fdG90YWwpXG4gICAgdGhpcy5fdXBkYXRlKHRydWUpXG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VkXCIpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdG90YWwgcHJvZ3Jlc3MgdmFsdWUuXG4gICAqL1xuICBnZXQgdG90YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdG90YWwgcHJvZ3Jlc3MgdmFsdWUgYW5kIHVwZGF0ZXMgdGhlIFVJIGFjY29yZGluZ2x5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gLSBUaGUgdG90YWwgcHJvZ3Jlc3MgcG9zaXRpdmUgaW50ZWdlciB2YWx1ZS5cbiAgICovXG4gIHNldCB0b3RhbCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl90b3RhbCA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3RvdGFsID0gTWF0aC5tYXgodmFsdWUsIHRoaXMuX21pblZhbHVlKVxuICAgIHRoaXMuX3ZhbHVlID0gY2xhbXAodGhpcy5fdmFsdWUsIHRoaXMuX21pblZhbHVlLCB0aGlzLl90b3RhbClcblxuICAgIC8vIENsZWFyIHRoZSB0aWNrc1xuICAgIGZvciAobGV0IHRpY2sgb2YgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NMQVNTX1RJQ0t9YCkpIHtcbiAgICAgIHRoaXMuX2JhckVsZW1lbnQuZWxlbWVudC5yZW1vdmVDaGlsZCh0aWNrKVxuICAgIH1cblxuICAgIHRoaXMuX2xheW91dCgpXG4gICAgdGhpcy5fYWRkVGlja3MoKVxuXG4gICAgdGhpcy5fdXBkYXRlKGZhbHNlKVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwidG90YWxjaGFuZ2VkXCIpXG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgcHVibGljIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9idXR0b25MZWZ0LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2J1dHRvbkNsaWNrSGFuZGxlcilcbiAgICB0aGlzLl9idXR0b25SaWdodC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9idXR0b25DbGlja0hhbmRsZXIpXG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIHB1YmxpYyBkaXNhYmxlKCkge1xuICAgIHRoaXMuX2J1dHRvbkxlZnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fYnV0dG9uQ2xpY2tIYW5kbGVyKVxuICAgIHRoaXMuX2J1dHRvblJpZ2h0LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2J1dHRvbkNsaWNrSGFuZGxlcilcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5wcm9ncmVzcy1saWdodFwiLCAoZSkgPT4ge1xuICAgIG5ldyBQcm9ncmVzc0xpZ2h0KGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb2dyZXNzTGlnaHRcbiIsImltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL1V0aWxzXCJcblxuaW1wb3J0IExvYWRlckJhciwgeyBpbml0IGFzIGluaXRMb2FkZXJCYXIgfSBmcm9tIFwiLi9sb2FkZXIvTG9hZGVyQmFyXCJcblxuLyogRm9ybSBDb21wb25lbnRzICovXG5pbXBvcnQgSW5wdXRGaWVsZCwgeyBpbml0IGFzIGluaXRJbnB1dEZpZWxkIH0gZnJvbSBcIi4vZm9ybS9JbnB1dEZpZWxkXCJcbmltcG9ydCBUZXh0YXJlYSwgeyBpbml0IGFzIGluaXRUZXh0YXJlYSB9IGZyb20gXCIuL2Zvcm0vVGV4dGFyZWFcIlxuaW1wb3J0IFNlbGVjdCwgeyBpbml0IGFzIGluaXRTZWxlY3QgfSBmcm9tIFwiLi9mb3JtL1NlbGVjdFwiXG5pbXBvcnQgUmFuZ2UsIHsgaW5pdCBhcyBpbml0UmFuZ2UgfSBmcm9tIFwiLi9mb3JtL1JhbmdlXCJcbmltcG9ydCBBdXRvY29tcGxldGUsIHsgaW5pdCBhcyBpbml0QXV0b2NvbXBsZXRlIH0gZnJvbSBcIi4vZm9ybS9BdXRvY29tcGxldGVcIlxuXG5pbXBvcnQgUHJvZ3Jlc3NMaWdodCwgeyBpbml0IGFzIGluaXRQcm9ncmVzc0xpZ2h0IH0gZnJvbSBcIi4vcHJvZ3Jlc3MvUHJvZ3Jlc3NMaWdodFwiXG5pbXBvcnQgUHJvZ3Jlc3NGdWxsLCB7IGluaXQgYXMgaW5pdFByb2dyZXNzRnVsbCB9IGZyb20gXCIuL3Byb2dyZXNzL1Byb2dyZXNzRnVsbFwiXG5cbmltcG9ydCBNb2RhbCwgeyBpbml0IGFzIGluaXRNb2RhbCB9IGZyb20gXCIuL21vZGFsL01vZGFsXCJcbmltcG9ydCBUb29sYmFyIGZyb20gXCIuL3Rvb2xiYXIvVG9vbGJhclwiXG5cbmltcG9ydCAqIGFzIE5vdGlmaWNhdGlvbiBmcm9tIFwiLi9ub3RpZmljYXRpb24vTm90aWZpY2F0aW9uXCJcblxuaW1wb3J0IENvbGxhcHNlLCB7IGluaXQgYXMgaW5pdENvbGxhcHNlIH0gZnJvbSBcIi4vY29sbGFwc2UvQ29sbGFwc2VcIlxuaW1wb3J0IEFjY29yZGlvbiwgeyBpbml0IGFzIGluaXRBY2NvcmRpb24gfSBmcm9tIFwiLi9hY2NvcmRpb24vQWNjb3JkaW9uXCJcbmltcG9ydCBNZW51Rmx5b3V0LCB7IGluaXQgYXMgaW5pdE1lbnVGbHlvdXQgfSBmcm9tIFwiLi9tZW51L01lbnVGbHlvdXRcIlxuXG5pbXBvcnQgTmF2aWdhdGlvbiwgeyBpbml0IGFzIGluaXROYXZpZ2F0aW9uIH0gZnJvbSBcIi4vbmF2aWdhdGlvbi9OYXZpZ2F0aW9uXCJcbmltcG9ydCBOYXZpZ2F0aW9uU2lkZSwgeyBpbml0IGFzIGluaXROYXZpZ2F0aW9uU2lkZSB9IGZyb20gXCIuL25hdmlnYXRpb24vTmF2aWdhdGlvblNpZGVcIlxuaW1wb3J0IFNlYXJjaElucHV0LCB7IGluaXQgYXMgaW5pdFNlYXJjaElucHV0IH0gZnJvbSBcIi4vc2VhcmNoL1NlYXJjaElucHV0XCJcbmltcG9ydCBFbXB0eVN0YXRlLCB7IGluaXQgYXMgaW5pdEVtcHR5U3RhdGUgfSBmcm9tIFwiLi9lbXB0eS1zdGF0ZXMvRW1wdHlTdGF0ZVwiXG5pbXBvcnQgQ2Fyb3VzZWwsIHsgaW5pdCBhcyBpbml0Q2Fyb3VzZWwgfSBmcm9tIFwiLi9jYXJvdXNlbC9DYXJvdXNlbFwiXG5cbmltcG9ydCBUYWJsZSwgeyBpbml0IGFzIGluaXRUYWJsZSB9IGZyb20gXCIuL3RhYmxlL1RhYmxlXCJcblxuaW1wb3J0IFBpZUNoYXJ0LCB7IGluaXQgYXMgaW5pdFBpZUNoYXJ0IH0gZnJvbSBcIi4vY2hhcnRzL1BpZUNoYXJ0XCJcbmltcG9ydCBCYXJDaGFydEhvcml6b250YWwsIHsgaW5pdCBhcyBpbml0QmFyQ2hhcnRIb3Jpem9udGFsIH0gZnJvbSBcIi4vY2hhcnRzL0JhckNoYXJ0SG9yaXpvbnRhbFwiXG5pbXBvcnQgQmFyQ2hhcnRWZXJ0aWNhbCwgeyBpbml0IGFzIGluaXRCYXJDaGFydFZlcnRpY2FsIH0gZnJvbSBcIi4vY2hhcnRzL0JhckNoYXJ0VmVydGljYWxcIlxuXG5leHBvcnQge1xuICB1dGlscyxcbiAgTG9hZGVyQmFyLCBpbml0TG9hZGVyQmFyLFxuICBJbnB1dEZpZWxkLCBpbml0SW5wdXRGaWVsZCxcbiAgVGV4dGFyZWEsIGluaXRUZXh0YXJlYSxcbiAgU2VsZWN0LCBpbml0U2VsZWN0LFxuICBSYW5nZSwgaW5pdFJhbmdlLFxuICBBdXRvY29tcGxldGUsIGluaXRBdXRvY29tcGxldGUsXG4gIFByb2dyZXNzTGlnaHQsIGluaXRQcm9ncmVzc0xpZ2h0LFxuICBQcm9ncmVzc0Z1bGwsIGluaXRQcm9ncmVzc0Z1bGwsXG4gIE1vZGFsLCBpbml0TW9kYWwsXG4gIFRvb2xiYXIsXG4gIE5vdGlmaWNhdGlvbixcbiAgQ29sbGFwc2UsIGluaXRDb2xsYXBzZSxcbiAgQWNjb3JkaW9uLCBpbml0QWNjb3JkaW9uLFxuICBNZW51Rmx5b3V0LCBpbml0TWVudUZseW91dCxcbiAgTmF2aWdhdGlvbiwgaW5pdE5hdmlnYXRpb24sXG4gIE5hdmlnYXRpb25TaWRlLCBpbml0TmF2aWdhdGlvblNpZGUsXG4gIFNlYXJjaElucHV0LCBpbml0U2VhcmNoSW5wdXQsXG4gIEVtcHR5U3RhdGUsIGluaXRFbXB0eVN0YXRlLFxuICBDYXJvdXNlbCwgaW5pdENhcm91c2VsLFxuICBUYWJsZSwgaW5pdFRhYmxlLFxuICBQaWVDaGFydCwgaW5pdFBpZUNoYXJ0LFxuICBCYXJDaGFydEhvcml6b250YWwsIGluaXRCYXJDaGFydEhvcml6b250YWwsXG4gIEJhckNoYXJ0VmVydGljYWwsIGluaXRCYXJDaGFydFZlcnRpY2FsXG59XG4iLCJpbXBvcnQgYW5pbWUsIHsgQW5pbWVUaW1lbGluZUluc3RhbmNlIH0gZnJvbSBcImFuaW1lanNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0ICogYXMgSW5wdXRzIGZyb20gXCIuLi9JbnB1dHNcIlxuaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgcHJldmVudERlZmF1bHQsIGludGVybmV0RXhwbG9yZXJPckVkZ2VWZXJzaW9uIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCB7IGFkZENsYXNzLCByZW1vdmVDbGFzcywgZ2V0QXR0cmlidXRlUmVmZXJlbmNlLCBwYXJlbnRXaXRoQ2xhc3MgfSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcblxuY29uc3QgUVVFUllfU0VBUkNIX0lOUFVUID0gXCJpbnB1dC5zZWFyY2hfX2ZpZWxkXCJcbmNvbnN0IFFVRVJZX0JUTl9DTE9TRSA9IFwiLnNlYXJjaF9faWNvbi1jbG9zZVwiXG5cbmNvbnN0IFFVRVJZX0xJVkVfU1VHRVNUSU9OUyA9IFwiLmpzLXN1Z2dlc3Rpb25zXCJcbmNvbnN0IFFVRVJZX0xJVkVfRk9PVEVSID0gXCIuanMtZm9vdGVyXCJcblxuY29uc3QgQ0xBU1NfQUNUSVZFID0gXCJpcy1hY3RpdmVcIlxuY29uc3QgQ0xBU1NfT1BFTiA9IFwiaXMtb3BlblwiXG5cbmNvbnN0IENMQVNTX1NFQVJDSCA9IFwic2VhcmNoXCJcblxuY29uc3QgQU5JTUFUSU9OX1NVR0dFU1RJT05TX0RVUkFUSU9OID0gMzAwXG5jb25zdCBBTklNQVRJT05fRk9PVEVSX0RVUkFUSU9OID0gMTAwXG5jb25zdCBBTklNQVRJT05fRk9PVEVSX0RFTEFZID0gQU5JTUFUSU9OX1NVR0dFU1RJT05TX0RVUkFUSU9OIC0gQU5JTUFUSU9OX0ZPT1RFUl9EVVJBVElPTlxuXG4vKipcbiAqIFRoZSBzZWFyY2ggaW5wdXQgY29tcG9uZW50IGRlZmluaXRpb24uXG4gKi9cbmNsYXNzIFNlYXJjaElucHV0IGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgX2lucHV0OiBIVE1MSW5wdXRFbGVtZW50XG4gIHByaXZhdGUgX2Zvcm06IEhUTUxGb3JtRWxlbWVudFxuICBwcml2YXRlIF9idG5DbG9zZTogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfbGl2ZVN1Z2dlc3Rpb25zPzogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfbGl2ZUZvb3Rlcj86IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX2xpdmVDb250YWluZXI/OiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX2ZvY3VzSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2JsdXJIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfY2xvc2VIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfd2luZG93Q2xpY2tIYW5kbGVyOiAoZTogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfa2V5ZG93bkhhbmRsZXI6IChlOiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3Jlc2l6ZUhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX2lzT3BlbjogYm9vbGVhbiA9IGZhbHNlXG4gIHByaXZhdGUgYW5pbWF0aW9uITogQW5pbWVUaW1lbGluZUluc3RhbmNlXG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5faW5wdXQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9TRUFSQ0hfSU5QVVQpIGFzIEhUTUxJbnB1dEVsZW1lbnRcbiAgICB0aGlzLl9mb3JtID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJmb3JtXCIpIVxuICAgIHRoaXMuX2J0bkNsb3NlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfQlROX0NMT1NFKSBhcyBIVE1MRWxlbWVudFxuXG4gICAgbGV0IGxpdmVTZWFyY2ggPSBnZXRBdHRyaWJ1dGVSZWZlcmVuY2UodGhpcy5lbGVtZW50LCBcImRhdGEtbGl2ZVwiKVxuICAgIGlmIChsaXZlU2VhcmNoKSB7XG4gICAgICB0aGlzLl9saXZlU3VnZ2VzdGlvbnMgPSBsaXZlU2VhcmNoLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTElWRV9TVUdFU1RJT05TKSBhcyBIVE1MRWxlbWVudCB8fCB1bmRlZmluZWRcbiAgICAgIHRoaXMuX2xpdmVGb290ZXIgPSBsaXZlU2VhcmNoLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTElWRV9GT09URVIpIGFzIEhUTUxFbGVtZW50IHx8IHVuZGVmaW5lZFxuXG4gICAgICBpZiAodGhpcy5fbGl2ZVN1Z2dlc3Rpb25zKSB7XG4gICAgICAgIHRoaXMuX2xpdmVDb250YWluZXIgPSB0aGlzLl9saXZlU3VnZ2VzdGlvbnMucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudCB8fCB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9mb2N1c0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVJbnB1dEZvY3VzLmJpbmQodGhpcylcbiAgICB0aGlzLl9ibHVySGFuZGxlciA9IHRoaXMuX2hhbmRsZUlucHV0Qmx1ci5iaW5kKHRoaXMpXG4gICAgdGhpcy5fY2xvc2VIYW5kbGVyID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlV2luZG93Q2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2tleWRvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcmVzaXplSGFuZGxlciA9IHRoaXMuX2hhbmRsZVJlc2l6ZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5fZm9jdXNIYW5kbGVyKVxuICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKVxuXG4gICAgaWYgKGludGVybmV0RXhwbG9yZXJPckVkZ2VWZXJzaW9uKCkgPiAwKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgSUUgYnJvd3NlcnMgd2hlcmUgYSBmb2N1c2VkXG4gICAgICAvLyBpbnB1dCdzIGN1cnNvciBibGVlZHMgdHJvdWdoIGV2ZW4gaWYgaGlkZGVuXG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2J0bkNsb3NlKSB7XG4gICAgICB0aGlzLl9idG5DbG9zZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xvc2VIYW5kbGVyKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlSW5wdXRGb2N1cygpIHtcbiAgICB0aGlzLmFkZENsYXNzKENMQVNTX0FDVElWRSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlSW5wdXRCbHVyKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoQ0xBU1NfQUNUSVZFKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVXaW5kb3dDbGljayhldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpIHtcbiAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50XG5cbiAgICBpZiAoIXBhcmVudFdpdGhDbGFzcyh0YXJnZXQsIENMQVNTX1NFQVJDSCkpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGxldCBrZXljb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZVxuXG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfRVNDQVBFKSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlUmVzaXplKCkge1xuICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudClcbiAgICBpZiAoc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgIHRoaXMuX2lucHV0LmJsdXIoKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfcmVzZXRNYWluVGltZWxpbmUoKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbi5wYXVzZSgpXG4gICAgfVxuICAgIGFuaW1lLnJlbW92ZSh0aGlzLl9saXZlU3VnZ2VzdGlvbnMhKVxuICAgIGFuaW1lLnJlbW92ZSh0aGlzLl9saXZlRm9vdGVyISlcblxuICAgIHRoaXMuYW5pbWF0aW9uID0gYW5pbWUudGltZWxpbmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNlYXJjaCBpbnB1dCB0ZXh0IGNvbnRlbnQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBpbnB1dCB0ZXh0LlxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dC52YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zL2FjdGl2YXRlcyB0aGUgc2VhcmNoIGlucHV0LlxuICAgKi9cbiAgcHVibGljIG9wZW4oKSB7XG4gICAgdGhpcy5hZGRDbGFzcyhDTEFTU19PUEVOKVxuICAgIHRoaXMuX2lucHV0LmZvY3VzKClcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgICB9LCA1MClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMvZGVhY3RpdmF0ZXMgdGhlIHNlYXJjaCBpbnB1dC5cbiAgICovXG4gIHB1YmxpYyBjbG9zZSgpIHtcbiAgICB0aGlzLl9mb3JtLnJlc2V0KClcbiAgICB0aGlzLnJlbW92ZUNsYXNzKENMQVNTX09QRU4pXG5cbiAgICB0aGlzLmNsb3NlTGl2ZVNlYXJjaCgpXG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpXG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIGxpdmUgc2VhcmNoIHN1Z2dlc3Rpb25zLlxuICAgKi9cbiAgcHVibGljIG9wZW5MaXZlU2VhcmNoKCkge1xuICAgIGlmICghdGhpcy5fbGl2ZVN1Z2dlc3Rpb25zIHx8IHRoaXMuX2lzT3Blbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5faXNPcGVuID0gdHJ1ZVxuICAgIGFkZENsYXNzKHRoaXMuX2xpdmVDb250YWluZXIhLCBDTEFTU19PUEVOKVxuXG4gICAgdGhpcy5fcmVzZXRNYWluVGltZWxpbmUoKVxuXG4gICAgdGhpcy5fbGl2ZVN1Z2dlc3Rpb25zLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCJcblxuICAgIHRoaXMuYW5pbWF0aW9uLmFkZCh7XG4gICAgICB0YXJnZXRzOiB0aGlzLl9saXZlU3VnZ2VzdGlvbnMsXG4gICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX1NVR0dFU1RJT05TX0RVUkFUSU9OLFxuICAgICAgaGVpZ2h0OiB0aGlzLl9saXZlU3VnZ2VzdGlvbnMuc2Nyb2xsSGVpZ2h0ICsgXCJweFwiLFxuICAgICAgZWFzaW5nOiBcImN1YmljQmV6aWVyKDAuNTUwLCAwLjA4NSwgMC4zMjAsIDEpXCIsXG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBkb21FbCA9IG5ldyBEb21FbGVtZW50KHRoaXMuX2xpdmVTdWdnZXN0aW9ucyEpXG4gICAgICAgIGRvbUVsLmFkZENsYXNzKENMQVNTX09QRU4pXG4gICAgICAgIGRvbUVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmICh0aGlzLl9saXZlRm9vdGVyKSB7XG4gICAgICB0aGlzLl9saXZlRm9vdGVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCJcblxuICAgICAgdGhpcy5hbmltYXRpb24uYWRkKHtcbiAgICAgICAgdGFyZ2V0czogdGhpcy5fbGl2ZUZvb3RlcixcbiAgICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9GT09URVJfRFVSQVRJT04sXG4gICAgICAgIGhlaWdodDogdGhpcy5fbGl2ZUZvb3Rlci5zY3JvbGxIZWlnaHQgKyBcInB4XCIsXG4gICAgICAgIGVhc2luZzogXCJjdWJpY0JlemllcigwLjU1MCwgMC4wODUsIDAuMzIwLCAxKVwiLFxuICAgICAgICBvZmZzZXQ6IEFOSU1BVElPTl9GT09URVJfREVMQVksXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZG9tRWwgPSBuZXcgRG9tRWxlbWVudCh0aGlzLl9saXZlRm9vdGVyISlcbiAgICAgICAgICBkb21FbC5hZGRDbGFzcyhDTEFTU19PUEVOKVxuICAgICAgICAgIGRvbUVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbGl2ZSBzZWFyY2ggc3VnZ2VzdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgY2xvc2VMaXZlU2VhcmNoKCkge1xuICAgIGlmICghdGhpcy5fbGl2ZVN1Z2dlc3Rpb25zIHx8ICF0aGlzLmlzT3Blbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5faXNPcGVuID0gZmFsc2VcbiAgICB0aGlzLl9yZXNldE1haW5UaW1lbGluZSgpXG5cbiAgICB0aGlzLl9saXZlU3VnZ2VzdGlvbnMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuXG4gICAgdGhpcy5hbmltYXRpb24uYWRkKHtcbiAgICAgIHRhcmdldHM6IHRoaXMuX2xpdmVTdWdnZXN0aW9ucyxcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fU1VHR0VTVElPTlNfRFVSQVRJT04sXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBlYXNpbmc6IFwiY3ViaWNCZXppZXIoMC41NTAsIDAuMDg1LCAwLjMyMCwgMSlcIixcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvbUVsID0gbmV3IERvbUVsZW1lbnQodGhpcy5fbGl2ZVN1Z2dlc3Rpb25zISlcbiAgICAgICAgZG9tRWwucmVtb3ZlQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICAgICAgZG9tRWwuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5fbGl2ZUNvbnRhaW5lciEsIENMQVNTX09QRU4pXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmICh0aGlzLl9saXZlRm9vdGVyKSB7XG4gICAgICB0aGlzLl9saXZlRm9vdGVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCJcblxuICAgICAgdGhpcy5hbmltYXRpb24uYWRkKHtcbiAgICAgICAgdGFyZ2V0czogdGhpcy5fbGl2ZUZvb3RlcixcbiAgICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9GT09URVJfRFVSQVRJT04sXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgZWFzaW5nOiBcImN1YmljQmV6aWVyKDAuNTUwLCAwLjA4NSwgMC4zMjAsIDEpXCIsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBkb21FbCA9IG5ldyBEb21FbGVtZW50KHRoaXMuX2xpdmVGb290ZXIhKVxuICAgICAgICAgIGRvbUVsLnJlbW92ZUNsYXNzKENMQVNTX09QRU4pXG4gICAgICAgICAgZG9tRWwuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudCBhbmQgY2xlYXJzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuXG4gICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzSGFuZGxlcilcbiAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9ibHVySGFuZGxlcilcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuXG4gICAgaWYgKHRoaXMuX2J0bkNsb3NlKSB7XG4gICAgICB0aGlzLl9idG5DbG9zZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xvc2VIYW5kbGVyKVxuICAgIH1cblxuICAgICh0aGlzIGFzIGFueSkuX2lucHV0ID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9mb3JtID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9idG5DbG9zZSA9IG51bGw7XG5cbiAgICAodGhpcyBhcyBhbnkpLl9mb2N1c0hhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX2JsdXJIYW5kbGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9jbG9zZUhhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX3dpbmRvd0NsaWNrSGFuZGxlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fa2V5ZG93bkhhbmRsZXIgPSBudWxsO1xuXG4gICAgKHRoaXMgYXMgYW55KS5fbGl2ZVN1Z2dlc3Rpb25zID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9saXZlRm9vdGVyID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIFNlYXJjaElucHV0IGlzIG9wZW4vdmlzaWJsZS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gLSBUcnVlIGlmIG9wZW47IG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIHB1YmxpYyBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQ2xhc3MoQ0xBU1NfT1BFTilcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZTxIVE1MRWxlbWVudD4oXCIuc2VhcmNoLnNlYXJjaF9faW5wdXRcIiwgKGUpID0+IHtcbiAgICBuZXcgU2VhcmNoSW5wdXQoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VhcmNoSW5wdXRcbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0ICogYXMgRG9tIGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBRVUVSWV9IRUFERVIgPSBcInRoZWFkIHRoXCJcblxuY29uc3QgQ0xBU1NfU09SVEVEX0FTQ0VORElORyA9IFwianMtYXNjZW5kaW5nXCJcbmNvbnN0IENMQVNTX1NPUlRFRF9ERVNDRU5ESU5HID0gXCJqcy1kZXNjZW5kaW5nXCJcbmNvbnN0IENMQVNTX0FSUk9XID0gXCJhcnJvdy1pY29uXCJcblxuZXhwb3J0IGludGVyZmFjZSBDb21wYXJlcjxUID0gYW55PiB7XG4gIChpdGVtMTogVCwgaXRlbTI6IFQpOiBudW1iZXJcbn1cblxuLyoqXG4gKiBUaGUgVGFibGUgY29tcG9uZW50LiBBZGRzIGFkZGl0aW9uYWwgY2FwYWJpbGl0aWVzIHRvIHN0YW5kYXJkIEhUTUwgNSB0YWJsZXMuXG4gKi9cbmNsYXNzIFRhYmxlIGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgX2hlYWRlckNsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2JvZHk6IEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50XG4gIHByaXZhdGUgX3Jvd3M6IEhUTUxDb2xsZWN0aW9uT2Y8SFRNTFRhYmxlUm93RWxlbWVudD5cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgdGFibGUgY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTFRhYmxlRWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9oZWFkZXJDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVIZWFkZXJDbGljay5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9ib2R5ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0Ym9keVwiKSBhcyBIVE1MVGFibGVTZWN0aW9uRWxlbWVudFxuICAgIHRoaXMuX3Jvd3MgPSB0aGlzLl9ib2R5LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidHJcIilcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIGZvciAobGV0IGhlYWRlciBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9IRUFERVIpKSB7XG4gICAgICBpZiAoaGVhZGVyLmdldEF0dHJpYnV0ZShcImRhdGEtdHlwZVwiKSkge1xuICAgICAgICBoZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hlYWRlckNsaWNrSGFuZGxlcilcblxuICAgICAgICBsZXQgYXJyb3dFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfQVJST1cpXG4gICAgICAgICAgLmVsZW1lbnRcblxuICAgICAgICBoZWFkZXIuYXBwZW5kQ2hpbGQoYXJyb3dFbGVtZW50KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlSGVhZGVyQ2xpY2soZTogRXZlbnQpIHtcbiAgICBjb25zdCB0aCA9IGUudGFyZ2V0IGFzIEhUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50XG4gICAgdGhpcy5zb3J0KHRoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNvcnRzIHRoZSB0YWJsZSBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCB0YWJsZSBoZWFkZXIgZWxlbWVudC5cbiAgICogVGhlIGNvbHVtbiBpcyBzb3J0ZWQgYXNjZW5kaW5nIGJ5IGRlZmF1bHQgaWYgbm8gZGlyZWN0aW9uIGlzIHNwZWNpZmllZCBhbmQgbm9cbiAgICogZXhpc3Rpbmcgc29ydCBvcmRlciBjbGFzcyBpcyBmb3VuZCBpbiB0aGUgbWFya3VwLlxuICAgKlxuICAgKiBJZiB0aGUgZGlzcGxheWVkIGRhdGEgaXMgbm90IHN1aXRhYmxlIGZvciBzb3J0aW5nIGA8dGQvPmAgZWxlbWVudHMgY2FuIGRlZmluZSBhIGBkYXRhLXZhbHVlYCBhdHRyaWJ1dGVcbiAgICogd2hpY2ggaXMgdGhlbiB1c2VkIGZvciB0aGUgZGF0YS1zb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7VGFibGVIZWFkZXJ9IHRhYmxlSGVhZGVyIFRoZSBoZWFkZXIgZWxlbWVudCBvZiB0aGUgcm93IHRvIHNvcnQgYnkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0byBzb3J0LCBgMWAgZm9yIGFzY2VuZGluZywgYC0xYCBmb3IgZGVzY2VuZGluZyBvcmRlci4gVGhpcyBwYXJhbWV0ZXIgaXMgb3B0aW9uYWwuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGVxdWFsaXR5Q29tcGFyZXIgVGhlIGVxdWlhbGl0eSBjb21wYXJlciBmdW5jdGlvbiB0byBjb21wYXJlIGluZGl2aWR1YWwgY2VsbCB2YWx1ZXMuXG4gICAqL1xuICBwdWJsaWMgc29ydChcbiAgICB0YWJsZUhlYWRlcjogSFRNTFRhYmxlSGVhZGVyQ2VsbEVsZW1lbnQsXG4gICAgZGlyZWN0aW9uPzogLTEgfCAxLFxuICAgIGVxdWFsaXR5Q29tcGFyZXI/OiBDb21wYXJlclxuICApIHtcbiAgICBpZiAoIXRhYmxlSGVhZGVyIHx8IHRhYmxlSGVhZGVyLnRhZ05hbWUgIT09IFwiVEhcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHBhcmFtZXRlciAndGFibGVIZWFkZXInIG11c3QgYmUgYSB2YWxpZCBjb2x1bW4gaGVhZGVyIG5vZGVcIilcbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uICE9PSAxICYmIGRpcmVjdGlvbiAhPT0gLTEgJiYgZGlyZWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBvdXQgb2YgcmFuZ2UsIHBhcmFtZXRlciAnZGlyZWN0aW9uJyB3aXRoIHZhbHVlICcke2RpcmVjdGlvbn0nIG11c3QgYmUgZWl0aGVyIC0xLCAxIG9yIHVuZGVmaW5lZGApXG4gICAgfVxuXG4gICAgY29uc3QgY29sdW1uSW5kZXggPSB0YWJsZUhlYWRlci5jZWxsSW5kZXhcblxuICAgIGlmICghZXF1YWxpdHlDb21wYXJlcikge1xuICAgICAgbGV0IGRhdGFUeXBlID0gdGFibGVIZWFkZXIuZ2V0QXR0cmlidXRlKFwiZGF0YS10eXBlXCIpXG4gICAgICBlcXVhbGl0eUNvbXBhcmVyID0gdGhpcy5fZ2V0Q29tcGFyZXIoZGF0YVR5cGUhKVxuICAgIH1cblxuICAgIGlmIChjb2x1bW5JbmRleCA+PSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9IRUFERVIpLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29sdW1uIG91dCBvZiByYW5nZVwiKVxuICAgIH1cblxuICAgIGZvciAobGV0IGhlYWRlciBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9IRUFERVIpKSB7XG4gICAgICBpZiAoaGVhZGVyICE9PSB0YWJsZUhlYWRlcikge1xuICAgICAgICBEb20ucmVtb3ZlQ2xhc3MoaGVhZGVyLCBDTEFTU19TT1JURURfQVNDRU5ESU5HKVxuICAgICAgICBEb20ucmVtb3ZlQ2xhc3MoaGVhZGVyLCBDTEFTU19TT1JURURfREVTQ0VORElORylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoRG9tLmhhc0NsYXNzKHRhYmxlSGVhZGVyLCBDTEFTU19TT1JURURfQVNDRU5ESU5HKSkge1xuICAgICAgRG9tLnJlbW92ZUNsYXNzKHRhYmxlSGVhZGVyLCBDTEFTU19TT1JURURfQVNDRU5ESU5HKVxuICAgICAgRG9tLmFkZENsYXNzKHRhYmxlSGVhZGVyLCBDTEFTU19TT1JURURfREVTQ0VORElORylcblxuICAgICAgZGlyZWN0aW9uID0gZGlyZWN0aW9uIHx8IC0xXG4gICAgfSBlbHNlIHtcbiAgICAgIERvbS5yZW1vdmVDbGFzcyh0YWJsZUhlYWRlciwgQ0xBU1NfU09SVEVEX0RFU0NFTkRJTkcpXG4gICAgICBEb20uYWRkQ2xhc3ModGFibGVIZWFkZXIsIENMQVNTX1NPUlRFRF9BU0NFTkRJTkcpXG4gICAgICBkaXJlY3Rpb24gPSBkaXJlY3Rpb24gfHwgMVxuICAgIH1cblxuICAgIHRoaXMuX3F1aWNrc29ydChjb2x1bW5JbmRleCwgMCwgdGhpcy5fcm93cy5sZW5ndGggLSAxLCBkaXJlY3Rpb24sIGVxdWFsaXR5Q29tcGFyZXIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldENlbGwoY29sdW1uOiBudW1iZXIsIHJvdzogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvd3Nbcm93XS5jZWxsc1tjb2x1bW5dXG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldFJvdyhyb3c6IG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl9yb3dzW3Jvd11cbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0Q29tcGFyZXIoZGF0YVR5cGU6IHN0cmluZyk6IENvbXBhcmVyPHN0cmluZz4ge1xuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAgIGNhc2UgXCJudW1iZXJcIjoge1xuICAgICAgICAvLyBwYXJzZSB0aGUgc3RyaW5nIGFzIGEgbnVtYmVyXG4gICAgICAgIHJldHVybiAoYSwgYikgPT4gcGFyc2VGbG9hdChhKSAtIHBhcnNlRmxvYXQoYilcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgLy8gY29tcGFyZSBzdHJpbmdzXG4gICAgICAgIHJldHVybiAoYSwgYikgPT4ge1xuICAgICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhID4gYikge1xuICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9xdWlja3NvcnQoXG4gICAgY29sdW1uOiBudW1iZXIsXG4gICAgbGVmdDogbnVtYmVyLFxuICAgIHJpZ2h0OiBudW1iZXIsXG4gICAgZGlyZWN0aW9uOiAtMSB8IDEgPSAxLFxuICAgIGVxdWFsaXR5Q29tcGFyZXI6IENvbXBhcmVyPHN0cmluZz5cbiAgKSB7XG4gICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDApIHtcblxuICAgICAgbGV0IHBhcnRpdGlvbiA9IHRoaXMuX3BhcnRpdGlvbihjb2x1bW4sIGxlZnQsIHJpZ2h0LCBkaXJlY3Rpb24sIGVxdWFsaXR5Q29tcGFyZXIpXG5cbiAgICAgIGlmIChsZWZ0IDwgcGFydGl0aW9uIC0gMSkge1xuICAgICAgICB0aGlzLl9xdWlja3NvcnQoY29sdW1uLCBsZWZ0LCBwYXJ0aXRpb24gLSAxLCBkaXJlY3Rpb24sIGVxdWFsaXR5Q29tcGFyZXIpXG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJ0aXRpb24gPCByaWdodCkge1xuICAgICAgICB0aGlzLl9xdWlja3NvcnQoY29sdW1uLCBwYXJ0aXRpb24sIHJpZ2h0LCBkaXJlY3Rpb24sIGVxdWFsaXR5Q29tcGFyZXIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9wYXJ0aXRpb24oXG4gICAgY29sdW1uOiBudW1iZXIsXG4gICAgbGVmdDogbnVtYmVyLFxuICAgIHJpZ2h0OiBudW1iZXIsXG4gICAgZGlyZWN0aW9uOiAtMSB8IDEgPSAxLFxuICAgIGVxdWFsaXR5Q29tcGFyZXI6IENvbXBhcmVyPHN0cmluZz5cbiAgKSB7XG4gICAgbGV0IHBpdm90ID0gdGhpcy5fZ2V0Q2VsbChjb2x1bW4sIE1hdGguZmxvb3IoKHJpZ2h0ICsgbGVmdCkgLyAyKSlcbiAgICBsZXQgaSA9IGxlZnRcbiAgICBsZXQgaiA9IHJpZ2h0XG5cbiAgICB3aGlsZSAoaSA8PSBqKSB7XG4gICAgICB3aGlsZSAodGhpcy5fZXF1YWxzKHRoaXMuX2dldENlbGwoY29sdW1uLCBpKSwgcGl2b3QsIGVxdWFsaXR5Q29tcGFyZXIpICogZGlyZWN0aW9uIDwgMCkge1xuICAgICAgICBpKytcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRoaXMuX2VxdWFscyh0aGlzLl9nZXRDZWxsKGNvbHVtbiwgaiksIHBpdm90LCBlcXVhbGl0eUNvbXBhcmVyKSAqIGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgai0tXG4gICAgICB9XG5cbiAgICAgIGlmIChpIDw9IGopIHtcbiAgICAgICAgdGhpcy5fc3dhcChpLCBqKVxuICAgICAgICBpKytcbiAgICAgICAgai0tXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGlcbiAgfVxuXG4gIHByb3RlY3RlZCBfZXF1YWxzKFxuICAgIGE6IEhUTUxFbGVtZW50LFxuICAgIGI6IEhUTUxFbGVtZW50LFxuICAgIGVxdWFsaXR5Q29tcGFyZXI6IENvbXBhcmVyPHN0cmluZz5cbiAgKSB7XG4gICAgbGV0IGRhdGFBID0gYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpXG4gICAgbGV0IGRhdGFCID0gYi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpXG5cbiAgICBkYXRhQSA9IGRhdGFBIHx8IGEudGV4dENvbnRlbnQgfHwgYS5pbm5lclRleHRcbiAgICBkYXRhQiA9IGRhdGFCIHx8IGIudGV4dENvbnRlbnQgfHwgYi5pbm5lclRleHRcblxuICAgIHJldHVybiBlcXVhbGl0eUNvbXBhcmVyKGRhdGFBLCBkYXRhQilcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3dhcChpOiBudW1iZXIsIGo6IG51bWJlcikge1xuICAgIGxldCB0bXBOb2RlID0gdGhpcy5fYm9keS5yZXBsYWNlQ2hpbGQodGhpcy5fZ2V0Um93KGkpLCB0aGlzLl9nZXRSb3coaikpXG4gICAgY29uc3QgcmVmZXJlbmNlUm93ID0gdGhpcy5fZ2V0Um93KGkpXG5cbiAgICBpZiAoIXJlZmVyZW5jZVJvdykge1xuICAgICAgdGhpcy5fYm9keS5hcHBlbmRDaGlsZCh0bXBOb2RlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ib2R5Lmluc2VydEJlZm9yZSh0bXBOb2RlLCByZWZlcmVuY2VSb3cpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjb21wb25lbnQgYW5kIGNsZWFycyBhbGwgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IGhlYWRlciBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9IRUFERVIpKSB7XG4gICAgICBoZWFkZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hlYWRlckNsaWNrSGFuZGxlcilcbiAgICB9XG5cbiAgICAodGhpcyBhcyBhbnkpLl9oZWFkZXJDbGlja0hhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX2JvZHkgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX3Jvd3MgPSBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCJ0YWJsZVwiLCAoZSkgPT4ge1xuICAgIG5ldyBUYWJsZShlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBUYWJsZVxuIiwiaW1wb3J0IGFuaW1lIGZyb20gXCJhbmltZWpzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcblxuY29uc3QgQ0xBU1NfSVRFTVMgPSBcIi50b29sYmFyX19pdGVtXCJcbmNvbnN0IENMQVNTX1NIT1cgPSBcIml0ZW0tLXNob3dcIlxuXG5jb25zdCBBTklNQVRJT05fU1RBUlRfREVMQVkgPSAxMDBcbmNvbnN0IEFOSU1BVElPTl9PRkZTRVQgPSA1MFxuXG4vKipcbiAqIFRvb2xiYXIgY29tcG9uZW50LiBVc2UgdGhpcyBjb21wb25lbnQgdG8gc2hvdyBhbmQgaGlkZSB0aGVcbiAqIGluZGl2aWR1YWwgdG9vbGJhciBpdGVtcy5cbiAqL1xuY2xhc3MgVG9vbGJhciBleHRlbmRzIERvbUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBNYWtlcyB0aGUgdG9vbGJhciBpdGVtcyB2aXNpYmxlLlxuICAgKi9cbiAgcHVibGljIHNob3coKSB7XG4gICAgbGV0IGRlbGF5ID0gQU5JTUFUSU9OX1NUQVJUX0RFTEFZXG4gICAgbGV0IGl0ZW1zID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoQ0xBU1NfSVRFTVMpXG5cbiAgICBsZXQgdGltZWxpbmUgPSBhbmltZS50aW1lbGluZSgpXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGl0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdGltZWxpbmUuYWRkKHtcbiAgICAgICAgdGFyZ2V0czogaXRlbXNbaW5kZXhdLFxuICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgb2Zmc2V0OiBkZWxheSxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBpdGVtc1tpbmRleF0uY2xhc3NMaXN0LmFkZChDTEFTU19TSE9XKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgZGVsYXkgKz0gQU5JTUFUSU9OX09GRlNFVFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgdG9vbGJhciBpdGVtcy5cbiAgICovXG4gIHB1YmxpYyBoaWRlKCkge1xuICAgIGxldCBkZWxheSA9IEFOSU1BVElPTl9TVEFSVF9ERUxBWVxuICAgIGxldCBpdGVtcyA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKENMQVNTX0lURU1TKVxuXG4gICAgbGV0IHRpbWVsaW5lID0gYW5pbWUudGltZWxpbmUoKVxuICAgIGZvciAobGV0IGluZGV4ID0gaXRlbXMubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgdGltZWxpbmUuYWRkKHtcbiAgICAgICAgdGFyZ2V0czogaXRlbXNbaW5kZXhdLFxuICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgb2Zmc2V0OiBkZWxheSxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBpdGVtc1tpbmRleF0uY2xhc3NMaXN0LnJlbW92ZShDTEFTU19TSE9XKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgZGVsYXkgKz0gQU5JTUFUSU9OX09GRlNFVFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSB0b29sYmFyIGl0ZW1zIHZpc2liaWxpdHkuXG4gICAqL1xuICBwdWJsaWMgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7Q0xBU1NfU0hPV31gKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc2hvdygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvb2xiYXJcbiIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJkZWZhdWx0XCI6IG9ialxuICAgIH07XG4gIH1cblxuICB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTtcblxuICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gIH1cblxuICB2YXIgbmV3T2JqID0ge307XG4gIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xuXG4gICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7XG5cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsIi8qXG4gKiBhbmltZS5qcyB2My4xLjBcbiAqIChjKSAyMDE5IEp1bGlhbiBHYXJuaWVyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGFuaW1lanMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBEZWZhdWx0c1xuXG52YXIgZGVmYXVsdEluc3RhbmNlU2V0dGluZ3MgPSB7XG4gIHVwZGF0ZTogbnVsbCxcbiAgYmVnaW46IG51bGwsXG4gIGxvb3BCZWdpbjogbnVsbCxcbiAgY2hhbmdlQmVnaW46IG51bGwsXG4gIGNoYW5nZTogbnVsbCxcbiAgY2hhbmdlQ29tcGxldGU6IG51bGwsXG4gIGxvb3BDb21wbGV0ZTogbnVsbCxcbiAgY29tcGxldGU6IG51bGwsXG4gIGxvb3A6IDEsXG4gIGRpcmVjdGlvbjogJ25vcm1hbCcsXG4gIGF1dG9wbGF5OiB0cnVlLFxuICB0aW1lbGluZU9mZnNldDogMFxufTtcblxudmFyIGRlZmF1bHRUd2VlblNldHRpbmdzID0ge1xuICBkdXJhdGlvbjogMTAwMCxcbiAgZGVsYXk6IDAsXG4gIGVuZERlbGF5OiAwLFxuICBlYXNpbmc6ICdlYXNlT3V0RWxhc3RpYygxLCAuNSknLFxuICByb3VuZDogMFxufTtcblxudmFyIHZhbGlkVHJhbnNmb3JtcyA9IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJywgJ3RyYW5zbGF0ZVonLCAncm90YXRlJywgJ3JvdGF0ZVgnLCAncm90YXRlWScsICdyb3RhdGVaJywgJ3NjYWxlJywgJ3NjYWxlWCcsICdzY2FsZVknLCAnc2NhbGVaJywgJ3NrZXcnLCAnc2tld1gnLCAnc2tld1knLCAncGVyc3BlY3RpdmUnXTtcblxuLy8gQ2FjaGluZ1xuXG52YXIgY2FjaGUgPSB7XG4gIENTUzoge30sXG4gIHNwcmluZ3M6IHt9XG59O1xuXG4vLyBVdGlsc1xuXG5mdW5jdGlvbiBtaW5NYXgodmFsLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsLCBtaW4pLCBtYXgpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdDb250YWlucyhzdHIsIHRleHQpIHtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKHRleHQpID4gLTE7XG59XG5cbmZ1bmN0aW9uIGFwcGx5QXJndW1lbnRzKGZ1bmMsIGFyZ3MpIHtcbiAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XG59XG5cbnZhciBpcyA9IHtcbiAgYXJyOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gQXJyYXkuaXNBcnJheShhKTsgfSxcbiAgb2JqOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gc3RyaW5nQ29udGFpbnMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpLCAnT2JqZWN0Jyk7IH0sXG4gIHB0aDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGlzLm9iaihhKSAmJiBhLmhhc093blByb3BlcnR5KCd0b3RhbExlbmd0aCcpOyB9LFxuICBzdmc6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhIGluc3RhbmNlb2YgU1ZHRWxlbWVudDsgfSxcbiAgaW5wOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQ7IH0sXG4gIGRvbTogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEubm9kZVR5cGUgfHwgaXMuc3ZnKGEpOyB9LFxuICBzdHI6IGZ1bmN0aW9uIChhKSB7IHJldHVybiB0eXBlb2YgYSA9PT0gJ3N0cmluZyc7IH0sXG4gIGZuYzogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHR5cGVvZiBhID09PSAnZnVuY3Rpb24nOyB9LFxuICB1bmQ6IGZ1bmN0aW9uIChhKSB7IHJldHVybiB0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCc7IH0sXG4gIGhleDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIC8oXiNbMC05QS1GXXs2fSQpfCheI1swLTlBLUZdezN9JCkvaS50ZXN0KGEpOyB9LFxuICByZ2I6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAvXnJnYi8udGVzdChhKTsgfSxcbiAgaHNsOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gL15oc2wvLnRlc3QoYSk7IH0sXG4gIGNvbDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIChpcy5oZXgoYSkgfHwgaXMucmdiKGEpIHx8IGlzLmhzbChhKSk7IH0sXG4gIGtleTogZnVuY3Rpb24gKGEpIHsgcmV0dXJuICFkZWZhdWx0SW5zdGFuY2VTZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShhKSAmJiAhZGVmYXVsdFR3ZWVuU2V0dGluZ3MuaGFzT3duUHJvcGVydHkoYSkgJiYgYSAhPT0gJ3RhcmdldHMnICYmIGEgIT09ICdrZXlmcmFtZXMnOyB9XG59O1xuXG4vLyBFYXNpbmdzXG5cbmZ1bmN0aW9uIHBhcnNlRWFzaW5nUGFyYW1ldGVycyhzdHJpbmcpIHtcbiAgdmFyIG1hdGNoID0gL1xcKChbXildKylcXCkvLmV4ZWMoc3RyaW5nKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHBhcnNlRmxvYXQocCk7IH0pIDogW107XG59XG5cbi8vIFNwcmluZyBzb2x2ZXIgaW5zcGlyZWQgYnkgV2Via2l0IENvcHlyaWdodCDCqSAyMDE2IEFwcGxlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gaHR0cHM6Ly93ZWJraXQub3JnL2RlbW9zL3NwcmluZy9zcHJpbmcuanNcblxuZnVuY3Rpb24gc3ByaW5nKHN0cmluZywgZHVyYXRpb24pIHtcblxuICB2YXIgcGFyYW1zID0gcGFyc2VFYXNpbmdQYXJhbWV0ZXJzKHN0cmluZyk7XG4gIHZhciBtYXNzID0gbWluTWF4KGlzLnVuZChwYXJhbXNbMF0pID8gMSA6IHBhcmFtc1swXSwgLjEsIDEwMCk7XG4gIHZhciBzdGlmZm5lc3MgPSBtaW5NYXgoaXMudW5kKHBhcmFtc1sxXSkgPyAxMDAgOiBwYXJhbXNbMV0sIC4xLCAxMDApO1xuICB2YXIgZGFtcGluZyA9IG1pbk1heChpcy51bmQocGFyYW1zWzJdKSA/IDEwIDogcGFyYW1zWzJdLCAuMSwgMTAwKTtcbiAgdmFyIHZlbG9jaXR5ID0gIG1pbk1heChpcy51bmQocGFyYW1zWzNdKSA/IDAgOiBwYXJhbXNbM10sIC4xLCAxMDApO1xuICB2YXIgdzAgPSBNYXRoLnNxcnQoc3RpZmZuZXNzIC8gbWFzcyk7XG4gIHZhciB6ZXRhID0gZGFtcGluZyAvICgyICogTWF0aC5zcXJ0KHN0aWZmbmVzcyAqIG1hc3MpKTtcbiAgdmFyIHdkID0gemV0YSA8IDEgPyB3MCAqIE1hdGguc3FydCgxIC0gemV0YSAqIHpldGEpIDogMDtcbiAgdmFyIGEgPSAxO1xuICB2YXIgYiA9IHpldGEgPCAxID8gKHpldGEgKiB3MCArIC12ZWxvY2l0eSkgLyB3ZCA6IC12ZWxvY2l0eSArIHcwO1xuXG4gIGZ1bmN0aW9uIHNvbHZlcih0KSB7XG4gICAgdmFyIHByb2dyZXNzID0gZHVyYXRpb24gPyAoZHVyYXRpb24gKiB0KSAvIDEwMDAgOiB0O1xuICAgIGlmICh6ZXRhIDwgMSkge1xuICAgICAgcHJvZ3Jlc3MgPSBNYXRoLmV4cCgtcHJvZ3Jlc3MgKiB6ZXRhICogdzApICogKGEgKiBNYXRoLmNvcyh3ZCAqIHByb2dyZXNzKSArIGIgKiBNYXRoLnNpbih3ZCAqIHByb2dyZXNzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2dyZXNzID0gKGEgKyBiICogcHJvZ3Jlc3MpICogTWF0aC5leHAoLXByb2dyZXNzICogdzApO1xuICAgIH1cbiAgICBpZiAodCA9PT0gMCB8fCB0ID09PSAxKSB7IHJldHVybiB0OyB9XG4gICAgcmV0dXJuIDEgLSBwcm9ncmVzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldER1cmF0aW9uKCkge1xuICAgIHZhciBjYWNoZWQgPSBjYWNoZS5zcHJpbmdzW3N0cmluZ107XG4gICAgaWYgKGNhY2hlZCkgeyByZXR1cm4gY2FjaGVkOyB9XG4gICAgdmFyIGZyYW1lID0gMS82O1xuICAgIHZhciBlbGFwc2VkID0gMDtcbiAgICB2YXIgcmVzdCA9IDA7XG4gICAgd2hpbGUodHJ1ZSkge1xuICAgICAgZWxhcHNlZCArPSBmcmFtZTtcbiAgICAgIGlmIChzb2x2ZXIoZWxhcHNlZCkgPT09IDEpIHtcbiAgICAgICAgcmVzdCsrO1xuICAgICAgICBpZiAocmVzdCA+PSAxNikgeyBicmVhazsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBkdXJhdGlvbiA9IGVsYXBzZWQgKiBmcmFtZSAqIDEwMDA7XG4gICAgY2FjaGUuc3ByaW5nc1tzdHJpbmddID0gZHVyYXRpb247XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9XG5cbiAgcmV0dXJuIGR1cmF0aW9uID8gc29sdmVyIDogZ2V0RHVyYXRpb247XG5cbn1cblxuLy8gQmFzaWMgc3RlcHMgZWFzaW5nIGltcGxlbWVudGF0aW9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2ZyL2RvY3MvV2ViL0NTUy90cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblxuXG5mdW5jdGlvbiBzdGVwcyhzdGVwcykge1xuICBpZiAoIHN0ZXBzID09PSB2b2lkIDAgKSBzdGVwcyA9IDEwO1xuXG4gIHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gTWF0aC5yb3VuZCh0ICogc3RlcHMpICogKDEgLyBzdGVwcyk7IH07XG59XG5cbi8vIEJlemllckVhc2luZyBodHRwczovL2dpdGh1Yi5jb20vZ3JlL2Jlemllci1lYXNpbmdcblxudmFyIGJlemllciA9IChmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGtTcGxpbmVUYWJsZVNpemUgPSAxMTtcbiAgdmFyIGtTYW1wbGVTdGVwU2l6ZSA9IDEuMCAvIChrU3BsaW5lVGFibGVTaXplIC0gMS4wKTtcblxuICBmdW5jdGlvbiBBKGFBMSwgYUEyKSB7IHJldHVybiAxLjAgLSAzLjAgKiBhQTIgKyAzLjAgKiBhQTEgfVxuICBmdW5jdGlvbiBCKGFBMSwgYUEyKSB7IHJldHVybiAzLjAgKiBhQTIgLSA2LjAgKiBhQTEgfVxuICBmdW5jdGlvbiBDKGFBMSkgICAgICB7IHJldHVybiAzLjAgKiBhQTEgfVxuXG4gIGZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7IHJldHVybiAoKEEoYUExLCBhQTIpICogYVQgKyBCKGFBMSwgYUEyKSkgKiBhVCArIEMoYUExKSkgKiBhVCB9XG4gIGZ1bmN0aW9uIGdldFNsb3BlKGFULCBhQTEsIGFBMikgeyByZXR1cm4gMy4wICogQShhQTEsIGFBMikgKiBhVCAqIGFUICsgMi4wICogQihhQTEsIGFBMikgKiBhVCArIEMoYUExKSB9XG5cbiAgZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIsIG1YMSwgbVgyKSB7XG4gICAgdmFyIGN1cnJlbnRYLCBjdXJyZW50VCwgaSA9IDA7XG4gICAgZG8ge1xuICAgICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcbiAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICBpZiAoY3VycmVudFggPiAwLjApIHsgYUIgPSBjdXJyZW50VDsgfSBlbHNlIHsgYUEgPSBjdXJyZW50VDsgfVxuICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IDAuMDAwMDAwMSAmJiArK2kgPCAxMCk7XG4gICAgcmV0dXJuIGN1cnJlbnRUO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGFHdWVzc1QsIG1YMSwgbVgyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgIHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHsgcmV0dXJuIGFHdWVzc1Q7IH1cbiAgICAgIHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICAgIH1cbiAgICByZXR1cm4gYUd1ZXNzVDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcblxuICAgIGlmICghKDAgPD0gbVgxICYmIG1YMSA8PSAxICYmIDAgPD0gbVgyICYmIG1YMiA8PSAxKSkgeyByZXR1cm47IH1cbiAgICB2YXIgc2FtcGxlVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKTtcblxuICAgIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrU3BsaW5lVGFibGVTaXplOyArK2kpIHtcbiAgICAgICAgc2FtcGxlVmFsdWVzW2ldID0gY2FsY0JlemllcihpICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcblxuICAgICAgdmFyIGludGVydmFsU3RhcnQgPSAwO1xuICAgICAgdmFyIGN1cnJlbnRTYW1wbGUgPSAxO1xuICAgICAgdmFyIGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcblxuICAgICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgICB9XG5cbiAgICAgIC0tY3VycmVudFNhbXBsZTtcblxuICAgICAgdmFyIGRpc3QgPSAoYVggLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pO1xuICAgICAgdmFyIGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplO1xuICAgICAgdmFyIGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuXG4gICAgICBpZiAoaW5pdGlhbFNsb3BlID49IDAuMDAxKSB7XG4gICAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgICB9IGVsc2UgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikgeyByZXR1cm4geDsgfVxuICAgICAgaWYgKHggPT09IDAgfHwgeCA9PT0gMSkgeyByZXR1cm4geDsgfVxuICAgICAgcmV0dXJuIGNhbGNCZXppZXIoZ2V0VEZvclgoeCksIG1ZMSwgbVkyKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBiZXppZXI7XG5cbn0pKCk7XG5cbnZhciBwZW5uZXIgPSAoZnVuY3Rpb24gKCkge1xuXG4gIC8vIEJhc2VkIG9uIGpRdWVyeSBVSSdzIGltcGxlbWVuYXRpb24gb2YgZWFzaW5nIGVxdWF0aW9ucyBmcm9tIFJvYmVydCBQZW5uZXIgKGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcpXG5cbiAgdmFyIGVhc2VzID0geyBsaW5lYXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9OyB9IH07XG5cbiAgdmFyIGZ1bmN0aW9uRWFzaW5ncyA9IHtcbiAgICBTaW5lOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gMSAtIE1hdGguY29zKHQgKiBNYXRoLlBJIC8gMik7IH07IH0sXG4gICAgQ2lyYzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KTsgfTsgfSxcbiAgICBCYWNrOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAqIHQgKiAoMyAqIHQgLSAyKTsgfTsgfSxcbiAgICBCb3VuY2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgcG93MiwgYiA9IDQ7XG4gICAgICB3aGlsZSAodCA8ICgoIHBvdzIgPSBNYXRoLnBvdygyLCAtLWIpKSAtIDEpIC8gMTEpIHt9XG4gICAgICByZXR1cm4gMSAvIE1hdGgucG93KDQsIDMgLSBiKSAtIDcuNTYyNSAqIE1hdGgucG93KCggcG93MiAqIDMgLSAyICkgLyAyMiAtIHQsIDIpXG4gICAgfTsgfSxcbiAgICBFbGFzdGljOiBmdW5jdGlvbiAoYW1wbGl0dWRlLCBwZXJpb2QpIHtcbiAgICAgIGlmICggYW1wbGl0dWRlID09PSB2b2lkIDAgKSBhbXBsaXR1ZGUgPSAxO1xuICAgICAgaWYgKCBwZXJpb2QgPT09IHZvaWQgMCApIHBlcmlvZCA9IC41O1xuXG4gICAgICB2YXIgYSA9IG1pbk1heChhbXBsaXR1ZGUsIDEsIDEwKTtcbiAgICAgIHZhciBwID0gbWluTWF4KHBlcmlvZCwgLjEsIDIpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAodCA9PT0gMCB8fCB0ID09PSAxKSA/IHQgOiBcbiAgICAgICAgICAtYSAqIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSkgKiBNYXRoLnNpbigoKCh0IC0gMSkgLSAocCAvIChNYXRoLlBJICogMikgKiBNYXRoLmFzaW4oMSAvIGEpKSkgKiAoTWF0aC5QSSAqIDIpKSAvIHApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgYmFzZUVhc2luZ3MgPSBbJ1F1YWQnLCAnQ3ViaWMnLCAnUXVhcnQnLCAnUXVpbnQnLCAnRXhwbyddO1xuXG4gIGJhc2VFYXNpbmdzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUsIGkpIHtcbiAgICBmdW5jdGlvbkVhc2luZ3NbbmFtZV0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gTWF0aC5wb3codCwgaSArIDIpOyB9OyB9O1xuICB9KTtcblxuICBPYmplY3Qua2V5cyhmdW5jdGlvbkVhc2luZ3MpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgZWFzZUluID0gZnVuY3Rpb25FYXNpbmdzW25hbWVdO1xuICAgIGVhc2VzWydlYXNlSW4nICsgbmFtZV0gPSBlYXNlSW47XG4gICAgZWFzZXNbJ2Vhc2VPdXQnICsgbmFtZV0gPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDEgLSBlYXNlSW4oYSwgYikoMSAtIHQpOyB9OyB9O1xuICAgIGVhc2VzWydlYXNlSW5PdXQnICsgbmFtZV0gPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPCAwLjUgPyBlYXNlSW4oYSwgYikodCAqIDIpIC8gMiA6IFxuICAgICAgMSAtIGVhc2VJbihhLCBiKSh0ICogLTIgKyAyKSAvIDI7IH07IH07XG4gIH0pO1xuXG4gIHJldHVybiBlYXNlcztcblxufSkoKTtcblxuZnVuY3Rpb24gcGFyc2VFYXNpbmdzKGVhc2luZywgZHVyYXRpb24pIHtcbiAgaWYgKGlzLmZuYyhlYXNpbmcpKSB7IHJldHVybiBlYXNpbmc7IH1cbiAgdmFyIG5hbWUgPSBlYXNpbmcuc3BsaXQoJygnKVswXTtcbiAgdmFyIGVhc2UgPSBwZW5uZXJbbmFtZV07XG4gIHZhciBhcmdzID0gcGFyc2VFYXNpbmdQYXJhbWV0ZXJzKGVhc2luZyk7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ3NwcmluZycgOiByZXR1cm4gc3ByaW5nKGVhc2luZywgZHVyYXRpb24pO1xuICAgIGNhc2UgJ2N1YmljQmV6aWVyJyA6IHJldHVybiBhcHBseUFyZ3VtZW50cyhiZXppZXIsIGFyZ3MpO1xuICAgIGNhc2UgJ3N0ZXBzJyA6IHJldHVybiBhcHBseUFyZ3VtZW50cyhzdGVwcywgYXJncyk7XG4gICAgZGVmYXVsdCA6IHJldHVybiBhcHBseUFyZ3VtZW50cyhlYXNlLCBhcmdzKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdzXG5cbmZ1bmN0aW9uIHNlbGVjdFN0cmluZyhzdHIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHN0cik7XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuLy8gQXJyYXlzXG5cbmZ1bmN0aW9uIGZpbHRlckFycmF5KGFyciwgY2FsbGJhY2spIHtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaSBpbiBhcnIpIHtcbiAgICAgIHZhciB2YWwgPSBhcnJbaV07XG4gICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWwsIGksIGFycikpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbkFycmF5KGFycikge1xuICByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5jb25jYXQoaXMuYXJyKGIpID8gZmxhdHRlbkFycmF5KGIpIDogYik7IH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheShvKSB7XG4gIGlmIChpcy5hcnIobykpIHsgcmV0dXJuIG87IH1cbiAgaWYgKGlzLnN0cihvKSkgeyBvID0gc2VsZWN0U3RyaW5nKG8pIHx8IG87IH1cbiAgaWYgKG8gaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBvIGluc3RhbmNlb2YgSFRNTENvbGxlY3Rpb24pIHsgcmV0dXJuIFtdLnNsaWNlLmNhbGwobyk7IH1cbiAgcmV0dXJuIFtvXTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDb250YWlucyhhcnIsIHZhbCkge1xuICByZXR1cm4gYXJyLnNvbWUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgPT09IHZhbDsgfSk7XG59XG5cbi8vIE9iamVjdHNcblxuZnVuY3Rpb24gY2xvbmVPYmplY3Qobykge1xuICB2YXIgY2xvbmUgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBvKSB7IGNsb25lW3BdID0gb1twXTsgfVxuICByZXR1cm4gY2xvbmU7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VPYmplY3RQcm9wcyhvMSwgbzIpIHtcbiAgdmFyIG8gPSBjbG9uZU9iamVjdChvMSk7XG4gIGZvciAodmFyIHAgaW4gbzEpIHsgb1twXSA9IG8yLmhhc093blByb3BlcnR5KHApID8gbzJbcF0gOiBvMVtwXTsgfVxuICByZXR1cm4gbztcbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG8xLCBvMikge1xuICB2YXIgbyA9IGNsb25lT2JqZWN0KG8xKTtcbiAgZm9yICh2YXIgcCBpbiBvMikgeyBvW3BdID0gaXMudW5kKG8xW3BdKSA/IG8yW3BdIDogbzFbcF07IH1cbiAgcmV0dXJuIG87XG59XG5cbi8vIENvbG9yc1xuXG5mdW5jdGlvbiByZ2JUb1JnYmEocmdiVmFsdWUpIHtcbiAgdmFyIHJnYiA9IC9yZ2JcXCgoXFxkKyxcXHMqW1xcZF0rLFxccypbXFxkXSspXFwpL2cuZXhlYyhyZ2JWYWx1ZSk7XG4gIHJldHVybiByZ2IgPyAoXCJyZ2JhKFwiICsgKHJnYlsxXSkgKyBcIiwxKVwiKSA6IHJnYlZhbHVlO1xufVxuXG5mdW5jdGlvbiBoZXhUb1JnYmEoaGV4VmFsdWUpIHtcbiAgdmFyIHJneCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG4gIHZhciBoZXggPSBoZXhWYWx1ZS5yZXBsYWNlKHJneCwgZnVuY3Rpb24gKG0sIHIsIGcsIGIpIHsgcmV0dXJuIHIgKyByICsgZyArIGcgKyBiICsgYjsgfSApO1xuICB2YXIgcmdiID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKGhleCk7XG4gIHZhciByID0gcGFyc2VJbnQocmdiWzFdLCAxNik7XG4gIHZhciBnID0gcGFyc2VJbnQocmdiWzJdLCAxNik7XG4gIHZhciBiID0gcGFyc2VJbnQocmdiWzNdLCAxNik7XG4gIHJldHVybiAoXCJyZ2JhKFwiICsgciArIFwiLFwiICsgZyArIFwiLFwiICsgYiArIFwiLDEpXCIpO1xufVxuXG5mdW5jdGlvbiBoc2xUb1JnYmEoaHNsVmFsdWUpIHtcbiAgdmFyIGhzbCA9IC9oc2xcXCgoXFxkKyksXFxzKihbXFxkLl0rKSUsXFxzKihbXFxkLl0rKSVcXCkvZy5leGVjKGhzbFZhbHVlKSB8fCAvaHNsYVxcKChcXGQrKSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspXFwpL2cuZXhlYyhoc2xWYWx1ZSk7XG4gIHZhciBoID0gcGFyc2VJbnQoaHNsWzFdLCAxMCkgLyAzNjA7XG4gIHZhciBzID0gcGFyc2VJbnQoaHNsWzJdLCAxMCkgLyAxMDA7XG4gIHZhciBsID0gcGFyc2VJbnQoaHNsWzNdLCAxMCkgLyAxMDA7XG4gIHZhciBhID0gaHNsWzRdIHx8IDE7XG4gIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgIGlmICh0IDwgMCkgeyB0ICs9IDE7IH1cbiAgICBpZiAodCA+IDEpIHsgdCAtPSAxOyB9XG4gICAgaWYgKHQgPCAxLzYpIHsgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7IH1cbiAgICBpZiAodCA8IDEvMikgeyByZXR1cm4gcTsgfVxuICAgIGlmICh0IDwgMi8zKSB7IHJldHVybiBwICsgKHEgLSBwKSAqICgyLzMgLSB0KSAqIDY7IH1cbiAgICByZXR1cm4gcDtcbiAgfVxuICB2YXIgciwgZywgYjtcbiAgaWYgKHMgPT0gMCkge1xuICAgIHIgPSBnID0gYiA9IGw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgIHZhciBwID0gMiAqIGwgLSBxO1xuICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxLzMpO1xuICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAxLzMpO1xuICB9XG4gIHJldHVybiAoXCJyZ2JhKFwiICsgKHIgKiAyNTUpICsgXCIsXCIgKyAoZyAqIDI1NSkgKyBcIixcIiArIChiICogMjU1KSArIFwiLFwiICsgYSArIFwiKVwiKTtcbn1cblxuZnVuY3Rpb24gY29sb3JUb1JnYih2YWwpIHtcbiAgaWYgKGlzLnJnYih2YWwpKSB7IHJldHVybiByZ2JUb1JnYmEodmFsKTsgfVxuICBpZiAoaXMuaGV4KHZhbCkpIHsgcmV0dXJuIGhleFRvUmdiYSh2YWwpOyB9XG4gIGlmIChpcy5oc2wodmFsKSkgeyByZXR1cm4gaHNsVG9SZ2JhKHZhbCk7IH1cbn1cblxuLy8gVW5pdHNcblxuZnVuY3Rpb24gZ2V0VW5pdCh2YWwpIHtcbiAgdmFyIHNwbGl0ID0gL1srLV0/XFxkKlxcLj9cXGQrKD86XFwuXFxkKyk/KD86W2VFXVsrLV0/XFxkKyk/KCV8cHh8cHR8ZW18cmVtfGlufGNtfG1tfGV4fGNofHBjfHZ3fHZofHZtaW58dm1heHxkZWd8cmFkfHR1cm4pPyQvLmV4ZWModmFsKTtcbiAgaWYgKHNwbGl0KSB7IHJldHVybiBzcGxpdFsxXTsgfVxufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1Vbml0KHByb3BOYW1lKSB7XG4gIGlmIChzdHJpbmdDb250YWlucyhwcm9wTmFtZSwgJ3RyYW5zbGF0ZScpIHx8IHByb3BOYW1lID09PSAncGVyc3BlY3RpdmUnKSB7IHJldHVybiAncHgnOyB9XG4gIGlmIChzdHJpbmdDb250YWlucyhwcm9wTmFtZSwgJ3JvdGF0ZScpIHx8IHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAnc2tldycpKSB7IHJldHVybiAnZGVnJzsgfVxufVxuXG4vLyBWYWx1ZXNcblxuZnVuY3Rpb24gZ2V0RnVuY3Rpb25WYWx1ZSh2YWwsIGFuaW1hdGFibGUpIHtcbiAgaWYgKCFpcy5mbmModmFsKSkgeyByZXR1cm4gdmFsOyB9XG4gIHJldHVybiB2YWwoYW5pbWF0YWJsZS50YXJnZXQsIGFuaW1hdGFibGUuaWQsIGFuaW1hdGFibGUudG90YWwpO1xufVxuXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGUoZWwsIHByb3ApIHtcbiAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShwcm9wKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFB4VG9Vbml0KGVsLCB2YWx1ZSwgdW5pdCkge1xuICB2YXIgdmFsdWVVbml0ID0gZ2V0VW5pdCh2YWx1ZSk7XG4gIGlmIChhcnJheUNvbnRhaW5zKFt1bml0LCAnZGVnJywgJ3JhZCcsICd0dXJuJ10sIHZhbHVlVW5pdCkpIHsgcmV0dXJuIHZhbHVlOyB9XG4gIHZhciBjYWNoZWQgPSBjYWNoZS5DU1NbdmFsdWUgKyB1bml0XTtcbiAgaWYgKCFpcy51bmQoY2FjaGVkKSkgeyByZXR1cm4gY2FjaGVkOyB9XG4gIHZhciBiYXNlbGluZSA9IDEwMDtcbiAgdmFyIHRlbXBFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWwudGFnTmFtZSk7XG4gIHZhciBwYXJlbnRFbCA9IChlbC5wYXJlbnROb2RlICYmIChlbC5wYXJlbnROb2RlICE9PSBkb2N1bWVudCkpID8gZWwucGFyZW50Tm9kZSA6IGRvY3VtZW50LmJvZHk7XG4gIHBhcmVudEVsLmFwcGVuZENoaWxkKHRlbXBFbCk7XG4gIHRlbXBFbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIHRlbXBFbC5zdHlsZS53aWR0aCA9IGJhc2VsaW5lICsgdW5pdDtcbiAgdmFyIGZhY3RvciA9IGJhc2VsaW5lIC8gdGVtcEVsLm9mZnNldFdpZHRoO1xuICBwYXJlbnRFbC5yZW1vdmVDaGlsZCh0ZW1wRWwpO1xuICB2YXIgY29udmVydGVkVW5pdCA9IGZhY3RvciAqIHBhcnNlRmxvYXQodmFsdWUpO1xuICBjYWNoZS5DU1NbdmFsdWUgKyB1bml0XSA9IGNvbnZlcnRlZFVuaXQ7XG4gIHJldHVybiBjb252ZXJ0ZWRVbml0O1xufVxuXG5mdW5jdGlvbiBnZXRDU1NWYWx1ZShlbCwgcHJvcCwgdW5pdCkge1xuICBpZiAocHJvcCBpbiBlbC5zdHlsZSkge1xuICAgIHZhciB1cHBlcmNhc2VQcm9wTmFtZSA9IHByb3AucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgdmFsdWUgPSBlbC5zdHlsZVtwcm9wXSB8fCBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHVwcGVyY2FzZVByb3BOYW1lKSB8fCAnMCc7XG4gICAgcmV0dXJuIHVuaXQgPyBjb252ZXJ0UHhUb1VuaXQoZWwsIHZhbHVlLCB1bml0KSA6IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFuaW1hdGlvblR5cGUoZWwsIHByb3ApIHtcbiAgaWYgKGlzLmRvbShlbCkgJiYgIWlzLmlucChlbCkgJiYgKGdldEF0dHJpYnV0ZShlbCwgcHJvcCkgfHwgKGlzLnN2ZyhlbCkgJiYgZWxbcHJvcF0pKSkgeyByZXR1cm4gJ2F0dHJpYnV0ZSc7IH1cbiAgaWYgKGlzLmRvbShlbCkgJiYgYXJyYXlDb250YWlucyh2YWxpZFRyYW5zZm9ybXMsIHByb3ApKSB7IHJldHVybiAndHJhbnNmb3JtJzsgfVxuICBpZiAoaXMuZG9tKGVsKSAmJiAocHJvcCAhPT0gJ3RyYW5zZm9ybScgJiYgZ2V0Q1NTVmFsdWUoZWwsIHByb3ApKSkgeyByZXR1cm4gJ2Nzcyc7IH1cbiAgaWYgKGVsW3Byb3BdICE9IG51bGwpIHsgcmV0dXJuICdvYmplY3QnOyB9XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRUcmFuc2Zvcm1zKGVsKSB7XG4gIGlmICghaXMuZG9tKGVsKSkgeyByZXR1cm47IH1cbiAgdmFyIHN0ciA9IGVsLnN0eWxlLnRyYW5zZm9ybSB8fCAnJztcbiAgdmFyIHJlZyAgPSAvKFxcdyspXFwoKFteKV0qKVxcKS9nO1xuICB2YXIgdHJhbnNmb3JtcyA9IG5ldyBNYXAoKTtcbiAgdmFyIG07IHdoaWxlIChtID0gcmVnLmV4ZWMoc3RyKSkgeyB0cmFuc2Zvcm1zLnNldChtWzFdLCBtWzJdKTsgfVxuICByZXR1cm4gdHJhbnNmb3Jtcztcbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtVmFsdWUoZWwsIHByb3BOYW1lLCBhbmltYXRhYmxlLCB1bml0KSB7XG4gIHZhciBkZWZhdWx0VmFsID0gc3RyaW5nQ29udGFpbnMocHJvcE5hbWUsICdzY2FsZScpID8gMSA6IDAgKyBnZXRUcmFuc2Zvcm1Vbml0KHByb3BOYW1lKTtcbiAgdmFyIHZhbHVlID0gZ2V0RWxlbWVudFRyYW5zZm9ybXMoZWwpLmdldChwcm9wTmFtZSkgfHwgZGVmYXVsdFZhbDtcbiAgaWYgKGFuaW1hdGFibGUpIHtcbiAgICBhbmltYXRhYmxlLnRyYW5zZm9ybXMubGlzdC5zZXQocHJvcE5hbWUsIHZhbHVlKTtcbiAgICBhbmltYXRhYmxlLnRyYW5zZm9ybXNbJ2xhc3QnXSA9IHByb3BOYW1lO1xuICB9XG4gIHJldHVybiB1bml0ID8gY29udmVydFB4VG9Vbml0KGVsLCB2YWx1ZSwgdW5pdCkgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCB1bml0LCBhbmltYXRhYmxlKSB7XG4gIHN3aXRjaCAoZ2V0QW5pbWF0aW9uVHlwZSh0YXJnZXQsIHByb3BOYW1lKSkge1xuICAgIGNhc2UgJ3RyYW5zZm9ybSc6IHJldHVybiBnZXRUcmFuc2Zvcm1WYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCBhbmltYXRhYmxlLCB1bml0KTtcbiAgICBjYXNlICdjc3MnOiByZXR1cm4gZ2V0Q1NTVmFsdWUodGFyZ2V0LCBwcm9wTmFtZSwgdW5pdCk7XG4gICAgY2FzZSAnYXR0cmlidXRlJzogcmV0dXJuIGdldEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BOYW1lKTtcbiAgICBkZWZhdWx0OiByZXR1cm4gdGFyZ2V0W3Byb3BOYW1lXSB8fCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlbGF0aXZlVmFsdWUodG8sIGZyb20pIHtcbiAgdmFyIG9wZXJhdG9yID0gL14oXFwqPXxcXCs9fC09KS8uZXhlYyh0byk7XG4gIGlmICghb3BlcmF0b3IpIHsgcmV0dXJuIHRvOyB9XG4gIHZhciB1ID0gZ2V0VW5pdCh0bykgfHwgMDtcbiAgdmFyIHggPSBwYXJzZUZsb2F0KGZyb20pO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQodG8ucmVwbGFjZShvcGVyYXRvclswXSwgJycpKTtcbiAgc3dpdGNoIChvcGVyYXRvclswXVswXSkge1xuICAgIGNhc2UgJysnOiByZXR1cm4geCArIHkgKyB1O1xuICAgIGNhc2UgJy0nOiByZXR1cm4geCAtIHkgKyB1O1xuICAgIGNhc2UgJyonOiByZXR1cm4geCAqIHkgKyB1O1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVmFsdWUodmFsLCB1bml0KSB7XG4gIGlmIChpcy5jb2wodmFsKSkgeyByZXR1cm4gY29sb3JUb1JnYih2YWwpOyB9XG4gIGlmICgvXFxzL2cudGVzdCh2YWwpKSB7IHJldHVybiB2YWw7IH1cbiAgdmFyIG9yaWdpbmFsVW5pdCA9IGdldFVuaXQodmFsKTtcbiAgdmFyIHVuaXRMZXNzID0gb3JpZ2luYWxVbml0ID8gdmFsLnN1YnN0cigwLCB2YWwubGVuZ3RoIC0gb3JpZ2luYWxVbml0Lmxlbmd0aCkgOiB2YWw7XG4gIGlmICh1bml0KSB7IHJldHVybiB1bml0TGVzcyArIHVuaXQ7IH1cbiAgcmV0dXJuIHVuaXRMZXNzO1xufVxuXG4vLyBnZXRUb3RhbExlbmd0aCgpIGVxdWl2YWxlbnQgZm9yIGNpcmNsZSwgcmVjdCwgcG9seWxpbmUsIHBvbHlnb24gYW5kIGxpbmUgc2hhcGVzXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vU2ViTGFtYmxhLzNlMDU1MGM0OTZjMjM2NzA5NzQ0XG5cbmZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMikge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHAyLnggLSBwMS54LCAyKSArIE1hdGgucG93KHAyLnkgLSBwMS55LCAyKSk7XG59XG5cbmZ1bmN0aW9uIGdldENpcmNsZUxlbmd0aChlbCkge1xuICByZXR1cm4gTWF0aC5QSSAqIDIgKiBnZXRBdHRyaWJ1dGUoZWwsICdyJyk7XG59XG5cbmZ1bmN0aW9uIGdldFJlY3RMZW5ndGgoZWwpIHtcbiAgcmV0dXJuIChnZXRBdHRyaWJ1dGUoZWwsICd3aWR0aCcpICogMikgKyAoZ2V0QXR0cmlidXRlKGVsLCAnaGVpZ2h0JykgKiAyKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGluZUxlbmd0aChlbCkge1xuICByZXR1cm4gZ2V0RGlzdGFuY2UoXG4gICAge3g6IGdldEF0dHJpYnV0ZShlbCwgJ3gxJyksIHk6IGdldEF0dHJpYnV0ZShlbCwgJ3kxJyl9LCBcbiAgICB7eDogZ2V0QXR0cmlidXRlKGVsLCAneDInKSwgeTogZ2V0QXR0cmlidXRlKGVsLCAneTInKX1cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9seWxpbmVMZW5ndGgoZWwpIHtcbiAgdmFyIHBvaW50cyA9IGVsLnBvaW50cztcbiAgdmFyIHRvdGFsTGVuZ3RoID0gMDtcbiAgdmFyIHByZXZpb3VzUG9zO1xuICBmb3IgKHZhciBpID0gMCA7IGkgPCBwb2ludHMubnVtYmVyT2ZJdGVtczsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRQb3MgPSBwb2ludHMuZ2V0SXRlbShpKTtcbiAgICBpZiAoaSA+IDApIHsgdG90YWxMZW5ndGggKz0gZ2V0RGlzdGFuY2UocHJldmlvdXNQb3MsIGN1cnJlbnRQb3MpOyB9XG4gICAgcHJldmlvdXNQb3MgPSBjdXJyZW50UG9zO1xuICB9XG4gIHJldHVybiB0b3RhbExlbmd0aDtcbn1cblxuZnVuY3Rpb24gZ2V0UG9seWdvbkxlbmd0aChlbCkge1xuICB2YXIgcG9pbnRzID0gZWwucG9pbnRzO1xuICByZXR1cm4gZ2V0UG9seWxpbmVMZW5ndGgoZWwpICsgZ2V0RGlzdGFuY2UocG9pbnRzLmdldEl0ZW0ocG9pbnRzLm51bWJlck9mSXRlbXMgLSAxKSwgcG9pbnRzLmdldEl0ZW0oMCkpO1xufVxuXG4vLyBQYXRoIGFuaW1hdGlvblxuXG5mdW5jdGlvbiBnZXRUb3RhbExlbmd0aChlbCkge1xuICBpZiAoZWwuZ2V0VG90YWxMZW5ndGgpIHsgcmV0dXJuIGVsLmdldFRvdGFsTGVuZ3RoKCk7IH1cbiAgc3dpdGNoKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2NpcmNsZSc6IHJldHVybiBnZXRDaXJjbGVMZW5ndGgoZWwpO1xuICAgIGNhc2UgJ3JlY3QnOiByZXR1cm4gZ2V0UmVjdExlbmd0aChlbCk7XG4gICAgY2FzZSAnbGluZSc6IHJldHVybiBnZXRMaW5lTGVuZ3RoKGVsKTtcbiAgICBjYXNlICdwb2x5bGluZSc6IHJldHVybiBnZXRQb2x5bGluZUxlbmd0aChlbCk7XG4gICAgY2FzZSAncG9seWdvbic6IHJldHVybiBnZXRQb2x5Z29uTGVuZ3RoKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXREYXNob2Zmc2V0KGVsKSB7XG4gIHZhciBwYXRoTGVuZ3RoID0gZ2V0VG90YWxMZW5ndGgoZWwpO1xuICBlbC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBwYXRoTGVuZ3RoKTtcbiAgcmV0dXJuIHBhdGhMZW5ndGg7XG59XG5cbi8vIE1vdGlvbiBwYXRoXG5cbmZ1bmN0aW9uIGdldFBhcmVudFN2Z0VsKGVsKSB7XG4gIHZhciBwYXJlbnRFbCA9IGVsLnBhcmVudE5vZGU7XG4gIHdoaWxlIChpcy5zdmcocGFyZW50RWwpKSB7XG4gICAgaWYgKCFpcy5zdmcocGFyZW50RWwucGFyZW50Tm9kZSkpIHsgYnJlYWs7IH1cbiAgICBwYXJlbnRFbCA9IHBhcmVudEVsLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIHBhcmVudEVsO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnRTdmcocGF0aEVsLCBzdmdEYXRhKSB7XG4gIHZhciBzdmcgPSBzdmdEYXRhIHx8IHt9O1xuICB2YXIgcGFyZW50U3ZnRWwgPSBzdmcuZWwgfHwgZ2V0UGFyZW50U3ZnRWwocGF0aEVsKTtcbiAgdmFyIHJlY3QgPSBwYXJlbnRTdmdFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHZpZXdCb3hBdHRyID0gZ2V0QXR0cmlidXRlKHBhcmVudFN2Z0VsLCAndmlld0JveCcpO1xuICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIHZhciB2aWV3Qm94ID0gc3ZnLnZpZXdCb3ggfHwgKHZpZXdCb3hBdHRyID8gdmlld0JveEF0dHIuc3BsaXQoJyAnKSA6IFswLCAwLCB3aWR0aCwgaGVpZ2h0XSk7XG4gIHJldHVybiB7XG4gICAgZWw6IHBhcmVudFN2Z0VsLFxuICAgIHZpZXdCb3g6IHZpZXdCb3gsXG4gICAgeDogdmlld0JveFswXSAvIDEsXG4gICAgeTogdmlld0JveFsxXSAvIDEsXG4gICAgdzogd2lkdGggLyB2aWV3Qm94WzJdLFxuICAgIGg6IGhlaWdodCAvIHZpZXdCb3hbM11cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYXRoKHBhdGgsIHBlcmNlbnQpIHtcbiAgdmFyIHBhdGhFbCA9IGlzLnN0cihwYXRoKSA/IHNlbGVjdFN0cmluZyhwYXRoKVswXSA6IHBhdGg7XG4gIHZhciBwID0gcGVyY2VudCB8fCAxMDA7XG4gIHJldHVybiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIHJldHVybiB7XG4gICAgICBwcm9wZXJ0eTogcHJvcGVydHksXG4gICAgICBlbDogcGF0aEVsLFxuICAgICAgc3ZnOiBnZXRQYXJlbnRTdmcocGF0aEVsKSxcbiAgICAgIHRvdGFsTGVuZ3RoOiBnZXRUb3RhbExlbmd0aChwYXRoRWwpICogKHAgLyAxMDApXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBhdGhQcm9ncmVzcyhwYXRoLCBwcm9ncmVzcykge1xuICBmdW5jdGlvbiBwb2ludChvZmZzZXQpIHtcbiAgICBpZiAoIG9mZnNldCA9PT0gdm9pZCAwICkgb2Zmc2V0ID0gMDtcblxuICAgIHZhciBsID0gcHJvZ3Jlc3MgKyBvZmZzZXQgPj0gMSA/IHByb2dyZXNzICsgb2Zmc2V0IDogMDtcbiAgICByZXR1cm4gcGF0aC5lbC5nZXRQb2ludEF0TGVuZ3RoKGwpO1xuICB9XG4gIHZhciBzdmcgPSBnZXRQYXJlbnRTdmcocGF0aC5lbCwgcGF0aC5zdmcpO1xuICB2YXIgcCA9IHBvaW50KCk7XG4gIHZhciBwMCA9IHBvaW50KC0xKTtcbiAgdmFyIHAxID0gcG9pbnQoKzEpO1xuICBzd2l0Y2ggKHBhdGgucHJvcGVydHkpIHtcbiAgICBjYXNlICd4JzogcmV0dXJuIChwLnggLSBzdmcueCkgKiBzdmcudztcbiAgICBjYXNlICd5JzogcmV0dXJuIChwLnkgLSBzdmcueSkgKiBzdmcuaDtcbiAgICBjYXNlICdhbmdsZSc6IHJldHVybiBNYXRoLmF0YW4yKHAxLnkgLSBwMC55LCBwMS54IC0gcDAueCkgKiAxODAgLyBNYXRoLlBJO1xuICB9XG59XG5cbi8vIERlY29tcG9zZSB2YWx1ZVxuXG5mdW5jdGlvbiBkZWNvbXBvc2VWYWx1ZSh2YWwsIHVuaXQpIHtcbiAgLy8gY29uc3Qgcmd4ID0gLy0/XFxkKlxcLj9cXGQrL2c7IC8vIGhhbmRsZXMgYmFzaWMgbnVtYmVyc1xuICAvLyBjb25zdCByZ3ggPSAvWystXT9cXGQrKD86XFwuXFxkKyk/KD86W2VFXVsrLV0/XFxkKyk/L2c7IC8vIGhhbmRsZXMgZXhwb25lbnRzIG5vdGF0aW9uXG4gIHZhciByZ3ggPSAvWystXT9cXGQqXFwuP1xcZCsoPzpcXC5cXGQrKT8oPzpbZUVdWystXT9cXGQrKT8vZzsgLy8gaGFuZGxlcyBleHBvbmVudHMgbm90YXRpb25cbiAgdmFyIHZhbHVlID0gdmFsaWRhdGVWYWx1ZSgoaXMucHRoKHZhbCkgPyB2YWwudG90YWxMZW5ndGggOiB2YWwpLCB1bml0KSArICcnO1xuICByZXR1cm4ge1xuICAgIG9yaWdpbmFsOiB2YWx1ZSxcbiAgICBudW1iZXJzOiB2YWx1ZS5tYXRjaChyZ3gpID8gdmFsdWUubWF0Y2gocmd4KS5tYXAoTnVtYmVyKSA6IFswXSxcbiAgICBzdHJpbmdzOiAoaXMuc3RyKHZhbCkgfHwgdW5pdCkgPyB2YWx1ZS5zcGxpdChyZ3gpIDogW11cbiAgfVxufVxuXG4vLyBBbmltYXRhYmxlc1xuXG5mdW5jdGlvbiBwYXJzZVRhcmdldHModGFyZ2V0cykge1xuICB2YXIgdGFyZ2V0c0FycmF5ID0gdGFyZ2V0cyA/IChmbGF0dGVuQXJyYXkoaXMuYXJyKHRhcmdldHMpID8gdGFyZ2V0cy5tYXAodG9BcnJheSkgOiB0b0FycmF5KHRhcmdldHMpKSkgOiBbXTtcbiAgcmV0dXJuIGZpbHRlckFycmF5KHRhcmdldHNBcnJheSwgZnVuY3Rpb24gKGl0ZW0sIHBvcywgc2VsZikgeyByZXR1cm4gc2VsZi5pbmRleE9mKGl0ZW0pID09PSBwb3M7IH0pO1xufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRhYmxlcyh0YXJnZXRzKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZVRhcmdldHModGFyZ2V0cyk7XG4gIHJldHVybiBwYXJzZWQubWFwKGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgcmV0dXJuIHt0YXJnZXQ6IHQsIGlkOiBpLCB0b3RhbDogcGFyc2VkLmxlbmd0aCwgdHJhbnNmb3JtczogeyBsaXN0OiBnZXRFbGVtZW50VHJhbnNmb3Jtcyh0KSB9IH07XG4gIH0pO1xufVxuXG4vLyBQcm9wZXJ0aWVzXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BlcnR5VHdlZW5zKHByb3AsIHR3ZWVuU2V0dGluZ3MpIHtcbiAgdmFyIHNldHRpbmdzID0gY2xvbmVPYmplY3QodHdlZW5TZXR0aW5ncyk7XG4gIC8vIE92ZXJyaWRlIGR1cmF0aW9uIGlmIGVhc2luZyBpcyBhIHNwcmluZ1xuICBpZiAoL15zcHJpbmcvLnRlc3Qoc2V0dGluZ3MuZWFzaW5nKSkgeyBzZXR0aW5ncy5kdXJhdGlvbiA9IHNwcmluZyhzZXR0aW5ncy5lYXNpbmcpOyB9XG4gIGlmIChpcy5hcnIocHJvcCkpIHtcbiAgICB2YXIgbCA9IHByb3AubGVuZ3RoO1xuICAgIHZhciBpc0Zyb21UbyA9IChsID09PSAyICYmICFpcy5vYmoocHJvcFswXSkpO1xuICAgIGlmICghaXNGcm9tVG8pIHtcbiAgICAgIC8vIER1cmF0aW9uIGRpdmlkZWQgYnkgdGhlIG51bWJlciBvZiB0d2VlbnNcbiAgICAgIGlmICghaXMuZm5jKHR3ZWVuU2V0dGluZ3MuZHVyYXRpb24pKSB7IHNldHRpbmdzLmR1cmF0aW9uID0gdHdlZW5TZXR0aW5ncy5kdXJhdGlvbiAvIGw7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJhbnNmb3JtIFtmcm9tLCB0b10gdmFsdWVzIHNob3J0aGFuZCB0byBhIHZhbGlkIHR3ZWVuIHZhbHVlXG4gICAgICBwcm9wID0ge3ZhbHVlOiBwcm9wfTtcbiAgICB9XG4gIH1cbiAgdmFyIHByb3BBcnJheSA9IGlzLmFycihwcm9wKSA/IHByb3AgOiBbcHJvcF07XG4gIHJldHVybiBwcm9wQXJyYXkubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgdmFyIG9iaiA9IChpcy5vYmoodikgJiYgIWlzLnB0aCh2KSkgPyB2IDoge3ZhbHVlOiB2fTtcbiAgICAvLyBEZWZhdWx0IGRlbGF5IHZhbHVlIHNob3VsZCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGZpcnN0IHR3ZWVuXG4gICAgaWYgKGlzLnVuZChvYmouZGVsYXkpKSB7IG9iai5kZWxheSA9ICFpID8gdHdlZW5TZXR0aW5ncy5kZWxheSA6IDA7IH1cbiAgICAvLyBEZWZhdWx0IGVuZERlbGF5IHZhbHVlIHNob3VsZCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGxhc3QgdHdlZW5cbiAgICBpZiAoaXMudW5kKG9iai5lbmREZWxheSkpIHsgb2JqLmVuZERlbGF5ID0gaSA9PT0gcHJvcEFycmF5Lmxlbmd0aCAtIDEgPyB0d2VlblNldHRpbmdzLmVuZERlbGF5IDogMDsgfVxuICAgIHJldHVybiBvYmo7XG4gIH0pLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gbWVyZ2VPYmplY3RzKGssIHNldHRpbmdzKTsgfSk7XG59XG5cblxuZnVuY3Rpb24gZmxhdHRlbktleWZyYW1lcyhrZXlmcmFtZXMpIHtcbiAgdmFyIHByb3BlcnR5TmFtZXMgPSBmaWx0ZXJBcnJheShmbGF0dGVuQXJyYXkoa2V5ZnJhbWVzLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBPYmplY3Qua2V5cyhrZXkpOyB9KSksIGZ1bmN0aW9uIChwKSB7IHJldHVybiBpcy5rZXkocCk7IH0pXG4gIC5yZWR1Y2UoZnVuY3Rpb24gKGEsYikgeyBpZiAoYS5pbmRleE9mKGIpIDwgMCkgeyBhLnB1c2goYik7IH0gcmV0dXJuIGE7IH0sIFtdKTtcbiAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlOYW1lc1tpXTtcbiAgICBwcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IGtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG5ld0tleSA9IHt9O1xuICAgICAgZm9yICh2YXIgcCBpbiBrZXkpIHtcbiAgICAgICAgaWYgKGlzLmtleShwKSkge1xuICAgICAgICAgIGlmIChwID09IHByb3BOYW1lKSB7IG5ld0tleS52YWx1ZSA9IGtleVtwXTsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0tleVtwXSA9IGtleVtwXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0tleTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnR5TmFtZXMubGVuZ3RoOyBpKyspIGxvb3AoIGkgKTtcbiAgcmV0dXJuIHByb3BlcnRpZXM7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnRpZXModHdlZW5TZXR0aW5ncywgcGFyYW1zKSB7XG4gIHZhciBwcm9wZXJ0aWVzID0gW107XG4gIHZhciBrZXlmcmFtZXMgPSBwYXJhbXMua2V5ZnJhbWVzO1xuICBpZiAoa2V5ZnJhbWVzKSB7IHBhcmFtcyA9IG1lcmdlT2JqZWN0cyhmbGF0dGVuS2V5ZnJhbWVzKGtleWZyYW1lcyksIHBhcmFtcyk7IH1cbiAgZm9yICh2YXIgcCBpbiBwYXJhbXMpIHtcbiAgICBpZiAoaXMua2V5KHApKSB7XG4gICAgICBwcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgICBuYW1lOiBwLFxuICAgICAgICB0d2VlbnM6IG5vcm1hbGl6ZVByb3BlcnR5VHdlZW5zKHBhcmFtc1twXSwgdHdlZW5TZXR0aW5ncylcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcGVydGllcztcbn1cblxuLy8gVHdlZW5zXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVR3ZWVuVmFsdWVzKHR3ZWVuLCBhbmltYXRhYmxlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gdHdlZW4pIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRGdW5jdGlvblZhbHVlKHR3ZWVuW3BdLCBhbmltYXRhYmxlKTtcbiAgICBpZiAoaXMuYXJyKHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGdldEZ1bmN0aW9uVmFsdWUodiwgYW5pbWF0YWJsZSk7IH0pO1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMSkgeyB2YWx1ZSA9IHZhbHVlWzBdOyB9XG4gICAgfVxuICAgIHRbcF0gPSB2YWx1ZTtcbiAgfVxuICB0LmR1cmF0aW9uID0gcGFyc2VGbG9hdCh0LmR1cmF0aW9uKTtcbiAgdC5kZWxheSA9IHBhcnNlRmxvYXQodC5kZWxheSk7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVUd2VlbnMocHJvcCwgYW5pbWF0YWJsZSkge1xuICB2YXIgcHJldmlvdXNUd2VlbjtcbiAgcmV0dXJuIHByb3AudHdlZW5zLm1hcChmdW5jdGlvbiAodCkge1xuICAgIHZhciB0d2VlbiA9IG5vcm1hbGl6ZVR3ZWVuVmFsdWVzKHQsIGFuaW1hdGFibGUpO1xuICAgIHZhciB0d2VlblZhbHVlID0gdHdlZW4udmFsdWU7XG4gICAgdmFyIHRvID0gaXMuYXJyKHR3ZWVuVmFsdWUpID8gdHdlZW5WYWx1ZVsxXSA6IHR3ZWVuVmFsdWU7XG4gICAgdmFyIHRvVW5pdCA9IGdldFVuaXQodG8pO1xuICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZShhbmltYXRhYmxlLnRhcmdldCwgcHJvcC5uYW1lLCB0b1VuaXQsIGFuaW1hdGFibGUpO1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gcHJldmlvdXNUd2VlbiA/IHByZXZpb3VzVHdlZW4udG8ub3JpZ2luYWwgOiBvcmlnaW5hbFZhbHVlO1xuICAgIHZhciBmcm9tID0gaXMuYXJyKHR3ZWVuVmFsdWUpID8gdHdlZW5WYWx1ZVswXSA6IHByZXZpb3VzVmFsdWU7XG4gICAgdmFyIGZyb21Vbml0ID0gZ2V0VW5pdChmcm9tKSB8fCBnZXRVbml0KG9yaWdpbmFsVmFsdWUpO1xuICAgIHZhciB1bml0ID0gdG9Vbml0IHx8IGZyb21Vbml0O1xuICAgIGlmIChpcy51bmQodG8pKSB7IHRvID0gcHJldmlvdXNWYWx1ZTsgfVxuICAgIHR3ZWVuLmZyb20gPSBkZWNvbXBvc2VWYWx1ZShmcm9tLCB1bml0KTtcbiAgICB0d2Vlbi50byA9IGRlY29tcG9zZVZhbHVlKGdldFJlbGF0aXZlVmFsdWUodG8sIGZyb20pLCB1bml0KTtcbiAgICB0d2Vlbi5zdGFydCA9IHByZXZpb3VzVHdlZW4gPyBwcmV2aW91c1R3ZWVuLmVuZCA6IDA7XG4gICAgdHdlZW4uZW5kID0gdHdlZW4uc3RhcnQgKyB0d2Vlbi5kZWxheSArIHR3ZWVuLmR1cmF0aW9uICsgdHdlZW4uZW5kRGVsYXk7XG4gICAgdHdlZW4uZWFzaW5nID0gcGFyc2VFYXNpbmdzKHR3ZWVuLmVhc2luZywgdHdlZW4uZHVyYXRpb24pO1xuICAgIHR3ZWVuLmlzUGF0aCA9IGlzLnB0aCh0d2VlblZhbHVlKTtcbiAgICB0d2Vlbi5pc0NvbG9yID0gaXMuY29sKHR3ZWVuLmZyb20ub3JpZ2luYWwpO1xuICAgIGlmICh0d2Vlbi5pc0NvbG9yKSB7IHR3ZWVuLnJvdW5kID0gMTsgfVxuICAgIHByZXZpb3VzVHdlZW4gPSB0d2VlbjtcbiAgICByZXR1cm4gdHdlZW47XG4gIH0pO1xufVxuXG4vLyBUd2VlbiBwcm9ncmVzc1xuXG52YXIgc2V0UHJvZ3Jlc3NWYWx1ZSA9IHtcbiAgY3NzOiBmdW5jdGlvbiAodCwgcCwgdikgeyByZXR1cm4gdC5zdHlsZVtwXSA9IHY7IH0sXG4gIGF0dHJpYnV0ZTogZnVuY3Rpb24gKHQsIHAsIHYpIHsgcmV0dXJuIHQuc2V0QXR0cmlidXRlKHAsIHYpOyB9LFxuICBvYmplY3Q6IGZ1bmN0aW9uICh0LCBwLCB2KSB7IHJldHVybiB0W3BdID0gdjsgfSxcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiAodCwgcCwgdiwgdHJhbnNmb3JtcywgbWFudWFsKSB7XG4gICAgdHJhbnNmb3Jtcy5saXN0LnNldChwLCB2KTtcbiAgICBpZiAocCA9PT0gdHJhbnNmb3Jtcy5sYXN0IHx8IG1hbnVhbCkge1xuICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgdHJhbnNmb3Jtcy5saXN0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBwcm9wKSB7IHN0ciArPSBwcm9wICsgXCIoXCIgKyB2YWx1ZSArIFwiKSBcIjsgfSk7XG4gICAgICB0LnN0eWxlLnRyYW5zZm9ybSA9IHN0cjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIFNldCBWYWx1ZSBoZWxwZXJcblxuZnVuY3Rpb24gc2V0VGFyZ2V0c1ZhbHVlKHRhcmdldHMsIHByb3BlcnRpZXMpIHtcbiAgdmFyIGFuaW1hdGFibGVzID0gZ2V0QW5pbWF0YWJsZXModGFyZ2V0cyk7XG4gIGFuaW1hdGFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGFibGUpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRGdW5jdGlvblZhbHVlKHByb3BlcnRpZXNbcHJvcGVydHldLCBhbmltYXRhYmxlKTtcbiAgICAgIHZhciB0YXJnZXQgPSBhbmltYXRhYmxlLnRhcmdldDtcbiAgICAgIHZhciB2YWx1ZVVuaXQgPSBnZXRVbml0KHZhbHVlKTtcbiAgICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZVVuaXQsIGFuaW1hdGFibGUpO1xuICAgICAgdmFyIHVuaXQgPSB2YWx1ZVVuaXQgfHwgZ2V0VW5pdChvcmlnaW5hbFZhbHVlKTtcbiAgICAgIHZhciB0byA9IGdldFJlbGF0aXZlVmFsdWUodmFsaWRhdGVWYWx1ZSh2YWx1ZSwgdW5pdCksIG9yaWdpbmFsVmFsdWUpO1xuICAgICAgdmFyIGFuaW1UeXBlID0gZ2V0QW5pbWF0aW9uVHlwZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIHNldFByb2dyZXNzVmFsdWVbYW5pbVR5cGVdKHRhcmdldCwgcHJvcGVydHksIHRvLCBhbmltYXRhYmxlLnRyYW5zZm9ybXMsIHRydWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIEFuaW1hdGlvbnNcblxuZnVuY3Rpb24gY3JlYXRlQW5pbWF0aW9uKGFuaW1hdGFibGUsIHByb3ApIHtcbiAgdmFyIGFuaW1UeXBlID0gZ2V0QW5pbWF0aW9uVHlwZShhbmltYXRhYmxlLnRhcmdldCwgcHJvcC5uYW1lKTtcbiAgaWYgKGFuaW1UeXBlKSB7XG4gICAgdmFyIHR3ZWVucyA9IG5vcm1hbGl6ZVR3ZWVucyhwcm9wLCBhbmltYXRhYmxlKTtcbiAgICB2YXIgbGFzdFR3ZWVuID0gdHdlZW5zW3R3ZWVucy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogYW5pbVR5cGUsXG4gICAgICBwcm9wZXJ0eTogcHJvcC5uYW1lLFxuICAgICAgYW5pbWF0YWJsZTogYW5pbWF0YWJsZSxcbiAgICAgIHR3ZWVuczogdHdlZW5zLFxuICAgICAgZHVyYXRpb246IGxhc3RUd2Vlbi5lbmQsXG4gICAgICBkZWxheTogdHdlZW5zWzBdLmRlbGF5LFxuICAgICAgZW5kRGVsYXk6IGxhc3RUd2Vlbi5lbmREZWxheVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRpb25zKGFuaW1hdGFibGVzLCBwcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBmaWx0ZXJBcnJheShmbGF0dGVuQXJyYXkoYW5pbWF0YWJsZXMubWFwKGZ1bmN0aW9uIChhbmltYXRhYmxlKSB7XG4gICAgcmV0dXJuIHByb3BlcnRpZXMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQW5pbWF0aW9uKGFuaW1hdGFibGUsIHByb3ApO1xuICAgIH0pO1xuICB9KSksIGZ1bmN0aW9uIChhKSB7IHJldHVybiAhaXMudW5kKGEpOyB9KTtcbn1cblxuLy8gQ3JlYXRlIEluc3RhbmNlXG5cbmZ1bmN0aW9uIGdldEluc3RhbmNlVGltaW5ncyhhbmltYXRpb25zLCB0d2VlblNldHRpbmdzKSB7XG4gIHZhciBhbmltTGVuZ3RoID0gYW5pbWF0aW9ucy5sZW5ndGg7XG4gIHZhciBnZXRUbE9mZnNldCA9IGZ1bmN0aW9uIChhbmltKSB7IHJldHVybiBhbmltLnRpbWVsaW5lT2Zmc2V0ID8gYW5pbS50aW1lbGluZU9mZnNldCA6IDA7IH07XG4gIHZhciB0aW1pbmdzID0ge307XG4gIHRpbWluZ3MuZHVyYXRpb24gPSBhbmltTGVuZ3RoID8gTWF0aC5tYXguYXBwbHkoTWF0aCwgYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGdldFRsT2Zmc2V0KGFuaW0pICsgYW5pbS5kdXJhdGlvbjsgfSkpIDogdHdlZW5TZXR0aW5ncy5kdXJhdGlvbjtcbiAgdGltaW5ncy5kZWxheSA9IGFuaW1MZW5ndGggPyBNYXRoLm1pbi5hcHBseShNYXRoLCBhbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gZ2V0VGxPZmZzZXQoYW5pbSkgKyBhbmltLmRlbGF5OyB9KSkgOiB0d2VlblNldHRpbmdzLmRlbGF5O1xuICB0aW1pbmdzLmVuZERlbGF5ID0gYW5pbUxlbmd0aCA/IHRpbWluZ3MuZHVyYXRpb24gLSBNYXRoLm1heC5hcHBseShNYXRoLCBhbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gZ2V0VGxPZmZzZXQoYW5pbSkgKyBhbmltLmR1cmF0aW9uIC0gYW5pbS5lbmREZWxheTsgfSkpIDogdHdlZW5TZXR0aW5ncy5lbmREZWxheTtcbiAgcmV0dXJuIHRpbWluZ3M7XG59XG5cbnZhciBpbnN0YW5jZUlEID0gMDtcblxuZnVuY3Rpb24gY3JlYXRlTmV3SW5zdGFuY2UocGFyYW1zKSB7XG4gIHZhciBpbnN0YW5jZVNldHRpbmdzID0gcmVwbGFjZU9iamVjdFByb3BzKGRlZmF1bHRJbnN0YW5jZVNldHRpbmdzLCBwYXJhbXMpO1xuICB2YXIgdHdlZW5TZXR0aW5ncyA9IHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0VHdlZW5TZXR0aW5ncywgcGFyYW1zKTtcbiAgdmFyIHByb3BlcnRpZXMgPSBnZXRQcm9wZXJ0aWVzKHR3ZWVuU2V0dGluZ3MsIHBhcmFtcyk7XG4gIHZhciBhbmltYXRhYmxlcyA9IGdldEFuaW1hdGFibGVzKHBhcmFtcy50YXJnZXRzKTtcbiAgdmFyIGFuaW1hdGlvbnMgPSBnZXRBbmltYXRpb25zKGFuaW1hdGFibGVzLCBwcm9wZXJ0aWVzKTtcbiAgdmFyIHRpbWluZ3MgPSBnZXRJbnN0YW5jZVRpbWluZ3MoYW5pbWF0aW9ucywgdHdlZW5TZXR0aW5ncyk7XG4gIHZhciBpZCA9IGluc3RhbmNlSUQ7XG4gIGluc3RhbmNlSUQrKztcbiAgcmV0dXJuIG1lcmdlT2JqZWN0cyhpbnN0YW5jZVNldHRpbmdzLCB7XG4gICAgaWQ6IGlkLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBhbmltYXRhYmxlczogYW5pbWF0YWJsZXMsXG4gICAgYW5pbWF0aW9uczogYW5pbWF0aW9ucyxcbiAgICBkdXJhdGlvbjogdGltaW5ncy5kdXJhdGlvbixcbiAgICBkZWxheTogdGltaW5ncy5kZWxheSxcbiAgICBlbmREZWxheTogdGltaW5ncy5lbmREZWxheVxuICB9KTtcbn1cblxuLy8gQ29yZVxuXG52YXIgYWN0aXZlSW5zdGFuY2VzID0gW107XG52YXIgcGF1c2VkSW5zdGFuY2VzID0gW107XG52YXIgcmFmO1xuXG52YXIgZW5naW5lID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gcGxheSgpIHsgXG4gICAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICB9XG4gIGZ1bmN0aW9uIHN0ZXAodCkge1xuICAgIHZhciBhY3RpdmVJbnN0YW5jZXNMZW5ndGggPSBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoO1xuICAgIGlmIChhY3RpdmVJbnN0YW5jZXNMZW5ndGgpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgYWN0aXZlSW5zdGFuY2VzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlc1tpXTtcbiAgICAgICAgaWYgKCFhY3RpdmVJbnN0YW5jZS5wYXVzZWQpIHtcbiAgICAgICAgICBhY3RpdmVJbnN0YW5jZS50aWNrKHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpbnN0YW5jZUluZGV4ID0gYWN0aXZlSW5zdGFuY2VzLmluZGV4T2YoYWN0aXZlSW5zdGFuY2UpO1xuICAgICAgICAgIGlmIChpbnN0YW5jZUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGFjdGl2ZUluc3RhbmNlcy5zcGxpY2UoaW5zdGFuY2VJbmRleCwgMSk7XG4gICAgICAgICAgICBhY3RpdmVJbnN0YW5jZXNMZW5ndGggPSBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBwbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhZiA9IGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG4gICAgfVxuICB9XG4gIHJldHVybiBwbGF5O1xufSkoKTtcblxuZnVuY3Rpb24gaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgIGFjdGl2ZUluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnMpIHsgcmV0dXJuIGlucy5wYXVzZSgpOyB9KTtcbiAgICBwYXVzZWRJbnN0YW5jZXMgPSBhY3RpdmVJbnN0YW5jZXMuc2xpY2UoMCk7XG4gICAgYW5pbWUucnVubmluZyA9IGFjdGl2ZUluc3RhbmNlcyA9IFtdO1xuICB9IGVsc2Uge1xuICAgIHBhdXNlZEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnMpIHsgcmV0dXJuIGlucy5wbGF5KCk7IH0pO1xuICB9XG59XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbn1cblxuLy8gUHVibGljIEluc3RhbmNlXG5cbmZ1bmN0aW9uIGFuaW1lKHBhcmFtcykge1xuICBpZiAoIHBhcmFtcyA9PT0gdm9pZCAwICkgcGFyYW1zID0ge307XG5cblxuICB2YXIgc3RhcnRUaW1lID0gMCwgbGFzdFRpbWUgPSAwLCBub3cgPSAwO1xuICB2YXIgY2hpbGRyZW4sIGNoaWxkcmVuTGVuZ3RoID0gMDtcbiAgdmFyIHJlc29sdmUgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIG1ha2VQcm9taXNlKGluc3RhbmNlKSB7XG4gICAgdmFyIHByb21pc2UgPSB3aW5kb3cuUHJvbWlzZSAmJiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoX3Jlc29sdmUpIHsgcmV0dXJuIHJlc29sdmUgPSBfcmVzb2x2ZTsgfSk7XG4gICAgaW5zdGFuY2UuZmluaXNoZWQgPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gY3JlYXRlTmV3SW5zdGFuY2UocGFyYW1zKTtcbiAgdmFyIHByb21pc2UgPSBtYWtlUHJvbWlzZShpbnN0YW5jZSk7XG5cbiAgZnVuY3Rpb24gdG9nZ2xlSW5zdGFuY2VEaXJlY3Rpb24oKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGluc3RhbmNlLmRpcmVjdGlvbjtcbiAgICBpZiAoZGlyZWN0aW9uICE9PSAnYWx0ZXJuYXRlJykge1xuICAgICAgaW5zdGFuY2UuZGlyZWN0aW9uID0gZGlyZWN0aW9uICE9PSAnbm9ybWFsJyA/ICdub3JtYWwnIDogJ3JldmVyc2UnO1xuICAgIH1cbiAgICBpbnN0YW5jZS5yZXZlcnNlZCA9ICFpbnN0YW5jZS5yZXZlcnNlZDtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQucmV2ZXJzZWQgPSBpbnN0YW5jZS5yZXZlcnNlZDsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGp1c3RUaW1lKHRpbWUpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UucmV2ZXJzZWQgPyBpbnN0YW5jZS5kdXJhdGlvbiAtIHRpbWUgOiB0aW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUaW1lKCkge1xuICAgIHN0YXJ0VGltZSA9IDA7XG4gICAgbGFzdFRpbWUgPSBhZGp1c3RUaW1lKGluc3RhbmNlLmN1cnJlbnRUaW1lKSAqICgxIC8gYW5pbWUuc3BlZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2Vla0NoaWxkKHRpbWUsIGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkKSB7IGNoaWxkLnNlZWsodGltZSAtIGNoaWxkLnRpbWVsaW5lT2Zmc2V0KTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3luY0luc3RhbmNlQ2hpbGRyZW4odGltZSkge1xuICAgIGlmICghaW5zdGFuY2UucmV2ZXJzZVBsYXliYWNrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHsgc2Vla0NoaWxkKHRpbWUsIGNoaWxkcmVuW2ldKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSBjaGlsZHJlbkxlbmd0aDsgaSQxLS07KSB7IHNlZWtDaGlsZCh0aW1lLCBjaGlsZHJlbltpJDFdKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEFuaW1hdGlvbnNQcm9ncmVzcyhpbnNUaW1lKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBhbmltYXRpb25zID0gaW5zdGFuY2UuYW5pbWF0aW9ucztcbiAgICB2YXIgYW5pbWF0aW9uc0xlbmd0aCA9IGFuaW1hdGlvbnMubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgYW5pbWF0aW9uc0xlbmd0aCkge1xuICAgICAgdmFyIGFuaW0gPSBhbmltYXRpb25zW2ldO1xuICAgICAgdmFyIGFuaW1hdGFibGUgPSBhbmltLmFuaW1hdGFibGU7XG4gICAgICB2YXIgdHdlZW5zID0gYW5pbS50d2VlbnM7XG4gICAgICB2YXIgdHdlZW5MZW5ndGggPSB0d2VlbnMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciB0d2VlbiA9IHR3ZWVuc1t0d2Vlbkxlbmd0aF07XG4gICAgICAvLyBPbmx5IGNoZWNrIGZvciBrZXlmcmFtZXMgaWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSB0d2VlblxuICAgICAgaWYgKHR3ZWVuTGVuZ3RoKSB7IHR3ZWVuID0gZmlsdGVyQXJyYXkodHdlZW5zLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gKGluc1RpbWUgPCB0LmVuZCk7IH0pWzBdIHx8IHR3ZWVuOyB9XG4gICAgICB2YXIgZWxhcHNlZCA9IG1pbk1heChpbnNUaW1lIC0gdHdlZW4uc3RhcnQgLSB0d2Vlbi5kZWxheSwgMCwgdHdlZW4uZHVyYXRpb24pIC8gdHdlZW4uZHVyYXRpb247XG4gICAgICB2YXIgZWFzZWQgPSBpc05hTihlbGFwc2VkKSA/IDEgOiB0d2Vlbi5lYXNpbmcoZWxhcHNlZCk7XG4gICAgICB2YXIgc3RyaW5ncyA9IHR3ZWVuLnRvLnN0cmluZ3M7XG4gICAgICB2YXIgcm91bmQgPSB0d2Vlbi5yb3VuZDtcbiAgICAgIHZhciBudW1iZXJzID0gW107XG4gICAgICB2YXIgdG9OdW1iZXJzTGVuZ3RoID0gdHdlZW4udG8ubnVtYmVycy5sZW5ndGg7XG4gICAgICB2YXIgcHJvZ3Jlc3MgPSAodm9pZCAwKTtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdG9OdW1iZXJzTGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gKHZvaWQgMCk7XG4gICAgICAgIHZhciB0b051bWJlciA9IHR3ZWVuLnRvLm51bWJlcnNbbl07XG4gICAgICAgIHZhciBmcm9tTnVtYmVyID0gdHdlZW4uZnJvbS5udW1iZXJzW25dIHx8IDA7XG4gICAgICAgIGlmICghdHdlZW4uaXNQYXRoKSB7XG4gICAgICAgICAgdmFsdWUgPSBmcm9tTnVtYmVyICsgKGVhc2VkICogKHRvTnVtYmVyIC0gZnJvbU51bWJlcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gZ2V0UGF0aFByb2dyZXNzKHR3ZWVuLnZhbHVlLCBlYXNlZCAqIHRvTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91bmQpIHtcbiAgICAgICAgICBpZiAoISh0d2Vlbi5pc0NvbG9yICYmIG4gPiAyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogcm91bmQpIC8gcm91bmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bWJlcnMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBNYW51YWwgQXJyYXkucmVkdWNlIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VzXG4gICAgICB2YXIgc3RyaW5nc0xlbmd0aCA9IHN0cmluZ3MubGVuZ3RoO1xuICAgICAgaWYgKCFzdHJpbmdzTGVuZ3RoKSB7XG4gICAgICAgIHByb2dyZXNzID0gbnVtYmVyc1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2dyZXNzID0gc3RyaW5nc1swXTtcbiAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzdHJpbmdzTGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICB2YXIgYSA9IHN0cmluZ3Nbc107XG4gICAgICAgICAgdmFyIGIgPSBzdHJpbmdzW3MgKyAxXTtcbiAgICAgICAgICB2YXIgbiQxID0gbnVtYmVyc1tzXTtcbiAgICAgICAgICBpZiAoIWlzTmFOKG4kMSkpIHtcbiAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICBwcm9ncmVzcyArPSBuJDEgKyAnICc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcm9ncmVzcyArPSBuJDEgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0UHJvZ3Jlc3NWYWx1ZVthbmltLnR5cGVdKGFuaW1hdGFibGUudGFyZ2V0LCBhbmltLnByb3BlcnR5LCBwcm9ncmVzcywgYW5pbWF0YWJsZS50cmFuc2Zvcm1zKTtcbiAgICAgIGFuaW0uY3VycmVudFZhbHVlID0gcHJvZ3Jlc3M7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q2FsbGJhY2soY2IpIHtcbiAgICBpZiAoaW5zdGFuY2VbY2JdICYmICFpbnN0YW5jZS5wYXNzVGhyb3VnaCkgeyBpbnN0YW5jZVtjYl0oaW5zdGFuY2UpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3VudEl0ZXJhdGlvbigpIHtcbiAgICBpZiAoaW5zdGFuY2UucmVtYWluaW5nICYmIGluc3RhbmNlLnJlbWFpbmluZyAhPT0gdHJ1ZSkge1xuICAgICAgaW5zdGFuY2UucmVtYWluaW5nLS07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0SW5zdGFuY2VQcm9ncmVzcyhlbmdpbmVUaW1lKSB7XG4gICAgdmFyIGluc0R1cmF0aW9uID0gaW5zdGFuY2UuZHVyYXRpb247XG4gICAgdmFyIGluc0RlbGF5ID0gaW5zdGFuY2UuZGVsYXk7XG4gICAgdmFyIGluc0VuZERlbGF5ID0gaW5zRHVyYXRpb24gLSBpbnN0YW5jZS5lbmREZWxheTtcbiAgICB2YXIgaW5zVGltZSA9IGFkanVzdFRpbWUoZW5naW5lVGltZSk7XG4gICAgaW5zdGFuY2UucHJvZ3Jlc3MgPSBtaW5NYXgoKGluc1RpbWUgLyBpbnNEdXJhdGlvbikgKiAxMDAsIDAsIDEwMCk7XG4gICAgaW5zdGFuY2UucmV2ZXJzZVBsYXliYWNrID0gaW5zVGltZSA8IGluc3RhbmNlLmN1cnJlbnRUaW1lO1xuICAgIGlmIChjaGlsZHJlbikgeyBzeW5jSW5zdGFuY2VDaGlsZHJlbihpbnNUaW1lKTsgfVxuICAgIGlmICghaW5zdGFuY2UuYmVnYW4gJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgPiAwKSB7XG4gICAgICBpbnN0YW5jZS5iZWdhbiA9IHRydWU7XG4gICAgICBzZXRDYWxsYmFjaygnYmVnaW4nKTtcbiAgICB9XG4gICAgaWYgKCFpbnN0YW5jZS5sb29wQmVnYW4gJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgPiAwKSB7XG4gICAgICBpbnN0YW5jZS5sb29wQmVnYW4gPSB0cnVlO1xuICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BCZWdpbicpO1xuICAgIH1cbiAgICBpZiAoaW5zVGltZSA8PSBpbnNEZWxheSAmJiBpbnN0YW5jZS5jdXJyZW50VGltZSAhPT0gMCkge1xuICAgICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKDApO1xuICAgIH1cbiAgICBpZiAoKGluc1RpbWUgPj0gaW5zRW5kRGVsYXkgJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgIT09IGluc0R1cmF0aW9uKSB8fCAhaW5zRHVyYXRpb24pIHtcbiAgICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcyhpbnNEdXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChpbnNUaW1lID4gaW5zRGVsYXkgJiYgaW5zVGltZSA8IGluc0VuZERlbGF5KSB7XG4gICAgICBpZiAoIWluc3RhbmNlLmNoYW5nZUJlZ2FuKSB7XG4gICAgICAgIGluc3RhbmNlLmNoYW5nZUJlZ2FuID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHNldENhbGxiYWNrKCdjaGFuZ2VCZWdpbicpO1xuICAgICAgfVxuICAgICAgc2V0Q2FsbGJhY2soJ2NoYW5nZScpO1xuICAgICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc1RpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5zdGFuY2UuY2hhbmdlQmVnYW4pIHtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQmVnYW4gPSBmYWxzZTtcbiAgICAgICAgc2V0Q2FsbGJhY2soJ2NoYW5nZUNvbXBsZXRlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLmN1cnJlbnRUaW1lID0gbWluTWF4KGluc1RpbWUsIDAsIGluc0R1cmF0aW9uKTtcbiAgICBpZiAoaW5zdGFuY2UuYmVnYW4pIHsgc2V0Q2FsbGJhY2soJ3VwZGF0ZScpOyB9XG4gICAgaWYgKGVuZ2luZVRpbWUgPj0gaW5zRHVyYXRpb24pIHtcbiAgICAgIGxhc3RUaW1lID0gMDtcbiAgICAgIGNvdW50SXRlcmF0aW9uKCk7XG4gICAgICBpZiAoIWluc3RhbmNlLnJlbWFpbmluZykge1xuICAgICAgICBpbnN0YW5jZS5wYXVzZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWluc3RhbmNlLmNvbXBsZXRlZCkge1xuICAgICAgICAgIGluc3RhbmNlLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BDb21wbGV0ZScpO1xuICAgICAgICAgIHNldENhbGxiYWNrKCdjb21wbGV0ZScpO1xuICAgICAgICAgIGlmICghaW5zdGFuY2UucGFzc1Rocm91Z2ggJiYgJ1Byb21pc2UnIGluIHdpbmRvdykge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgcHJvbWlzZSA9IG1ha2VQcm9taXNlKGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0VGltZSA9IG5vdztcbiAgICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BDb21wbGV0ZScpO1xuICAgICAgICBpbnN0YW5jZS5sb29wQmVnYW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKGluc3RhbmNlLmRpcmVjdGlvbiA9PT0gJ2FsdGVybmF0ZScpIHtcbiAgICAgICAgICB0b2dnbGVJbnN0YW5jZURpcmVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5zdGFuY2UucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gaW5zdGFuY2UuZGlyZWN0aW9uO1xuICAgIGluc3RhbmNlLnBhc3NUaHJvdWdoID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY3VycmVudFRpbWUgPSAwO1xuICAgIGluc3RhbmNlLnByb2dyZXNzID0gMDtcbiAgICBpbnN0YW5jZS5wYXVzZWQgPSB0cnVlO1xuICAgIGluc3RhbmNlLmJlZ2FuID0gZmFsc2U7XG4gICAgaW5zdGFuY2UubG9vcEJlZ2FuID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY2hhbmdlQmVnYW4gPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5jaGFuZ2VDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5yZXZlcnNlUGxheWJhY2sgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5yZXZlcnNlZCA9IGRpcmVjdGlvbiA9PT0gJ3JldmVyc2UnO1xuICAgIGluc3RhbmNlLnJlbWFpbmluZyA9IGluc3RhbmNlLmxvb3A7XG4gICAgY2hpbGRyZW4gPSBpbnN0YW5jZS5jaGlsZHJlbjtcbiAgICBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gY2hpbGRyZW5MZW5ndGg7IGktLTspIHsgaW5zdGFuY2UuY2hpbGRyZW5baV0ucmVzZXQoKTsgfVxuICAgIGlmIChpbnN0YW5jZS5yZXZlcnNlZCAmJiBpbnN0YW5jZS5sb29wICE9PSB0cnVlIHx8IChkaXJlY3Rpb24gPT09ICdhbHRlcm5hdGUnICYmIGluc3RhbmNlLmxvb3AgPT09IDEpKSB7IGluc3RhbmNlLnJlbWFpbmluZysrOyB9XG4gICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc3RhbmNlLnJldmVyc2VkID8gaW5zdGFuY2UuZHVyYXRpb24gOiAwKTtcbiAgfTtcblxuICAvLyBTZXQgVmFsdWUgaGVscGVyXG5cbiAgaW5zdGFuY2Uuc2V0ID0gZnVuY3Rpb24odGFyZ2V0cywgcHJvcGVydGllcykge1xuICAgIHNldFRhcmdldHNWYWx1ZSh0YXJnZXRzLCBwcm9wZXJ0aWVzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgaW5zdGFuY2UudGljayA9IGZ1bmN0aW9uKHQpIHtcbiAgICBub3cgPSB0O1xuICAgIGlmICghc3RhcnRUaW1lKSB7IHN0YXJ0VGltZSA9IG5vdzsgfVxuICAgIHNldEluc3RhbmNlUHJvZ3Jlc3MoKG5vdyArIChsYXN0VGltZSAtIHN0YXJ0VGltZSkpICogYW5pbWUuc3BlZWQpO1xuICB9O1xuXG4gIGluc3RhbmNlLnNlZWsgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgc2V0SW5zdGFuY2VQcm9ncmVzcyhhZGp1c3RUaW1lKHRpbWUpKTtcbiAgfTtcblxuICBpbnN0YW5jZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIGluc3RhbmNlLnBhdXNlZCA9IHRydWU7XG4gICAgcmVzZXRUaW1lKCk7XG4gIH07XG5cbiAgaW5zdGFuY2UucGxheSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghaW5zdGFuY2UucGF1c2VkKSB7IHJldHVybjsgfVxuICAgIGlmIChpbnN0YW5jZS5jb21wbGV0ZWQpIHsgaW5zdGFuY2UucmVzZXQoKTsgfVxuICAgIGluc3RhbmNlLnBhdXNlZCA9IGZhbHNlO1xuICAgIGFjdGl2ZUluc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcbiAgICByZXNldFRpbWUoKTtcbiAgICBpZiAoIXJhZikgeyBlbmdpbmUoKTsgfVxuICB9O1xuXG4gIGluc3RhbmNlLnJldmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgICB0b2dnbGVJbnN0YW5jZURpcmVjdGlvbigpO1xuICAgIHJlc2V0VGltZSgpO1xuICB9O1xuXG4gIGluc3RhbmNlLnJlc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpbnN0YW5jZS5yZXNldCgpO1xuICAgIGluc3RhbmNlLnBsYXkoKTtcbiAgfTtcblxuICBpbnN0YW5jZS5yZXNldCgpO1xuXG4gIGlmIChpbnN0YW5jZS5hdXRvcGxheSkgeyBpbnN0YW5jZS5wbGF5KCk7IH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG5cbn1cblxuLy8gUmVtb3ZlIHRhcmdldHMgZnJvbSBhbmltYXRpb25cblxuZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0c0Zyb21BbmltYXRpb25zKHRhcmdldHNBcnJheSwgYW5pbWF0aW9ucykge1xuICBmb3IgKHZhciBhID0gYW5pbWF0aW9ucy5sZW5ndGg7IGEtLTspIHtcbiAgICBpZiAoYXJyYXlDb250YWlucyh0YXJnZXRzQXJyYXksIGFuaW1hdGlvbnNbYV0uYW5pbWF0YWJsZS50YXJnZXQpKSB7XG4gICAgICBhbmltYXRpb25zLnNwbGljZShhLCAxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0cyh0YXJnZXRzKSB7XG4gIHZhciB0YXJnZXRzQXJyYXkgPSBwYXJzZVRhcmdldHModGFyZ2V0cyk7XG4gIGZvciAodmFyIGkgPSBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgdmFyIGluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2VzW2ldO1xuICAgIHZhciBhbmltYXRpb25zID0gaW5zdGFuY2UuYW5pbWF0aW9ucztcbiAgICB2YXIgY2hpbGRyZW4gPSBpbnN0YW5jZS5jaGlsZHJlbjtcbiAgICByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbnModGFyZ2V0c0FycmF5LCBhbmltYXRpb25zKTtcbiAgICBmb3IgKHZhciBjID0gY2hpbGRyZW4ubGVuZ3RoOyBjLS07KSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltjXTtcbiAgICAgIHZhciBjaGlsZEFuaW1hdGlvbnMgPSBjaGlsZC5hbmltYXRpb25zO1xuICAgICAgcmVtb3ZlVGFyZ2V0c0Zyb21BbmltYXRpb25zKHRhcmdldHNBcnJheSwgY2hpbGRBbmltYXRpb25zKTtcbiAgICAgIGlmICghY2hpbGRBbmltYXRpb25zLmxlbmd0aCAmJiAhY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7IGNoaWxkcmVuLnNwbGljZShjLCAxKTsgfVxuICAgIH1cbiAgICBpZiAoIWFuaW1hdGlvbnMubGVuZ3RoICYmICFjaGlsZHJlbi5sZW5ndGgpIHsgaW5zdGFuY2UucGF1c2UoKTsgfVxuICB9XG59XG5cbi8vIFN0YWdnZXIgaGVscGVyc1xuXG5mdW5jdGlvbiBzdGFnZ2VyKHZhbCwgcGFyYW1zKSB7XG4gIGlmICggcGFyYW1zID09PSB2b2lkIDAgKSBwYXJhbXMgPSB7fTtcblxuICB2YXIgZGlyZWN0aW9uID0gcGFyYW1zLmRpcmVjdGlvbiB8fCAnbm9ybWFsJztcbiAgdmFyIGVhc2luZyA9IHBhcmFtcy5lYXNpbmcgPyBwYXJzZUVhc2luZ3MocGFyYW1zLmVhc2luZykgOiBudWxsO1xuICB2YXIgZ3JpZCA9IHBhcmFtcy5ncmlkO1xuICB2YXIgYXhpcyA9IHBhcmFtcy5heGlzO1xuICB2YXIgZnJvbUluZGV4ID0gcGFyYW1zLmZyb20gfHwgMDtcbiAgdmFyIGZyb21GaXJzdCA9IGZyb21JbmRleCA9PT0gJ2ZpcnN0JztcbiAgdmFyIGZyb21DZW50ZXIgPSBmcm9tSW5kZXggPT09ICdjZW50ZXInO1xuICB2YXIgZnJvbUxhc3QgPSBmcm9tSW5kZXggPT09ICdsYXN0JztcbiAgdmFyIGlzUmFuZ2UgPSBpcy5hcnIodmFsKTtcbiAgdmFyIHZhbDEgPSBpc1JhbmdlID8gcGFyc2VGbG9hdCh2YWxbMF0pIDogcGFyc2VGbG9hdCh2YWwpO1xuICB2YXIgdmFsMiA9IGlzUmFuZ2UgPyBwYXJzZUZsb2F0KHZhbFsxXSkgOiAwO1xuICB2YXIgdW5pdCA9IGdldFVuaXQoaXNSYW5nZSA/IHZhbFsxXSA6IHZhbCkgfHwgMDtcbiAgdmFyIHN0YXJ0ID0gcGFyYW1zLnN0YXJ0IHx8IDAgKyAoaXNSYW5nZSA/IHZhbDEgOiAwKTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgbWF4VmFsdWUgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKGVsLCBpLCB0KSB7XG4gICAgaWYgKGZyb21GaXJzdCkgeyBmcm9tSW5kZXggPSAwOyB9XG4gICAgaWYgKGZyb21DZW50ZXIpIHsgZnJvbUluZGV4ID0gKHQgLSAxKSAvIDI7IH1cbiAgICBpZiAoZnJvbUxhc3QpIHsgZnJvbUluZGV4ID0gdCAtIDE7IH1cbiAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0OyBpbmRleCsrKSB7XG4gICAgICAgIGlmICghZ3JpZCkge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKE1hdGguYWJzKGZyb21JbmRleCAtIGluZGV4KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZyb21YID0gIWZyb21DZW50ZXIgPyBmcm9tSW5kZXglZ3JpZFswXSA6IChncmlkWzBdLTEpLzI7XG4gICAgICAgICAgdmFyIGZyb21ZID0gIWZyb21DZW50ZXIgPyBNYXRoLmZsb29yKGZyb21JbmRleC9ncmlkWzBdKSA6IChncmlkWzFdLTEpLzI7XG4gICAgICAgICAgdmFyIHRvWCA9IGluZGV4JWdyaWRbMF07XG4gICAgICAgICAgdmFyIHRvWSA9IE1hdGguZmxvb3IoaW5kZXgvZ3JpZFswXSk7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlWCA9IGZyb21YIC0gdG9YO1xuICAgICAgICAgIHZhciBkaXN0YW5jZVkgPSBmcm9tWSAtIHRvWTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBNYXRoLnNxcnQoZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZKTtcbiAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3gnKSB7IHZhbHVlID0gLWRpc3RhbmNlWDsgfVxuICAgICAgICAgIGlmIChheGlzID09PSAneScpIHsgdmFsdWUgPSAtZGlzdGFuY2VZOyB9XG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG1heFZhbHVlID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChlYXNpbmcpIHsgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBlYXNpbmcodmFsIC8gbWF4VmFsdWUpICogbWF4VmFsdWU7IH0pOyB9XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAncmV2ZXJzZScpIHsgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBheGlzID8gKHZhbCA8IDApID8gdmFsICogLTEgOiAtdmFsIDogTWF0aC5hYnMobWF4VmFsdWUgLSB2YWwpOyB9KTsgfVxuICAgIH1cbiAgICB2YXIgc3BhY2luZyA9IGlzUmFuZ2UgPyAodmFsMiAtIHZhbDEpIC8gbWF4VmFsdWUgOiB2YWwxO1xuICAgIHJldHVybiBzdGFydCArIChzcGFjaW5nICogKE1hdGgucm91bmQodmFsdWVzW2ldICogMTAwKSAvIDEwMCkpICsgdW5pdDtcbiAgfVxufVxuXG4vLyBUaW1lbGluZVxuXG5mdW5jdGlvbiB0aW1lbGluZShwYXJhbXMpIHtcbiAgaWYgKCBwYXJhbXMgPT09IHZvaWQgMCApIHBhcmFtcyA9IHt9O1xuXG4gIHZhciB0bCA9IGFuaW1lKHBhcmFtcyk7XG4gIHRsLmR1cmF0aW9uID0gMDtcbiAgdGwuYWRkID0gZnVuY3Rpb24oaW5zdGFuY2VQYXJhbXMsIHRpbWVsaW5lT2Zmc2V0KSB7XG4gICAgdmFyIHRsSW5kZXggPSBhY3RpdmVJbnN0YW5jZXMuaW5kZXhPZih0bCk7XG4gICAgdmFyIGNoaWxkcmVuID0gdGwuY2hpbGRyZW47XG4gICAgaWYgKHRsSW5kZXggPiAtMSkgeyBhY3RpdmVJbnN0YW5jZXMuc3BsaWNlKHRsSW5kZXgsIDEpOyB9XG4gICAgZnVuY3Rpb24gcGFzc1Rocm91Z2goaW5zKSB7IGlucy5wYXNzVGhyb3VnaCA9IHRydWU7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7IHBhc3NUaHJvdWdoKGNoaWxkcmVuW2ldKTsgfVxuICAgIHZhciBpbnNQYXJhbXMgPSBtZXJnZU9iamVjdHMoaW5zdGFuY2VQYXJhbXMsIHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0VHdlZW5TZXR0aW5ncywgcGFyYW1zKSk7XG4gICAgaW5zUGFyYW1zLnRhcmdldHMgPSBpbnNQYXJhbXMudGFyZ2V0cyB8fCBwYXJhbXMudGFyZ2V0cztcbiAgICB2YXIgdGxEdXJhdGlvbiA9IHRsLmR1cmF0aW9uO1xuICAgIGluc1BhcmFtcy5hdXRvcGxheSA9IGZhbHNlO1xuICAgIGluc1BhcmFtcy5kaXJlY3Rpb24gPSB0bC5kaXJlY3Rpb247XG4gICAgaW5zUGFyYW1zLnRpbWVsaW5lT2Zmc2V0ID0gaXMudW5kKHRpbWVsaW5lT2Zmc2V0KSA/IHRsRHVyYXRpb24gOiBnZXRSZWxhdGl2ZVZhbHVlKHRpbWVsaW5lT2Zmc2V0LCB0bER1cmF0aW9uKTtcbiAgICBwYXNzVGhyb3VnaCh0bCk7XG4gICAgdGwuc2VlayhpbnNQYXJhbXMudGltZWxpbmVPZmZzZXQpO1xuICAgIHZhciBpbnMgPSBhbmltZShpbnNQYXJhbXMpO1xuICAgIHBhc3NUaHJvdWdoKGlucyk7XG4gICAgY2hpbGRyZW4ucHVzaChpbnMpO1xuICAgIHZhciB0aW1pbmdzID0gZ2V0SW5zdGFuY2VUaW1pbmdzKGNoaWxkcmVuLCBwYXJhbXMpO1xuICAgIHRsLmRlbGF5ID0gdGltaW5ncy5kZWxheTtcbiAgICB0bC5lbmREZWxheSA9IHRpbWluZ3MuZW5kRGVsYXk7XG4gICAgdGwuZHVyYXRpb24gPSB0aW1pbmdzLmR1cmF0aW9uO1xuICAgIHRsLnNlZWsoMCk7XG4gICAgdGwucmVzZXQoKTtcbiAgICBpZiAodGwuYXV0b3BsYXkpIHsgdGwucGxheSgpOyB9XG4gICAgcmV0dXJuIHRsO1xuICB9O1xuICByZXR1cm4gdGw7XG59XG5cbmFuaW1lLnZlcnNpb24gPSAnMy4xLjAnO1xuYW5pbWUuc3BlZWQgPSAxO1xuYW5pbWUucnVubmluZyA9IGFjdGl2ZUluc3RhbmNlcztcbmFuaW1lLnJlbW92ZSA9IHJlbW92ZVRhcmdldHM7XG5hbmltZS5nZXQgPSBnZXRPcmlnaW5hbFRhcmdldFZhbHVlO1xuYW5pbWUuc2V0ID0gc2V0VGFyZ2V0c1ZhbHVlO1xuYW5pbWUuY29udmVydFB4ID0gY29udmVydFB4VG9Vbml0O1xuYW5pbWUucGF0aCA9IGdldFBhdGg7XG5hbmltZS5zZXREYXNob2Zmc2V0ID0gc2V0RGFzaG9mZnNldDtcbmFuaW1lLnN0YWdnZXIgPSBzdGFnZ2VyO1xuYW5pbWUudGltZWxpbmUgPSB0aW1lbGluZTtcbmFuaW1lLmVhc2luZyA9IHBhcnNlRWFzaW5ncztcbmFuaW1lLnBlbm5lciA9IHBlbm5lcjtcbmFuaW1lLnJhbmRvbSA9IGZ1bmN0aW9uIChtaW4sIG1heCkgeyByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBhbmltZTtcbiIsIiFmdW5jdGlvbihlLHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW1wiZXhwb3J0c1wiXSx0KTtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBleHBvcnRzKXQoZXhwb3J0cyk7ZWxzZXt2YXIgbz17fTt0KG8pLGUuYm9keVNjcm9sbExvY2s9b319KHRoaXMsZnVuY3Rpb24oZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIHQ9MCxvPUFycmF5KGUubGVuZ3RoKTt0PGUubGVuZ3RoO3QrKylvW3RdPWVbdF07cmV0dXJuIG99cmV0dXJuIEFycmF5LmZyb20oZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGw9ITE7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyl7dmFyIGU9e2dldCBwYXNzaXZlKCl7bD0hMH19O3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFBhc3NpdmVcIixudWxsLGUpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFBhc3NpdmVcIixudWxsLGUpfXZhciBkPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5uYXZpZ2F0b3ImJndpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0mJi9pUChhZHxob25lfG9kKS8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSxjPVtdLHU9ITEsYT0tMSxzPXZvaWQgMCx2PXZvaWQgMCxmPWZ1bmN0aW9uKHQpe3JldHVybiBjLnNvbWUoZnVuY3Rpb24oZSl7cmV0dXJuISghZS5vcHRpb25zLmFsbG93VG91Y2hNb3ZlfHwhZS5vcHRpb25zLmFsbG93VG91Y2hNb3ZlKHQpKX0pfSxtPWZ1bmN0aW9uKGUpe3ZhciB0PWV8fHdpbmRvdy5ldmVudDtyZXR1cm4hIWYodC50YXJnZXQpfHwoMTx0LnRvdWNoZXMubGVuZ3RofHwodC5wcmV2ZW50RGVmYXVsdCYmdC5wcmV2ZW50RGVmYXVsdCgpLCExKSl9LG89ZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dm9pZCAwIT09diYmKGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0PXYsdj12b2lkIDApLHZvaWQgMCE9PXMmJihkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93PXMscz12b2lkIDApfSl9O2V4cG9ydHMuZGlzYWJsZUJvZHlTY3JvbGw9ZnVuY3Rpb24oaSxlKXtpZihkKXtpZighaSlyZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiZGlzYWJsZUJvZHlTY3JvbGwgdW5zdWNjZXNzZnVsIC0gdGFyZ2V0RWxlbWVudCBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gY2FsbGluZyBkaXNhYmxlQm9keVNjcm9sbCBvbiBJT1MgZGV2aWNlcy5cIik7aWYoaSYmIWMuc29tZShmdW5jdGlvbihlKXtyZXR1cm4gZS50YXJnZXRFbGVtZW50PT09aX0pKXt2YXIgdD17dGFyZ2V0RWxlbWVudDppLG9wdGlvbnM6ZXx8e319O2M9W10uY29uY2F0KHIoYyksW3RdKSxpLm9udG91Y2hzdGFydD1mdW5jdGlvbihlKXsxPT09ZS50YXJnZXRUb3VjaGVzLmxlbmd0aCYmKGE9ZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFkpfSxpLm9udG91Y2htb3ZlPWZ1bmN0aW9uKGUpe3ZhciB0LG8sbixyOzE9PT1lLnRhcmdldFRvdWNoZXMubGVuZ3RoJiYobz1pLHI9KHQ9ZSkudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZLWEsIWYodC50YXJnZXQpJiYobyYmMD09PW8uc2Nyb2xsVG9wJiYwPHI/bSh0KToobj1vKSYmbi5zY3JvbGxIZWlnaHQtbi5zY3JvbGxUb3A8PW4uY2xpZW50SGVpZ2h0JiZyPDA/bSh0KTp0LnN0b3BQcm9wYWdhdGlvbigpKSl9LHV8fChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsbSxsP3twYXNzaXZlOiExfTp2b2lkIDApLHU9ITApfX1lbHNle249ZSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWYodm9pZCAwPT09dil7dmFyIGU9ISFuJiYhMD09PW4ucmVzZXJ2ZVNjcm9sbEJhckdhcCx0PXdpbmRvdy5pbm5lcldpZHRoLWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtlJiYwPHQmJih2PWRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0LGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0PXQrXCJweFwiKX12b2lkIDA9PT1zJiYocz1kb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93LGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIil9KTt2YXIgbz17dGFyZ2V0RWxlbWVudDppLG9wdGlvbnM6ZXx8e319O2M9W10uY29uY2F0KHIoYyksW29dKX12YXIgbn0sZXhwb3J0cy5jbGVhckFsbEJvZHlTY3JvbGxMb2Nrcz1mdW5jdGlvbigpe2Q/KGMuZm9yRWFjaChmdW5jdGlvbihlKXtlLnRhcmdldEVsZW1lbnQub250b3VjaHN0YXJ0PW51bGwsZS50YXJnZXRFbGVtZW50Lm9udG91Y2htb3ZlPW51bGx9KSx1JiYoZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLG0sbD97cGFzc2l2ZTohMX06dm9pZCAwKSx1PSExKSxjPVtdLGE9LTEpOihvKCksYz1bXSl9LGV4cG9ydHMuZW5hYmxlQm9keVNjcm9sbD1mdW5jdGlvbih0KXtpZihkKXtpZighdClyZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiZW5hYmxlQm9keVNjcm9sbCB1bnN1Y2Nlc3NmdWwgLSB0YXJnZXRFbGVtZW50IG11c3QgYmUgcHJvdmlkZWQgd2hlbiBjYWxsaW5nIGVuYWJsZUJvZHlTY3JvbGwgb24gSU9TIGRldmljZXMuXCIpO3Qub250b3VjaHN0YXJ0PW51bGwsdC5vbnRvdWNobW92ZT1udWxsLGM9Yy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUudGFyZ2V0RWxlbWVudCE9PXR9KSx1JiYwPT09Yy5sZW5ndGgmJihkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsbSxsP3twYXNzaXZlOiExfTp2b2lkIDApLHU9ITEpfWVsc2UoYz1jLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS50YXJnZXRFbGVtZW50IT09dH0pKS5sZW5ndGh8fG8oKX19KTtcbiIsIi8qIGZsYXRwaWNrciB2NC41LjcsIEBsaWNlbnNlIE1JVCAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5mbGF0cGlja3IgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxuICAgIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbiAgICBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuICAgIFRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICAgIEtJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuICAgIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbiAgICBNRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuICAgIFNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG4gICAgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbiAgICB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xuXG4gICAgdmFyIEhPT0tTID0gW1xuICAgICAgICBcIm9uQ2hhbmdlXCIsXG4gICAgICAgIFwib25DbG9zZVwiLFxuICAgICAgICBcIm9uRGF5Q3JlYXRlXCIsXG4gICAgICAgIFwib25EZXN0cm95XCIsXG4gICAgICAgIFwib25LZXlEb3duXCIsXG4gICAgICAgIFwib25Nb250aENoYW5nZVwiLFxuICAgICAgICBcIm9uT3BlblwiLFxuICAgICAgICBcIm9uUGFyc2VDb25maWdcIixcbiAgICAgICAgXCJvblJlYWR5XCIsXG4gICAgICAgIFwib25WYWx1ZVVwZGF0ZVwiLFxuICAgICAgICBcIm9uWWVhckNoYW5nZVwiLFxuICAgICAgICBcIm9uUHJlQ2FsZW5kYXJQb3NpdGlvblwiLFxuICAgIF07XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICBfZGlzYWJsZTogW10sXG4gICAgICAgIF9lbmFibGU6IFtdLFxuICAgICAgICBhbGxvd0lucHV0OiBmYWxzZSxcbiAgICAgICAgYWx0Rm9ybWF0OiBcIkYgaiwgWVwiLFxuICAgICAgICBhbHRJbnB1dDogZmFsc2UsXG4gICAgICAgIGFsdElucHV0Q2xhc3M6IFwiZm9ybS1jb250cm9sIGlucHV0XCIsXG4gICAgICAgIGFuaW1hdGU6IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpID09PSAtMSxcbiAgICAgICAgYXJpYURhdGVGb3JtYXQ6IFwiRiBqLCBZXCIsXG4gICAgICAgIGNsaWNrT3BlbnM6IHRydWUsXG4gICAgICAgIGNsb3NlT25TZWxlY3Q6IHRydWUsXG4gICAgICAgIGNvbmp1bmN0aW9uOiBcIiwgXCIsXG4gICAgICAgIGRhdGVGb3JtYXQ6IFwiWS1tLWRcIixcbiAgICAgICAgZGVmYXVsdEhvdXI6IDEyLFxuICAgICAgICBkZWZhdWx0TWludXRlOiAwLFxuICAgICAgICBkZWZhdWx0U2Vjb25kczogMCxcbiAgICAgICAgZGlzYWJsZTogW10sXG4gICAgICAgIGRpc2FibGVNb2JpbGU6IGZhbHNlLFxuICAgICAgICBlbmFibGU6IFtdLFxuICAgICAgICBlbmFibGVTZWNvbmRzOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlVGltZTogZmFsc2UsXG4gICAgICAgIGVycm9ySGFuZGxlcjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2FybihlcnIpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRXZWVrOiBmdW5jdGlvbiAoZ2l2ZW5EYXRlKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKGdpdmVuRGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIC8vIFRodXJzZGF5IGluIGN1cnJlbnQgd2VlayBkZWNpZGVzIHRoZSB5ZWFyLlxuICAgICAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgMyAtICgoZGF0ZS5nZXREYXkoKSArIDYpICUgNykpO1xuICAgICAgICAgICAgLy8gSmFudWFyeSA0IGlzIGFsd2F5cyBpbiB3ZWVrIDEuXG4gICAgICAgICAgICB2YXIgd2VlazEgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDQpO1xuICAgICAgICAgICAgLy8gQWRqdXN0IHRvIFRodXJzZGF5IGluIHdlZWsgMSBhbmQgY291bnQgbnVtYmVyIG9mIHdlZWtzIGZyb20gZGF0ZSB0byB3ZWVrMS5cbiAgICAgICAgICAgIHJldHVybiAoMSArXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgoKGRhdGUuZ2V0VGltZSgpIC0gd2VlazEuZ2V0VGltZSgpKSAvIDg2NDAwMDAwIC1cbiAgICAgICAgICAgICAgICAgICAgMyArXG4gICAgICAgICAgICAgICAgICAgICgod2VlazEuZ2V0RGF5KCkgKyA2KSAlIDcpKSAvXG4gICAgICAgICAgICAgICAgICAgIDcpKTtcbiAgICAgICAgfSxcbiAgICAgICAgaG91ckluY3JlbWVudDogMSxcbiAgICAgICAgaWdub3JlZEZvY3VzRWxlbWVudHM6IFtdLFxuICAgICAgICBpbmxpbmU6IGZhbHNlLFxuICAgICAgICBsb2NhbGU6IFwiZGVmYXVsdFwiLFxuICAgICAgICBtaW51dGVJbmNyZW1lbnQ6IDUsXG4gICAgICAgIG1vZGU6IFwic2luZ2xlXCIsXG4gICAgICAgIG5leHRBcnJvdzogXCI8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgdmlld0JveD0nMCAwIDE3IDE3Jz48Zz48L2c+PHBhdGggZD0nTTEzLjIwNyA4LjQ3MmwtNy44NTQgNy44NTQtMC43MDctMC43MDcgNy4xNDYtNy4xNDYtNy4xNDYtNy4xNDggMC43MDctMC43MDcgNy44NTQgNy44NTR6JyAvPjwvc3ZnPlwiLFxuICAgICAgICBub0NhbGVuZGFyOiBmYWxzZSxcbiAgICAgICAgbm93OiBuZXcgRGF0ZSgpLFxuICAgICAgICBvbkNoYW5nZTogW10sXG4gICAgICAgIG9uQ2xvc2U6IFtdLFxuICAgICAgICBvbkRheUNyZWF0ZTogW10sXG4gICAgICAgIG9uRGVzdHJveTogW10sXG4gICAgICAgIG9uS2V5RG93bjogW10sXG4gICAgICAgIG9uTW9udGhDaGFuZ2U6IFtdLFxuICAgICAgICBvbk9wZW46IFtdLFxuICAgICAgICBvblBhcnNlQ29uZmlnOiBbXSxcbiAgICAgICAgb25SZWFkeTogW10sXG4gICAgICAgIG9uVmFsdWVVcGRhdGU6IFtdLFxuICAgICAgICBvblllYXJDaGFuZ2U6IFtdLFxuICAgICAgICBvblByZUNhbGVuZGFyUG9zaXRpb246IFtdLFxuICAgICAgICBwbHVnaW5zOiBbXSxcbiAgICAgICAgcG9zaXRpb246IFwiYXV0b1wiLFxuICAgICAgICBwb3NpdGlvbkVsZW1lbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJldkFycm93OiBcIjxzdmcgdmVyc2lvbj0nMS4xJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHhtbG5zOnhsaW5rPSdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyB2aWV3Qm94PScwIDAgMTcgMTcnPjxnPjwvZz48cGF0aCBkPSdNNS4yMDcgOC40NzFsNy4xNDYgNy4xNDctMC43MDcgMC43MDctNy44NTMtNy44NTQgNy44NTQtNy44NTMgMC43MDcgMC43MDctNy4xNDcgNy4xNDZ6JyAvPjwvc3ZnPlwiLFxuICAgICAgICBzaG9ydGhhbmRDdXJyZW50TW9udGg6IGZhbHNlLFxuICAgICAgICBzaG93TW9udGhzOiAxLFxuICAgICAgICBzdGF0aWM6IGZhbHNlLFxuICAgICAgICB0aW1lXzI0aHI6IGZhbHNlLFxuICAgICAgICB3ZWVrTnVtYmVyczogZmFsc2UsXG4gICAgICAgIHdyYXA6IGZhbHNlXG4gICAgfTtcblxuICAgIHZhciBlbmdsaXNoID0ge1xuICAgICAgICB3ZWVrZGF5czoge1xuICAgICAgICAgICAgc2hvcnRoYW5kOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gICAgICAgICAgICBsb25naGFuZDogW1xuICAgICAgICAgICAgICAgIFwiU3VuZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJNb25kYXlcIixcbiAgICAgICAgICAgICAgICBcIlR1ZXNkYXlcIixcbiAgICAgICAgICAgICAgICBcIldlZG5lc2RheVwiLFxuICAgICAgICAgICAgICAgIFwiVGh1cnNkYXlcIixcbiAgICAgICAgICAgICAgICBcIkZyaWRheVwiLFxuICAgICAgICAgICAgICAgIFwiU2F0dXJkYXlcIixcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgbW9udGhzOiB7XG4gICAgICAgICAgICBzaG9ydGhhbmQ6IFtcbiAgICAgICAgICAgICAgICBcIkphblwiLFxuICAgICAgICAgICAgICAgIFwiRmViXCIsXG4gICAgICAgICAgICAgICAgXCJNYXJcIixcbiAgICAgICAgICAgICAgICBcIkFwclwiLFxuICAgICAgICAgICAgICAgIFwiTWF5XCIsXG4gICAgICAgICAgICAgICAgXCJKdW5cIixcbiAgICAgICAgICAgICAgICBcIkp1bFwiLFxuICAgICAgICAgICAgICAgIFwiQXVnXCIsXG4gICAgICAgICAgICAgICAgXCJTZXBcIixcbiAgICAgICAgICAgICAgICBcIk9jdFwiLFxuICAgICAgICAgICAgICAgIFwiTm92XCIsXG4gICAgICAgICAgICAgICAgXCJEZWNcIixcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBsb25naGFuZDogW1xuICAgICAgICAgICAgICAgIFwiSmFudWFyeVwiLFxuICAgICAgICAgICAgICAgIFwiRmVicnVhcnlcIixcbiAgICAgICAgICAgICAgICBcIk1hcmNoXCIsXG4gICAgICAgICAgICAgICAgXCJBcHJpbFwiLFxuICAgICAgICAgICAgICAgIFwiTWF5XCIsXG4gICAgICAgICAgICAgICAgXCJKdW5lXCIsXG4gICAgICAgICAgICAgICAgXCJKdWx5XCIsXG4gICAgICAgICAgICAgICAgXCJBdWd1c3RcIixcbiAgICAgICAgICAgICAgICBcIlNlcHRlbWJlclwiLFxuICAgICAgICAgICAgICAgIFwiT2N0b2JlclwiLFxuICAgICAgICAgICAgICAgIFwiTm92ZW1iZXJcIixcbiAgICAgICAgICAgICAgICBcIkRlY2VtYmVyXCIsXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIGRheXNJbk1vbnRoOiBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV0sXG4gICAgICAgIGZpcnN0RGF5T2ZXZWVrOiAwLFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnRoKSB7XG4gICAgICAgICAgICB2YXIgcyA9IG50aCAlIDEwMDtcbiAgICAgICAgICAgIGlmIChzID4gMyAmJiBzIDwgMjEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidGhcIjtcbiAgICAgICAgICAgIHN3aXRjaCAocyAlIDEwKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibmRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInJkXCI7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidGhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmFuZ2VTZXBhcmF0b3I6IFwiIHRvIFwiLFxuICAgICAgICB3ZWVrQWJicmV2aWF0aW9uOiBcIldrXCIsXG4gICAgICAgIHNjcm9sbFRpdGxlOiBcIlNjcm9sbCB0byBpbmNyZW1lbnRcIixcbiAgICAgICAgdG9nZ2xlVGl0bGU6IFwiQ2xpY2sgdG8gdG9nZ2xlXCIsXG4gICAgICAgIGFtUE06IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgICAgIHllYXJBcmlhTGFiZWw6IFwiWWVhclwiXG4gICAgfTtcblxuICAgIHZhciBwYWQgPSBmdW5jdGlvbiAobnVtYmVyKSB7IHJldHVybiAoXCIwXCIgKyBudW1iZXIpLnNsaWNlKC0yKTsgfTtcbiAgICB2YXIgaW50ID0gZnVuY3Rpb24gKGJvb2wpIHsgcmV0dXJuIChib29sID09PSB0cnVlID8gMSA6IDApOyB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgICAgIGlmIChpbW1lZGlhdGUgPT09IHZvaWQgMCkgeyBpbW1lZGlhdGUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgdGltZW91dDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRpbWVvdXQgIT09IG51bGwgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWltbWVkaWF0ZSlcbiAgICAgICAgICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH0sIHdhaXQpO1xuICAgICAgICAgICAgaWYgKGltbWVkaWF0ZSAmJiAhdGltZW91dClcbiAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgYXJyYXlpZnkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBBcnJheSA/IG9iaiA6IFtvYmpdO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtLCBjbGFzc05hbWUsIGJvb2wpIHtcbiAgICAgICAgaWYgKGJvb2wgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm4gZWxlbS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZywgY2xhc3NOYW1lLCBjb250ZW50KSB7XG4gICAgICAgIHZhciBlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8IFwiXCI7XG4gICAgICAgIGNvbnRlbnQgPSBjb250ZW50IHx8IFwiXCI7XG4gICAgICAgIGUuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICBpZiAoY29udGVudCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZS50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhck5vZGUobm9kZSkge1xuICAgICAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKVxuICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kUGFyZW50KG5vZGUsIGNvbmRpdGlvbikge1xuICAgICAgICBpZiAoY29uZGl0aW9uKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmaW5kUGFyZW50KG5vZGUucGFyZW50Tm9kZSwgY29uZGl0aW9uKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gbm90aGluZyBmb3VuZFxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVOdW1iZXJJbnB1dChpbnB1dENsYXNzTmFtZSwgb3B0cykge1xuICAgICAgICB2YXIgd3JhcHBlciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJudW1JbnB1dFdyYXBwZXJcIiksIG51bUlucHV0ID0gY3JlYXRlRWxlbWVudChcImlucHV0XCIsIFwibnVtSW5wdXQgXCIgKyBpbnB1dENsYXNzTmFtZSksIGFycm93VXAgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImFycm93VXBcIiksIGFycm93RG93biA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiYXJyb3dEb3duXCIpO1xuICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRSA5LjBcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBudW1JbnB1dC50eXBlID0gXCJudW1iZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG51bUlucHV0LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICAgIG51bUlucHV0LnBhdHRlcm4gPSBcIlxcXFxkKlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0cylcbiAgICAgICAgICAgICAgICBudW1JbnB1dC5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRzW2tleV0pO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKG51bUlucHV0KTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChhcnJvd1VwKTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChhcnJvd0Rvd24pO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudC5jb21wb3NlZFBhdGggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudC50YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGRvX25vdGhpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH07XG4gICAgdmFyIG1vbnRoVG9TdHIgPSBmdW5jdGlvbiAobW9udGhOdW1iZXIsIHNob3J0aGFuZCwgbG9jYWxlKSB7IHJldHVybiBsb2NhbGUubW9udGhzW3Nob3J0aGFuZCA/IFwic2hvcnRoYW5kXCIgOiBcImxvbmdoYW5kXCJdW21vbnRoTnVtYmVyXTsgfTtcbiAgICB2YXIgcmV2Rm9ybWF0ID0ge1xuICAgICAgICBEOiBkb19ub3RoaW5nLFxuICAgICAgICBGOiBmdW5jdGlvbiAoZGF0ZU9iaiwgbW9udGhOYW1lLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0TW9udGgobG9jYWxlLm1vbnRocy5sb25naGFuZC5pbmRleE9mKG1vbnRoTmFtZSkpO1xuICAgICAgICB9LFxuICAgICAgICBHOiBmdW5jdGlvbiAoZGF0ZU9iaiwgaG91cikge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRIb3VycyhwYXJzZUZsb2F0KGhvdXIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgSDogZnVuY3Rpb24gKGRhdGVPYmosIGhvdXIpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0SG91cnMocGFyc2VGbG9hdChob3VyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIEo6IGZ1bmN0aW9uIChkYXRlT2JqLCBkYXkpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0RGF0ZShwYXJzZUZsb2F0KGRheSkpO1xuICAgICAgICB9LFxuICAgICAgICBLOiBmdW5jdGlvbiAoZGF0ZU9iaiwgYW1QTSwgbG9jYWxlKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldEhvdXJzKChkYXRlT2JqLmdldEhvdXJzKCkgJSAxMikgK1xuICAgICAgICAgICAgICAgIDEyICogaW50KG5ldyBSZWdFeHAobG9jYWxlLmFtUE1bMV0sIFwiaVwiKS50ZXN0KGFtUE0pKSk7XG4gICAgICAgIH0sXG4gICAgICAgIE06IGZ1bmN0aW9uIChkYXRlT2JqLCBzaG9ydE1vbnRoLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0TW9udGgobG9jYWxlLm1vbnRocy5zaG9ydGhhbmQuaW5kZXhPZihzaG9ydE1vbnRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIFM6IGZ1bmN0aW9uIChkYXRlT2JqLCBzZWNvbmRzKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldFNlY29uZHMocGFyc2VGbG9hdChzZWNvbmRzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIFU6IGZ1bmN0aW9uIChfLCB1bml4U2Vjb25kcykgeyByZXR1cm4gbmV3IERhdGUocGFyc2VGbG9hdCh1bml4U2Vjb25kcykgKiAxMDAwKTsgfSxcbiAgICAgICAgVzogZnVuY3Rpb24gKGRhdGVPYmosIHdlZWtOdW0pIHtcbiAgICAgICAgICAgIHZhciB3ZWVrTnVtYmVyID0gcGFyc2VJbnQod2Vla051bSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZU9iai5nZXRGdWxsWWVhcigpLCAwLCAyICsgKHdlZWtOdW1iZXIgLSAxKSAqIDcsIDAsIDAsIDAsIDApO1xuICAgICAgICB9LFxuICAgICAgICBZOiBmdW5jdGlvbiAoZGF0ZU9iaiwgeWVhcikge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRGdWxsWWVhcihwYXJzZUZsb2F0KHllYXIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgWjogZnVuY3Rpb24gKF8sIElTT0RhdGUpIHsgcmV0dXJuIG5ldyBEYXRlKElTT0RhdGUpOyB9LFxuICAgICAgICBkOiBmdW5jdGlvbiAoZGF0ZU9iaiwgZGF5KSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldERhdGUocGFyc2VGbG9hdChkYXkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgaDogZnVuY3Rpb24gKGRhdGVPYmosIGhvdXIpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0SG91cnMocGFyc2VGbG9hdChob3VyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGk6IGZ1bmN0aW9uIChkYXRlT2JqLCBtaW51dGVzKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldE1pbnV0ZXMocGFyc2VGbG9hdChtaW51dGVzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGo6IGZ1bmN0aW9uIChkYXRlT2JqLCBkYXkpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0RGF0ZShwYXJzZUZsb2F0KGRheSkpO1xuICAgICAgICB9LFxuICAgICAgICBsOiBkb19ub3RoaW5nLFxuICAgICAgICBtOiBmdW5jdGlvbiAoZGF0ZU9iaiwgbW9udGgpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0TW9udGgocGFyc2VGbG9hdChtb250aCkgLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgbjogZnVuY3Rpb24gKGRhdGVPYmosIG1vbnRoKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldE1vbnRoKHBhcnNlRmxvYXQobW9udGgpIC0gMSk7XG4gICAgICAgIH0sXG4gICAgICAgIHM6IGZ1bmN0aW9uIChkYXRlT2JqLCBzZWNvbmRzKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldFNlY29uZHMocGFyc2VGbG9hdChzZWNvbmRzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHU6IGZ1bmN0aW9uIChfLCB1bml4TWlsbFNlY29uZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShwYXJzZUZsb2F0KHVuaXhNaWxsU2Vjb25kcykpO1xuICAgICAgICB9LFxuICAgICAgICB3OiBkb19ub3RoaW5nLFxuICAgICAgICB5OiBmdW5jdGlvbiAoZGF0ZU9iaiwgeWVhcikge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRGdWxsWWVhcigyMDAwICsgcGFyc2VGbG9hdCh5ZWFyKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciB0b2tlblJlZ2V4ID0ge1xuICAgICAgICBEOiBcIihcXFxcdyspXCIsXG4gICAgICAgIEY6IFwiKFxcXFx3KylcIixcbiAgICAgICAgRzogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgSDogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgSjogXCIoXFxcXGRcXFxcZHxcXFxcZClcXFxcdytcIixcbiAgICAgICAgSzogXCJcIixcbiAgICAgICAgTTogXCIoXFxcXHcrKVwiLFxuICAgICAgICBTOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBVOiBcIiguKylcIixcbiAgICAgICAgVzogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgWTogXCIoXFxcXGR7NH0pXCIsXG4gICAgICAgIFo6IFwiKC4rKVwiLFxuICAgICAgICBkOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBoOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBpOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBqOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBsOiBcIihcXFxcdyspXCIsXG4gICAgICAgIG06IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIG46IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIHM6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIHU6IFwiKC4rKVwiLFxuICAgICAgICB3OiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICB5OiBcIihcXFxcZHsyfSlcIlxuICAgIH07XG4gICAgdmFyIGZvcm1hdHMgPSB7XG4gICAgICAgIC8vIGdldCB0aGUgZGF0ZSBpbiBVVENcbiAgICAgICAgWjogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTsgfSxcbiAgICAgICAgLy8gd2Vla2RheSBuYW1lLCBzaG9ydCwgZS5nLiBUaHVcbiAgICAgICAgRDogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5cy5zaG9ydGhhbmRbZm9ybWF0cy53KGRhdGUsIGxvY2FsZSwgb3B0aW9ucyldO1xuICAgICAgICB9LFxuICAgICAgICAvLyBmdWxsIG1vbnRoIG5hbWUgZS5nLiBKYW51YXJ5XG4gICAgICAgIEY6IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBtb250aFRvU3RyKGZvcm1hdHMubihkYXRlLCBsb2NhbGUsIG9wdGlvbnMpIC0gMSwgZmFsc2UsIGxvY2FsZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHBhZGRlZCBob3VyIDEtMTJcbiAgICAgICAgRzogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHBhZChmb3JtYXRzLmgoZGF0ZSwgbG9jYWxlLCBvcHRpb25zKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGhvdXJzIHdpdGggbGVhZGluZyB6ZXJvIGUuZy4gMDNcbiAgICAgICAgSDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHBhZChkYXRlLmdldEhvdXJzKCkpOyB9LFxuICAgICAgICAvLyBkYXkgKDEtMzApIHdpdGggb3JkaW5hbCBzdWZmaXggZS5nLiAxc3QsIDJuZFxuICAgICAgICBKOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLm9yZGluYWwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gZGF0ZS5nZXREYXRlKCkgKyBsb2NhbGUub3JkaW5hbChkYXRlLmdldERhdGUoKSlcbiAgICAgICAgICAgICAgICA6IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBBTS9QTVxuICAgICAgICBLOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7IHJldHVybiBsb2NhbGUuYW1QTVtpbnQoZGF0ZS5nZXRIb3VycygpID4gMTEpXTsgfSxcbiAgICAgICAgLy8gc2hvcnRoYW5kIG1vbnRoIGUuZy4gSmFuLCBTZXAsIE9jdCwgZXRjXG4gICAgICAgIE06IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtb250aFRvU3RyKGRhdGUuZ2V0TW9udGgoKSwgdHJ1ZSwgbG9jYWxlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gc2Vjb25kcyAwMC01OVxuICAgICAgICBTOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gcGFkKGRhdGUuZ2V0U2Vjb25kcygpKTsgfSxcbiAgICAgICAgLy8gdW5peCB0aW1lc3RhbXBcbiAgICAgICAgVTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIC8gMTAwMDsgfSxcbiAgICAgICAgVzogZnVuY3Rpb24gKGRhdGUsIF8sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmdldFdlZWsoZGF0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGZ1bGwgeWVhciBlLmcuIDIwMTZcbiAgICAgICAgWTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTsgfSxcbiAgICAgICAgLy8gZGF5IGluIG1vbnRoLCBwYWRkZWQgKDAxLTMwKVxuICAgICAgICBkOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gcGFkKGRhdGUuZ2V0RGF0ZSgpKTsgfSxcbiAgICAgICAgLy8gaG91ciBmcm9tIDEtMTIgKGFtL3BtKVxuICAgICAgICBoOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gKGRhdGUuZ2V0SG91cnMoKSAlIDEyID8gZGF0ZS5nZXRIb3VycygpICUgMTIgOiAxMik7IH0sXG4gICAgICAgIC8vIG1pbnV0ZXMsIHBhZGRlZCB3aXRoIGxlYWRpbmcgemVybyBlLmcuIDA5XG4gICAgICAgIGk6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBwYWQoZGF0ZS5nZXRNaW51dGVzKCkpOyB9LFxuICAgICAgICAvLyBkYXkgaW4gbW9udGggKDEtMzApXG4gICAgICAgIGo6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldERhdGUoKTsgfSxcbiAgICAgICAgLy8gd2Vla2RheSBuYW1lLCBmdWxsLCBlLmcuIFRodXJzZGF5XG4gICAgICAgIGw6IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXMubG9uZ2hhbmRbZGF0ZS5nZXREYXkoKV07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHBhZGRlZCBtb250aCBudW1iZXIgKDAxLTEyKVxuICAgICAgICBtOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gcGFkKGRhdGUuZ2V0TW9udGgoKSArIDEpOyB9LFxuICAgICAgICAvLyB0aGUgbW9udGggbnVtYmVyICgxLTEyKVxuICAgICAgICBuOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRNb250aCgpICsgMTsgfSxcbiAgICAgICAgLy8gc2Vjb25kcyAwLTU5XG4gICAgICAgIHM6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFNlY29uZHMoKTsgfSxcbiAgICAgICAgLy8gVW5peCBNaWxsaXNlY29uZHNcbiAgICAgICAgdTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VGltZSgpOyB9LFxuICAgICAgICAvLyBudW1iZXIgb2YgdGhlIGRheSBvZiB0aGUgd2Vla1xuICAgICAgICB3OiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXREYXkoKTsgfSxcbiAgICAgICAgLy8gbGFzdCB0d28gZGlnaXRzIG9mIHllYXIgZS5nLiAxNiBmb3IgMjAxNlxuICAgICAgICB5OiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gU3RyaW5nKGRhdGUuZ2V0RnVsbFllYXIoKSkuc3Vic3RyaW5nKDIpOyB9XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVEYXRlRm9ybWF0dGVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hLmNvbmZpZywgY29uZmlnID0gX2IgPT09IHZvaWQgMCA/IGRlZmF1bHRzIDogX2IsIF9jID0gX2EubDEwbiwgbDEwbiA9IF9jID09PSB2b2lkIDAgPyBlbmdsaXNoIDogX2M7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZU9iaiwgZnJtdCwgb3ZlcnJpZGVMb2NhbGUpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUgPSBvdmVycmlkZUxvY2FsZSB8fCBsMTBuO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5mb3JtYXREYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnLmZvcm1hdERhdGUoZGF0ZU9iaiwgZnJtdCwgbG9jYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmcm10XG4gICAgICAgICAgICAgICAgLnNwbGl0KFwiXCIpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYywgaSwgYXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHNbY10gJiYgYXJyW2kgLSAxXSAhPT0gXCJcXFxcXCJcbiAgICAgICAgICAgICAgICAgICAgPyBmb3JtYXRzW2NdKGRhdGVPYmosIGxvY2FsZSwgY29uZmlnKVxuICAgICAgICAgICAgICAgICAgICA6IGMgIT09IFwiXFxcXFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlRGF0ZVBhcnNlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYS5jb25maWcsIGNvbmZpZyA9IF9iID09PSB2b2lkIDAgPyBkZWZhdWx0cyA6IF9iLCBfYyA9IF9hLmwxMG4sIGwxMG4gPSBfYyA9PT0gdm9pZCAwID8gZW5nbGlzaCA6IF9jO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUsIGdpdmVuRm9ybWF0LCB0aW1lbGVzcywgY3VzdG9tTG9jYWxlKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZSAhPT0gMCAmJiAhZGF0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIGxvY2FsZSA9IGN1c3RvbUxvY2FsZSB8fCBsMTBuO1xuICAgICAgICAgICAgdmFyIHBhcnNlZERhdGU7XG4gICAgICAgICAgICB2YXIgZGF0ZV9vcmlnID0gZGF0ZTtcbiAgICAgICAgICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGUgIT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBkYXRlLnRvRml4ZWQgIT09IHVuZGVmaW5lZCAvLyB0aW1lc3RhbXBcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBjb3B5XG4gICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBkYXRlIHN0cmluZ1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXQgPSBnaXZlbkZvcm1hdCB8fCAoY29uZmlnIHx8IGRlZmF1bHRzKS5kYXRlRm9ybWF0O1xuICAgICAgICAgICAgICAgIHZhciBkYXRlc3RyID0gU3RyaW5nKGRhdGUpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZXN0ciA9PT0gXCJ0b2RheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lbGVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9aJC8udGVzdChkYXRlc3RyKSB8fFxuICAgICAgICAgICAgICAgICAgICAvR01UJC8udGVzdChkYXRlc3RyKSAvLyBkYXRlc3RyaW5ncyB3LyB0aW1lem9uZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZyAmJiBjb25maWcucGFyc2VEYXRlKVxuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gY29uZmlnLnBhcnNlRGF0ZShkYXRlLCBmb3JtYXQpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICFjb25maWcgfHwgIWNvbmZpZy5ub0NhbGVuZGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgRGF0ZShuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksIDAsIDEsIDAsIDAsIDAsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldEhvdXJzKDAsIDAsIDAsIDApKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSB2b2lkIDAsIG9wcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbWF0Y2hJbmRleCA9IDAsIHJlZ2V4U3RyID0gXCJcIjsgaSA8IGZvcm1hdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuXzEgPSBmb3JtYXRbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNCYWNrU2xhc2ggPSB0b2tlbl8xID09PSBcIlxcXFxcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlc2NhcGVkID0gZm9ybWF0W2kgLSAxXSA9PT0gXCJcXFxcXCIgfHwgaXNCYWNrU2xhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5SZWdleFt0b2tlbl8xXSAmJiAhZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4U3RyICs9IHRva2VuUmVnZXhbdG9rZW5fMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbmV3IFJlZ0V4cChyZWdleFN0cikuZXhlYyhkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgKG1hdGNoZWQgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHNbdG9rZW5fMSAhPT0gXCJZXCIgPyBcInB1c2hcIiA6IFwidW5zaGlmdFwiXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogcmV2Rm9ybWF0W3Rva2VuXzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsOiBtYXRjaFsrK21hdGNoSW5kZXhdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0JhY2tTbGFzaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleFN0ciArPSBcIi5cIjsgLy8gZG9uJ3QgcmVhbGx5IGNhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IF9hLmZuLCB2YWwgPSBfYS52YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChwYXJzZWREYXRlID0gZm4ocGFyc2VkRGF0ZSwgdmFsLCBsb2NhbGUpIHx8IHBhcnNlZERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG1hdGNoZWQgPyBwYXJzZWREYXRlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoIShwYXJzZWREYXRlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4ocGFyc2VkRGF0ZS5nZXRUaW1lKCkpKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5lcnJvckhhbmRsZXIobmV3IEVycm9yKFwiSW52YWxpZCBkYXRlIHByb3ZpZGVkOiBcIiArIGRhdGVfb3JpZykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZWxlc3MgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgcGFyc2VkRGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWREYXRlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgZGlmZmVyZW5jZSBpbiBkYXRlcywgbWVhc3VyZWQgaW4gbXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlRGF0ZXMoZGF0ZTEsIGRhdGUyLCB0aW1lbGVzcykge1xuICAgICAgICBpZiAodGltZWxlc3MgPT09IHZvaWQgMCkgeyB0aW1lbGVzcyA9IHRydWU7IH1cbiAgICAgICAgaWYgKHRpbWVsZXNzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgRGF0ZShkYXRlMS5nZXRUaW1lKCkpLnNldEhvdXJzKDAsIDAsIDAsIDApIC1cbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShkYXRlMi5nZXRUaW1lKCkpLnNldEhvdXJzKDAsIDAsIDAsIDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTEuZ2V0VGltZSgpIC0gZGF0ZTIuZ2V0VGltZSgpO1xuICAgIH1cbiAgICB2YXIgaXNCZXR3ZWVuID0gZnVuY3Rpb24gKHRzLCB0czEsIHRzMikge1xuICAgICAgICByZXR1cm4gdHMgPiBNYXRoLm1pbih0czEsIHRzMikgJiYgdHMgPCBNYXRoLm1heCh0czEsIHRzMik7XG4gICAgfTtcbiAgICB2YXIgZHVyYXRpb24gPSB7XG4gICAgICAgIERBWTogODY0MDAwMDBcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgYXJnc18xID0gYXJnczsgX2EgPCBhcmdzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3NfMVtfYV07XG4gICAgICAgICAgICAgICAgX2xvb3BfMShzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgREVCT1VOQ0VEX0NIQU5HRV9NUyA9IDMwMDtcbiAgICBmdW5jdGlvbiBGbGF0cGlja3JJbnN0YW5jZShlbGVtZW50LCBpbnN0YW5jZUNvbmZpZykge1xuICAgICAgICB2YXIgc2VsZiA9IHtcbiAgICAgICAgICAgIGNvbmZpZzogX19hc3NpZ24oe30sIGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnKSxcbiAgICAgICAgICAgIGwxMG46IGVuZ2xpc2hcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5wYXJzZURhdGUgPSBjcmVhdGVEYXRlUGFyc2VyKHsgY29uZmlnOiBzZWxmLmNvbmZpZywgbDEwbjogc2VsZi5sMTBuIH0pO1xuICAgICAgICBzZWxmLl9oYW5kbGVycyA9IFtdO1xuICAgICAgICBzZWxmLl9iaW5kID0gYmluZDtcbiAgICAgICAgc2VsZi5fc2V0SG91cnNGcm9tRGF0ZSA9IHNldEhvdXJzRnJvbURhdGU7XG4gICAgICAgIHNlbGYuX3Bvc2l0aW9uQ2FsZW5kYXIgPSBwb3NpdGlvbkNhbGVuZGFyO1xuICAgICAgICBzZWxmLmNoYW5nZU1vbnRoID0gY2hhbmdlTW9udGg7XG4gICAgICAgIHNlbGYuY2hhbmdlWWVhciA9IGNoYW5nZVllYXI7XG4gICAgICAgIHNlbGYuY2xlYXIgPSBjbGVhcjtcbiAgICAgICAgc2VsZi5jbG9zZSA9IGNsb3NlO1xuICAgICAgICBzZWxmLl9jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDtcbiAgICAgICAgc2VsZi5kZXN0cm95ID0gZGVzdHJveTtcbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBpc0VuYWJsZWQ7XG4gICAgICAgIHNlbGYuanVtcFRvRGF0ZSA9IGp1bXBUb0RhdGU7XG4gICAgICAgIHNlbGYub3BlbiA9IG9wZW47XG4gICAgICAgIHNlbGYucmVkcmF3ID0gcmVkcmF3O1xuICAgICAgICBzZWxmLnNldCA9IHNldDtcbiAgICAgICAgc2VsZi5zZXREYXRlID0gc2V0RGF0ZTtcbiAgICAgICAgc2VsZi50b2dnbGUgPSB0b2dnbGU7XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwSGVscGVyRnVuY3Rpb25zKCkge1xuICAgICAgICAgICAgc2VsZi51dGlscyA9IHtcbiAgICAgICAgICAgICAgICBnZXREYXlzSW5Nb250aDogZnVuY3Rpb24gKG1vbnRoLCB5cikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9udGggPT09IHZvaWQgMCkgeyBtb250aCA9IHNlbGYuY3VycmVudE1vbnRoOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh5ciA9PT0gdm9pZCAwKSB7IHlyID0gc2VsZi5jdXJyZW50WWVhcjsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9udGggPT09IDEgJiYgKCh5ciAlIDQgPT09IDAgJiYgeXIgJSAxMDAgIT09IDApIHx8IHlyICUgNDAwID09PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAyOTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYubDEwbi5kYXlzSW5Nb250aFttb250aF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgICAgc2VsZi5lbGVtZW50ID0gc2VsZi5pbnB1dCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBzZWxmLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgcGFyc2VDb25maWcoKTtcbiAgICAgICAgICAgIHNldHVwTG9jYWxlKCk7XG4gICAgICAgICAgICBzZXR1cElucHV0cygpO1xuICAgICAgICAgICAgc2V0dXBEYXRlcygpO1xuICAgICAgICAgICAgc2V0dXBIZWxwZXJGdW5jdGlvbnMoKTtcbiAgICAgICAgICAgIGlmICghc2VsZi5pc01vYmlsZSlcbiAgICAgICAgICAgICAgICBidWlsZCgpO1xuICAgICAgICAgICAgYmluZEV2ZW50cygpO1xuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggfHwgc2VsZi5jb25maWcubm9DYWxlbmRhcikge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEhvdXJzRnJvbURhdGUoc2VsZi5jb25maWcubm9DYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiB8fCBzZWxmLmNvbmZpZy5taW5EYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENhbGVuZGFyV2lkdGgoKTtcbiAgICAgICAgICAgIHNlbGYuc2hvd1RpbWVJbnB1dCA9XG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDAgfHwgc2VsZi5jb25maWcubm9DYWxlbmRhcjtcbiAgICAgICAgICAgIHZhciBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgICAgICAvKiBUT0RPOiBpbnZlc3RpZ2F0ZSB0aGlzIGZ1cnRoZXJcbiAgICAgICAgXG4gICAgICAgICAgICAgIEN1cnJlbnRseSwgdGhlcmUgaXMgd2VpcmQgcG9zaXRpb25pbmcgYmVoYXZpb3IgaW4gc2FmYXJpIGNhdXNpbmcgcGFnZXNcbiAgICAgICAgICAgICAgdG8gc2Nyb2xsIHVwLiBodHRwczovL2dpdGh1Yi5jb20vY2htbG4vZmxhdHBpY2tyL2lzc3Vlcy81NjNcbiAgICAgICAgXG4gICAgICAgICAgICAgIEhvd2V2ZXIsIG1vc3QgYnJvd3NlcnMgYXJlIG5vdCBTYWZhcmkgYW5kIHBvc2l0aW9uaW5nIGlzIGV4cGVuc2l2ZSB3aGVuIHVzZWRcbiAgICAgICAgICAgICAgaW4gc2NhbGUuIGh0dHBzOi8vZ2l0aHViLmNvbS9jaG1sbi9mbGF0cGlja3IvaXNzdWVzLzEwOTZcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNNb2JpbGUgJiYgaXNTYWZhcmkpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNhbGVuZGFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblJlYWR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJpbmRUb0luc3RhbmNlKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYmluZChzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRDYWxlbmRhcldpZHRoKCkge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHNlbGYuY29uZmlnO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy53ZWVrTnVtYmVycyA9PT0gZmFsc2UgJiYgY29uZmlnLnNob3dNb250aHMgPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLm5vQ2FsZW5kYXIgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXlzV2lkdGggPSAoc2VsZi5kYXlzLm9mZnNldFdpZHRoICsgMSkgKiBjb25maWcuc2hvd01vbnRocztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci5zdHlsZS53aWR0aCA9IGRheXNXaWR0aCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUud2lkdGggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheXNXaWR0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZWxmLndlZWtXcmFwcGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi53ZWVrV3JhcHBlci5vZmZzZXRXaWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ2aXNpYmlsaXR5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhhbmRsZXIgZm9yIGFsbCBldmVudHMgdGFyZ2V0aW5nIHRoZSB0aW1lIGlucHV0c1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlVGltZShlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNldERlZmF1bHRUaW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZSAhPT0gdW5kZWZpbmVkICYmIGUudHlwZSAhPT0gXCJibHVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aW1lV3JhcHBlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSBzZWxmLl9pbnB1dC52YWx1ZTtcbiAgICAgICAgICAgIHNldEhvdXJzRnJvbUlucHV0cygpO1xuICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLl9pbnB1dC52YWx1ZSAhPT0gcHJldlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fZGVib3VuY2VkQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYW1wbTJtaWxpdGFyeShob3VyLCBhbVBNKSB7XG4gICAgICAgICAgICByZXR1cm4gKGhvdXIgJSAxMikgKyAxMiAqIGludChhbVBNID09PSBzZWxmLmwxMG4uYW1QTVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWlsaXRhcnkyYW1wbShob3VyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGhvdXIgJSAyNCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTI7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgJSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU3luY3MgdGhlIHNlbGVjdGVkIGRhdGUgb2JqZWN0IHRpbWUgd2l0aCB1c2VyJ3MgdGltZSBpbnB1dFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2V0SG91cnNGcm9tSW5wdXRzKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaG91ckVsZW1lbnQgPT09IHVuZGVmaW5lZCB8fCBzZWxmLm1pbnV0ZUVsZW1lbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaG91cnMgPSAocGFyc2VJbnQoc2VsZi5ob3VyRWxlbWVudC52YWx1ZS5zbGljZSgtMiksIDEwKSB8fCAwKSAlIDI0LCBtaW51dGVzID0gKHBhcnNlSW50KHNlbGYubWludXRlRWxlbWVudC52YWx1ZSwgMTApIHx8IDApICUgNjAsIHNlY29uZHMgPSBzZWxmLnNlY29uZEVsZW1lbnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gKHBhcnNlSW50KHNlbGYuc2Vjb25kRWxlbWVudC52YWx1ZSwgMTApIHx8IDApICUgNjBcbiAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBob3VycyA9IGFtcG0ybWlsaXRhcnkoaG91cnMsIHNlbGYuYW1QTS50ZXh0Q29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGltaXRNaW5Ib3VycyA9IHNlbGYuY29uZmlnLm1pblRpbWUgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWluRGF0ZUhhc1RpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLCBzZWxmLmNvbmZpZy5taW5EYXRlLCB0cnVlKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIDApO1xuICAgICAgICAgICAgdmFyIGxpbWl0TWF4SG91cnMgPSBzZWxmLmNvbmZpZy5tYXhUaW1lICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWF4RGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLm1heERhdGVIYXNUaW1lICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiwgc2VsZi5jb25maWcubWF4RGF0ZSwgdHJ1ZSkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAwKTtcbiAgICAgICAgICAgIGlmIChsaW1pdE1heEhvdXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heFRpbWUgPSBzZWxmLmNvbmZpZy5tYXhUaW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5tYXhUaW1lXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWF4RGF0ZTtcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGgubWluKGhvdXJzLCBtYXhUaW1lLmdldEhvdXJzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWF4VGltZS5nZXRIb3VycygpKVxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5taW4obWludXRlcywgbWF4VGltZS5nZXRNaW51dGVzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtaW51dGVzID09PSBtYXhUaW1lLmdldE1pbnV0ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGgubWluKHNlY29uZHMsIG1heFRpbWUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdE1pbkhvdXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pblRpbWUgPSBzZWxmLmNvbmZpZy5taW5UaW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5taW5UaW1lXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWluRGF0ZTtcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGgubWF4KGhvdXJzLCBtaW5UaW1lLmdldEhvdXJzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWluVGltZS5nZXRIb3VycygpKVxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5tYXgobWludXRlcywgbWluVGltZS5nZXRNaW51dGVzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtaW51dGVzID09PSBtaW5UaW1lLmdldE1pbnV0ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGgubWF4KHNlY29uZHMsIG1pblRpbWUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEhvdXJzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU3luY3MgdGltZSBpbnB1dCB2YWx1ZXMgd2l0aCBhIGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHNldEhvdXJzRnJvbURhdGUoZGF0ZU9iaikge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBkYXRlT2JqIHx8IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqO1xuICAgICAgICAgICAgaWYgKGRhdGUpXG4gICAgICAgICAgICAgICAgc2V0SG91cnMoZGF0ZS5nZXRIb3VycygpLCBkYXRlLmdldE1pbnV0ZXMoKSwgZGF0ZS5nZXRTZWNvbmRzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldERlZmF1bHRIb3VycygpIHtcbiAgICAgICAgICAgIHZhciBob3VycyA9IHNlbGYuY29uZmlnLmRlZmF1bHRIb3VyO1xuICAgICAgICAgICAgdmFyIG1pbnV0ZXMgPSBzZWxmLmNvbmZpZy5kZWZhdWx0TWludXRlO1xuICAgICAgICAgICAgdmFyIHNlY29uZHMgPSBzZWxmLmNvbmZpZy5kZWZhdWx0U2Vjb25kcztcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5taW5EYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluX2hyID0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRIb3VycygpO1xuICAgICAgICAgICAgICAgIHZhciBtaW5fbWludXRlcyA9IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0TWludXRlcygpO1xuICAgICAgICAgICAgICAgIGhvdXJzID0gTWF0aC5tYXgoaG91cnMsIG1pbl9ocik7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtaW5faHIpXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLm1heChtaW5fbWludXRlcywgbWludXRlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtaW5faHIgJiYgbWludXRlcyA9PT0gbWluX21pbnV0ZXMpXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldFNlY29uZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tYXhEYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4X2hyID0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRIb3VycygpO1xuICAgICAgICAgICAgICAgIHZhciBtYXhfbWludXRlcyA9IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TWludXRlcygpO1xuICAgICAgICAgICAgICAgIGhvdXJzID0gTWF0aC5taW4oaG91cnMsIG1heF9ocik7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtYXhfaHIpXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLm1pbihtYXhfbWludXRlcywgbWludXRlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtYXhfaHIgJiYgbWludXRlcyA9PT0gbWF4X21pbnV0ZXMpXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldFNlY29uZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEhvdXJzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgaG91cnMsIG1pbnV0ZXMsIGFuZCBvcHRpb25hbGx5IHNlY29uZHNcbiAgICAgICAgICogb2YgdGhlIGxhdGVzdCBzZWxlY3RlZCBkYXRlIG9iamVjdCBhbmQgdGhlXG4gICAgICAgICAqIGNvcnJlc3BvbmRpbmcgdGltZSBpbnB1dHNcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvdXJzIHRoZSBob3VyLiB3aGV0aGVyIGl0cyBtaWxpdGFyeVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgb3IgYW0tcG0gZ2V0cyBpbmZlcnJlZCBmcm9tIGNvbmZpZ1xuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbWludXRlcyB0aGUgbWludXRlc1xuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kcyB0aGUgc2Vjb25kcyAob3B0aW9uYWwpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBzZXRIb3Vycyhob3VycywgbWludXRlcywgc2Vjb25kcykge1xuICAgICAgICAgICAgaWYgKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iai5zZXRIb3Vycyhob3VycyAlIDI0LCBtaW51dGVzLCBzZWNvbmRzIHx8IDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxmLmhvdXJFbGVtZW50IHx8ICFzZWxmLm1pbnV0ZUVsZW1lbnQgfHwgc2VsZi5pc01vYmlsZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LnZhbHVlID0gcGFkKCFzZWxmLmNvbmZpZy50aW1lXzI0aHJcbiAgICAgICAgICAgICAgICA/ICgoMTIgKyBob3VycykgJSAxMikgKyAxMiAqIGludChob3VycyAlIDEyID09PSAwKVxuICAgICAgICAgICAgICAgIDogaG91cnMpO1xuICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50LnZhbHVlID0gcGFkKG1pbnV0ZXMpO1xuICAgICAgICAgICAgaWYgKHNlbGYuYW1QTSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50ZXh0Q29udGVudCA9IHNlbGYubDEwbi5hbVBNW2ludChob3VycyA+PSAxMildO1xuICAgICAgICAgICAgaWYgKHNlbGYuc2Vjb25kRWxlbWVudCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudC52YWx1ZSA9IHBhZChzZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyB0aGUgeWVhciBpbnB1dCBhbmQgaW5jcmVtZW50aW5nIGV2ZW50c1xuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCB0aGUga2V5dXAgb3IgaW5jcmVtZW50IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBvblllYXJJbnB1dChldmVudCkge1xuICAgICAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludChldmVudC50YXJnZXQudmFsdWUpICsgKGV2ZW50LmRlbHRhIHx8IDApO1xuICAgICAgICAgICAgaWYgKHllYXIgLyAxMDAwID4gMSB8fFxuICAgICAgICAgICAgICAgIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiAmJiAhL1teXFxkXS8udGVzdCh5ZWFyLnRvU3RyaW5nKCkpKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZVllYXIoeWVhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVzc2VudGlhbGx5IGFkZEV2ZW50TGlzdGVuZXIgKyB0cmFja2luZ1xuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gYWRkRXZlbnRMaXN0ZW5lciB0b1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgdGhlIGV2ZW50IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciB0aGUgZXZlbnQgaGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYmluZChlbGVtZW50LCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmZvckVhY2goZnVuY3Rpb24gKGV2KSB7IHJldHVybiBiaW5kKGVsZW1lbnQsIGV2LCBoYW5kbGVyLCBvcHRpb25zKTsgfSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmZvckVhY2goZnVuY3Rpb24gKGVsKSB7IHJldHVybiBiaW5kKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7IH0pO1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHNlbGYuX2hhbmRsZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbW91c2Vkb3duIGhhbmRsZXIgd2hpY2ggbWltaWNzIGNsaWNrLlxuICAgICAgICAgKiBNaW5pbWl6ZXMgbGF0ZW5jeSwgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byB3YWl0IGZvciBtb3VzZXVwIGluIG1vc3QgY2FzZXMuXG4gICAgICAgICAqIEFsc28sIGF2b2lkcyBoYW5kbGluZyByaWdodCBjbGlja3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgdGhlIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIG9uQ2xpY2soaGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICBldnQud2hpY2ggPT09IDEgJiYgaGFuZGxlcihldnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyQ2hhbmdlKCkge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25DaGFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBiaW5kRXZlbnRzKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLndyYXApIHtcbiAgICAgICAgICAgICAgICBbXCJvcGVuXCIsIFwiY2xvc2VcIiwgXCJ0b2dnbGVcIiwgXCJjbGVhclwiXS5mb3JFYWNoKGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChzZWxmLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLVwiICsgZXZ0ICsgXCJdXCIpLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5kKGVsLCBcImNsaWNrXCIsIHNlbGZbZXZ0XSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaXNNb2JpbGUpIHtcbiAgICAgICAgICAgICAgICBzZXR1cE1vYmlsZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkZWJvdW5jZWRSZXNpemUgPSBkZWJvdW5jZShvblJlc2l6ZSwgNTApO1xuICAgICAgICAgICAgc2VsZi5fZGVib3VuY2VkQ2hhbmdlID0gZGVib3VuY2UodHJpZ2dlckNoYW5nZSwgREVCT1VOQ0VEX0NIQU5HRV9NUyk7XG4gICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICYmICEvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpXG4gICAgICAgICAgICAgICAgYmluZChzZWxmLmRheXNDb250YWluZXIsIFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlT3ZlcihlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiaW5kKHdpbmRvdy5kb2N1bWVudC5ib2R5LCBcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcuc3RhdGljKVxuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5faW5wdXQsIFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5pbmxpbmUgJiYgIXNlbGYuY29uZmlnLnN0YXRpYylcbiAgICAgICAgICAgICAgICBiaW5kKHdpbmRvdywgXCJyZXNpemVcIiwgZGVib3VuY2VkUmVzaXplKTtcbiAgICAgICAgICAgIGlmICh3aW5kb3cub250b3VjaHN0YXJ0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgYmluZCh3aW5kb3cuZG9jdW1lbnQsIFwiY2xpY2tcIiwgZG9jdW1lbnRDbGljayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYmluZCh3aW5kb3cuZG9jdW1lbnQsIFwibW91c2Vkb3duXCIsIG9uQ2xpY2soZG9jdW1lbnRDbGljaykpO1xuICAgICAgICAgICAgYmluZCh3aW5kb3cuZG9jdW1lbnQsIFwiZm9jdXNcIiwgZG9jdW1lbnRDbGljaywgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmNsaWNrT3BlbnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYuX2lucHV0LCBcImZvY3VzXCIsIHNlbGYub3Blbik7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLl9pbnB1dCwgXCJtb3VzZWRvd25cIiwgb25DbGljayhzZWxmLm9wZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5tb250aE5hdiwgXCJtb3VzZWRvd25cIiwgb25DbGljayhvbk1vbnRoTmF2Q2xpY2spKTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYubW9udGhOYXYsIFtcImtleXVwXCIsIFwiaW5jcmVtZW50XCJdLCBvblllYXJJbnB1dCk7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLmRheXNDb250YWluZXIsIFwibW91c2Vkb3duXCIsIG9uQ2xpY2soc2VsZWN0RGF0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYudGltZUNvbnRhaW5lciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsVGV4dCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnRhcmdldC5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi50aW1lQ29udGFpbmVyLCBbXCJpbmNyZW1lbnRcIl0sIHVwZGF0ZVRpbWUpO1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi50aW1lQ29udGFpbmVyLCBcImJsdXJcIiwgdXBkYXRlVGltZSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi50aW1lQ29udGFpbmVyLCBcIm1vdXNlZG93blwiLCBvbkNsaWNrKHRpbWVJbmNyZW1lbnQpKTtcbiAgICAgICAgICAgICAgICBiaW5kKFtzZWxmLmhvdXJFbGVtZW50LCBzZWxmLm1pbnV0ZUVsZW1lbnRdLCBbXCJmb2N1c1wiLCBcImNsaWNrXCJdLCBzZWxUZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZWNvbmRFbGVtZW50ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5zZWNvbmRFbGVtZW50LCBcImZvY3VzXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuc2Vjb25kRWxlbWVudCAmJiBzZWxmLnNlY29uZEVsZW1lbnQuc2VsZWN0KCk7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBiaW5kKHNlbGYuYW1QTSwgXCJtb3VzZWRvd25cIiwgb25DbGljayhmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGltZShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjYWxlbmRhciB2aWV3IHRvIGEgcGFydGljdWxhciBkYXRlLlxuICAgICAgICAgKiBAcGFyYW0ge0RhdGV9IGp1bXBEYXRlIHRoZSBkYXRlIHRvIHNldCB0aGUgdmlldyB0b1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24ganVtcFRvRGF0ZShqdW1wRGF0ZSkge1xuICAgICAgICAgICAgdmFyIGp1bXBUbyA9IGp1bXBEYXRlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHNlbGYucGFyc2VEYXRlKGp1bXBEYXRlKVxuICAgICAgICAgICAgICAgIDogc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogfHxcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1pbkRhdGUgJiYgc2VsZi5jb25maWcubWluRGF0ZSA+IHNlbGYubm93XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1pbkRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWF4RGF0ZSAmJiBzZWxmLmNvbmZpZy5tYXhEYXRlIDwgc2VsZi5ub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1heERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYubm93KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGp1bXBUbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBqdW1wVG8uZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBqdW1wVG8uZ2V0TW9udGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gXCJJbnZhbGlkIGRhdGUgc3VwcGxpZWQ6IFwiICsganVtcFRvO1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmVycm9ySGFuZGxlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1cC9kb3duIGFycm93IGhhbmRsZXIgZm9yIHRpbWUgaW5wdXRzXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgdGhlIGNsaWNrIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB0aW1lSW5jcmVtZW50KGUpIHtcbiAgICAgICAgICAgIGlmICh+ZS50YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoXCJhcnJvd1wiKSlcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnROdW1JbnB1dChlLCBlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJhcnJvd1VwXCIpID8gMSA6IC0xKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW5jcmVtZW50cy9kZWNyZW1lbnRzIHRoZSB2YWx1ZSBvZiBpbnB1dCBhc3NvY2ktXG4gICAgICAgICAqIGF0ZWQgd2l0aCB0aGUgdXAvZG93biBhcnJvdyBieSBkaXNwYXRjaGluZyBhblxuICAgICAgICAgKiBcImluY3JlbWVudFwiIGV2ZW50IG9uIHRoZSBpbnB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSB0aGUgY2xpY2sgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIHRoZSBkaWZmICh1c3VhbGx5IDEgb3IgLTEpXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gaW5wdXRFbGVtIHRoZSBpbnB1dCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpbmNyZW1lbnROdW1JbnB1dChlLCBkZWx0YSwgaW5wdXRFbGVtKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZSAmJiBlLnRhcmdldDtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGlucHV0RWxlbSB8fFxuICAgICAgICAgICAgICAgICh0YXJnZXQgJiYgdGFyZ2V0LnBhcmVudE5vZGUgJiYgdGFyZ2V0LnBhcmVudE5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBjcmVhdGVFdmVudChcImluY3JlbWVudFwiKTtcbiAgICAgICAgICAgIGV2ZW50LmRlbHRhID0gZGVsdGE7XG4gICAgICAgICAgICBpbnB1dCAmJiBpbnB1dC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1jYWxlbmRhclwiKTtcbiAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcubm9DYWxlbmRhcikge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGJ1aWxkTW9udGhOYXYoKSk7XG4gICAgICAgICAgICAgICAgc2VsZi5pbm5lckNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItaW5uZXJDb250YWluZXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLndlZWtOdW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGJ1aWxkV2Vla3MoKSwgd2Vla1dyYXBwZXIgPSBfYS53ZWVrV3JhcHBlciwgd2Vla051bWJlcnMgPSBfYS53ZWVrTnVtYmVycztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbm5lckNvbnRhaW5lci5hcHBlbmRDaGlsZCh3ZWVrV3JhcHBlcik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYud2Vla051bWJlcnMgPSB3ZWVrTnVtYmVycztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi53ZWVrV3JhcHBlciA9IHdlZWtXcmFwcGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnJDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXJDb250YWluZXJcIik7XG4gICAgICAgICAgICAgICAgc2VsZi5yQ29udGFpbmVyLmFwcGVuZENoaWxkKGJ1aWxkV2Vla2RheXMoKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLmRheXNDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXlzQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1kYXlzXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRheXNDb250YWluZXIudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVpbGREYXlzKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5yQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlbGYuZGF5c0NvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgc2VsZi5pbm5lckNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxmLnJDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHNlbGYuaW5uZXJDb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChidWlsZFRpbWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcInJhbmdlTW9kZVwiLCBzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJhbmltYXRlXCIsIHNlbGYuY29uZmlnLmFuaW1hdGUgPT09IHRydWUpO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJtdWx0aU1vbnRoXCIsIHNlbGYuY29uZmlnLnNob3dNb250aHMgPiAxKTtcbiAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgdmFyIGN1c3RvbUFwcGVuZCA9IHNlbGYuY29uZmlnLmFwcGVuZFRvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hcHBlbmRUby5ub2RlVHlwZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmlubGluZSB8fCBzZWxmLmNvbmZpZy5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoc2VsZi5jb25maWcuaW5saW5lID8gXCJpbmxpbmVcIiA6IFwic3RhdGljXCIpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5pbmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXN0b21BcHBlbmQgJiYgc2VsZi5lbGVtZW50LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgc2VsZi5faW5wdXQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxmLmNvbmZpZy5hcHBlbmRUbyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcuYXBwZW5kVG8uYXBwZW5kQ2hpbGQoc2VsZi5jYWxlbmRhckNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdyYXBwZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmVsZW1lbnQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh3cmFwcGVyLCBzZWxmLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHNlbGYuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFsdElucHV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChzZWxmLmFsdElucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGYuY29uZmlnLnN0YXRpYyAmJiAhc2VsZi5jb25maWcuaW5saW5lKVxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5hcHBlbmRUbyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcuYXBwZW5kVG9cbiAgICAgICAgICAgICAgICAgICAgOiB3aW5kb3cuZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2VsZi5jYWxlbmRhckNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRGF5KGNsYXNzTmFtZSwgZGF0ZSwgZGF5TnVtYmVyLCBpKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZUlzRW5hYmxlZCA9IGlzRW5hYmxlZChkYXRlLCB0cnVlKSwgZGF5RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLWRheSBcIiArIGNsYXNzTmFtZSwgZGF0ZS5nZXREYXRlKCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBkYXlFbGVtZW50LmRhdGVPYmogPSBkYXRlO1xuICAgICAgICAgICAgZGF5RWxlbWVudC4kaSA9IGk7XG4gICAgICAgICAgICBkYXlFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgc2VsZi5mb3JtYXREYXRlKGRhdGUsIHNlbGYuY29uZmlnLmFyaWFEYXRlRm9ybWF0KSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lLmluZGV4T2YoXCJoaWRkZW5cIikgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKGRhdGUsIHNlbGYubm93KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNlbGYudG9kYXlEYXRlRWxlbSA9IGRheUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgZGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwidG9kYXlcIik7XG4gICAgICAgICAgICAgICAgZGF5RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIiwgXCJkYXRlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVJc0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBkYXlFbGVtZW50LnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGF0ZVNlbGVjdGVkKGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZUVsZW0gPSBkYXlFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhkYXlFbGVtZW50LCBcInN0YXJ0UmFuZ2VcIiwgc2VsZi5zZWxlY3RlZERhdGVzWzBdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKGRhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1swXSwgdHJ1ZSkgPT09IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZGF5RWxlbWVudCwgXCJlbmRSYW5nZVwiLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzFdLCB0cnVlKSA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09PSBcIm5leHRNb250aERheVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImluUmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXlFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEYXRlSW5SYW5nZShkYXRlKSAmJiAhaXNEYXRlU2VsZWN0ZWQoZGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImluUmFuZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi53ZWVrTnVtYmVycyAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLnNob3dNb250aHMgPT09IDEgJiZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgIT09IFwicHJldk1vbnRoRGF5XCIgJiZcbiAgICAgICAgICAgICAgICBkYXlOdW1iZXIgJSA3ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2VsZi53ZWVrTnVtYmVycy5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgXCI8c3BhbiBjbGFzcz0nZmxhdHBpY2tyLWRheSc+XCIgKyBzZWxmLmNvbmZpZy5nZXRXZWVrKGRhdGUpICsgXCI8L3NwYW4+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25EYXlDcmVhdGVcIiwgZGF5RWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gZGF5RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb2N1c09uRGF5RWxlbSh0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICB0YXJnZXROb2RlLmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKVxuICAgICAgICAgICAgICAgIG9uTW91c2VPdmVyKHRhcmdldE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEZpcnN0QXZhaWxhYmxlRGF5KGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRNb250aCA9IGRlbHRhID4gMCA/IDAgOiBzZWxmLmNvbmZpZy5zaG93TW9udGhzIC0gMTtcbiAgICAgICAgICAgIHZhciBlbmRNb250aCA9IGRlbHRhID4gMCA/IHNlbGYuY29uZmlnLnNob3dNb250aHMgOiAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIG0gPSBzdGFydE1vbnRoOyBtICE9IGVuZE1vbnRoOyBtICs9IGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gc2VsZi5kYXlzQ29udGFpbmVyLmNoaWxkcmVuW21dO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gZGVsdGEgPiAwID8gMCA6IG1vbnRoLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gZGVsdGEgPiAwID8gbW9udGguY2hpbGRyZW4ubGVuZ3RoIDogLTE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgIT0gZW5kSW5kZXg7IGkgKz0gZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBtb250aC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuY2xhc3NOYW1lLmluZGV4T2YoXCJoaWRkZW5cIikgPT09IC0xICYmIGlzRW5hYmxlZChjLmRhdGVPYmopKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0QXZhaWxhYmxlRGF5KGN1cnJlbnQsIGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgZ2l2ZW5Nb250aCA9IGN1cnJlbnQuY2xhc3NOYW1lLmluZGV4T2YoXCJNb250aFwiKSA9PT0gLTFcbiAgICAgICAgICAgICAgICA/IGN1cnJlbnQuZGF0ZU9iai5nZXRNb250aCgpXG4gICAgICAgICAgICAgICAgOiBzZWxmLmN1cnJlbnRNb250aDtcbiAgICAgICAgICAgIHZhciBlbmRNb250aCA9IGRlbHRhID4gMCA/IHNlbGYuY29uZmlnLnNob3dNb250aHMgOiAtMTtcbiAgICAgICAgICAgIHZhciBsb29wRGVsdGEgPSBkZWx0YSA+IDAgPyAxIDogLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBtID0gZ2l2ZW5Nb250aCAtIHNlbGYuY3VycmVudE1vbnRoOyBtICE9IGVuZE1vbnRoOyBtICs9IGxvb3BEZWx0YSkge1xuICAgICAgICAgICAgICAgIHZhciBtb250aCA9IHNlbGYuZGF5c0NvbnRhaW5lci5jaGlsZHJlblttXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IGdpdmVuTW9udGggLSBzZWxmLmN1cnJlbnRNb250aCA9PT0gbVxuICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnQuJGkgKyBkZWx0YVxuICAgICAgICAgICAgICAgICAgICA6IGRlbHRhIDwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtb250aC5jaGlsZHJlbi5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICAgICAgdmFyIG51bU1vbnRoRGF5cyA9IG1vbnRoLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA+PSAwICYmIGkgPCBudW1Nb250aERheXMgJiYgaSAhPSAoZGVsdGEgPiAwID8gbnVtTW9udGhEYXlzIDogLTEpOyBpICs9IGxvb3BEZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG1vbnRoLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5jbGFzc05hbWUuaW5kZXhPZihcImhpZGRlblwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRW5hYmxlZChjLmRhdGVPYmopICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhjdXJyZW50LiRpIC0gaSkgPj0gTWF0aC5hYnMoZGVsdGEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzT25EYXlFbGVtKGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuY2hhbmdlTW9udGgobG9vcERlbHRhKTtcbiAgICAgICAgICAgIGZvY3VzT25EYXkoZ2V0Rmlyc3RBdmFpbGFibGVEYXkobG9vcERlbHRhKSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvY3VzT25EYXkoY3VycmVudCwgb2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgZGF5Rm9jdXNlZCA9IGlzSW5WaWV3KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICB2YXIgc3RhcnRFbGVtID0gY3VycmVudCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBjdXJyZW50XG4gICAgICAgICAgICAgICAgOiBkYXlGb2N1c2VkXG4gICAgICAgICAgICAgICAgICAgID8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuc2VsZWN0ZWREYXRlRWxlbSAhPT0gdW5kZWZpbmVkICYmIGlzSW5WaWV3KHNlbGYuc2VsZWN0ZWREYXRlRWxlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5zZWxlY3RlZERhdGVFbGVtXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYudG9kYXlEYXRlRWxlbSAhPT0gdW5kZWZpbmVkICYmIGlzSW5WaWV3KHNlbGYudG9kYXlEYXRlRWxlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYudG9kYXlEYXRlRWxlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZ2V0Rmlyc3RBdmFpbGFibGVEYXkob2Zmc2V0ID4gMCA/IDEgOiAtMSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRFbGVtID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2lucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAoIWRheUZvY3VzZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzT25EYXlFbGVtKHN0YXJ0RWxlbSk7XG4gICAgICAgICAgICBnZXROZXh0QXZhaWxhYmxlRGF5KHN0YXJ0RWxlbSwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZE1vbnRoRGF5cyh5ZWFyLCBtb250aCkge1xuICAgICAgICAgICAgdmFyIGZpcnN0T2ZNb250aCA9IChuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSkuZ2V0RGF5KCkgLSBzZWxmLmwxMG4uZmlyc3REYXlPZldlZWsgKyA3KSAlIDc7XG4gICAgICAgICAgICB2YXIgcHJldk1vbnRoRGF5cyA9IHNlbGYudXRpbHMuZ2V0RGF5c0luTW9udGgoKG1vbnRoIC0gMSArIDEyKSAlIDEyKTtcbiAgICAgICAgICAgIHZhciBkYXlzSW5Nb250aCA9IHNlbGYudXRpbHMuZ2V0RGF5c0luTW9udGgobW9udGgpLCBkYXlzID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgaXNNdWx0aU1vbnRoID0gc2VsZi5jb25maWcuc2hvd01vbnRocyA+IDEsIHByZXZNb250aERheUNsYXNzID0gaXNNdWx0aU1vbnRoID8gXCJwcmV2TW9udGhEYXkgaGlkZGVuXCIgOiBcInByZXZNb250aERheVwiLCBuZXh0TW9udGhEYXlDbGFzcyA9IGlzTXVsdGlNb250aCA/IFwibmV4dE1vbnRoRGF5IGhpZGRlblwiIDogXCJuZXh0TW9udGhEYXlcIjtcbiAgICAgICAgICAgIHZhciBkYXlOdW1iZXIgPSBwcmV2TW9udGhEYXlzICsgMSAtIGZpcnN0T2ZNb250aCwgZGF5SW5kZXggPSAwO1xuICAgICAgICAgICAgLy8gcHJlcGVuZCBkYXlzIGZyb20gdGhlIGVuZGluZyBvZiBwcmV2aW91cyBtb250aFxuICAgICAgICAgICAgZm9yICg7IGRheU51bWJlciA8PSBwcmV2TW9udGhEYXlzOyBkYXlOdW1iZXIrKywgZGF5SW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGRheXMuYXBwZW5kQ2hpbGQoY3JlYXRlRGF5KHByZXZNb250aERheUNsYXNzLCBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheU51bWJlciksIGRheU51bWJlciwgZGF5SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IGF0IDEgc2luY2UgdGhlcmUgaXMgbm8gMHRoIGRheVxuICAgICAgICAgICAgZm9yIChkYXlOdW1iZXIgPSAxOyBkYXlOdW1iZXIgPD0gZGF5c0luTW9udGg7IGRheU51bWJlcisrLCBkYXlJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZGF5cy5hcHBlbmRDaGlsZChjcmVhdGVEYXkoXCJcIiwgbmV3IERhdGUoeWVhciwgbW9udGgsIGRheU51bWJlciksIGRheU51bWJlciwgZGF5SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGVuZCBkYXlzIGZyb20gdGhlIG5leHQgbW9udGhcbiAgICAgICAgICAgIGZvciAodmFyIGRheU51bSA9IGRheXNJbk1vbnRoICsgMTsgZGF5TnVtIDw9IDQyIC0gZmlyc3RPZk1vbnRoICYmXG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLnNob3dNb250aHMgPT09IDEgfHwgZGF5SW5kZXggJSA3ICE9PSAwKTsgZGF5TnVtKyssIGRheUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBkYXlzLmFwcGVuZENoaWxkKGNyZWF0ZURheShuZXh0TW9udGhEYXlDbGFzcywgbmV3IERhdGUoeWVhciwgbW9udGggKyAxLCBkYXlOdW0gJSBkYXlzSW5Nb250aCksIGRheU51bSwgZGF5SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICAgICAgdmFyIGRheUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJkYXlDb250YWluZXJcIik7XG4gICAgICAgICAgICBkYXlDb250YWluZXIuYXBwZW5kQ2hpbGQoZGF5cyk7XG4gICAgICAgICAgICByZXR1cm4gZGF5Q29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkRGF5cygpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFyTm9kZShzZWxmLmRheXNDb250YWluZXIpO1xuICAgICAgICAgICAgLy8gVE9ETzogd2VlayBudW1iZXJzIGZvciBlYWNoIG1vbnRoXG4gICAgICAgICAgICBpZiAoc2VsZi53ZWVrTnVtYmVycylcbiAgICAgICAgICAgICAgICBjbGVhck5vZGUoc2VsZi53ZWVrTnVtYmVycyk7XG4gICAgICAgICAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5jb25maWcuc2hvd01vbnRoczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZShzZWxmLmN1cnJlbnRZZWFyLCBzZWxmLmN1cnJlbnRNb250aCwgMSk7XG4gICAgICAgICAgICAgICAgZC5zZXRNb250aChzZWxmLmN1cnJlbnRNb250aCArIGkpO1xuICAgICAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoYnVpbGRNb250aERheXMoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnKTtcbiAgICAgICAgICAgIHNlbGYuZGF5cyA9IHNlbGYuZGF5c0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIiAmJiBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgb25Nb3VzZU92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZE1vbnRoKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItbW9udGhcIik7XG4gICAgICAgICAgICB2YXIgbW9udGhOYXZGcmFnbWVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICB2YXIgbW9udGhFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJjdXItbW9udGhcIik7XG4gICAgICAgICAgICB2YXIgeWVhcklucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJjdXIteWVhclwiLCB7IHRhYmluZGV4OiBcIi0xXCIgfSk7XG4gICAgICAgICAgICB2YXIgeWVhckVsZW1lbnQgPSB5ZWFySW5wdXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXTtcbiAgICAgICAgICAgIHllYXJFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgc2VsZi5sMTBuLnllYXJBcmlhTGFiZWwpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1pbkRhdGUpIHtcbiAgICAgICAgICAgICAgICB5ZWFyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtaW5cIiwgc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1heERhdGUpIHtcbiAgICAgICAgICAgICAgICB5ZWFyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtYXhcIiwgc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHllYXJFbGVtZW50LmRpc2FibGVkID1cbiAgICAgICAgICAgICAgICAgICAgISFzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkgPT09IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjdXJyZW50TW9udGggPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLWN1cnJlbnQtbW9udGhcIik7XG4gICAgICAgICAgICBjdXJyZW50TW9udGguYXBwZW5kQ2hpbGQobW9udGhFbGVtZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnRNb250aC5hcHBlbmRDaGlsZCh5ZWFySW5wdXQpO1xuICAgICAgICAgICAgbW9udGhOYXZGcmFnbWVudC5hcHBlbmRDaGlsZChjdXJyZW50TW9udGgpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG1vbnRoTmF2RnJhZ21lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICB5ZWFyRWxlbWVudDogeWVhckVsZW1lbnQsXG4gICAgICAgICAgICAgICAgbW9udGhFbGVtZW50OiBtb250aEVsZW1lbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRNb250aHMoKSB7XG4gICAgICAgICAgICBjbGVhck5vZGUoc2VsZi5tb250aE5hdik7XG4gICAgICAgICAgICBzZWxmLm1vbnRoTmF2LmFwcGVuZENoaWxkKHNlbGYucHJldk1vbnRoTmF2KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5zaG93TW9udGhzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi55ZWFyRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBzZWxmLm1vbnRoRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIG0gPSBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBtLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gYnVpbGRNb250aCgpO1xuICAgICAgICAgICAgICAgIHNlbGYueWVhckVsZW1lbnRzLnB1c2gobW9udGgueWVhckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHNlbGYubW9udGhFbGVtZW50cy5wdXNoKG1vbnRoLm1vbnRoRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgc2VsZi5tb250aE5hdi5hcHBlbmRDaGlsZChtb250aC5jb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5tb250aE5hdi5hcHBlbmRDaGlsZChzZWxmLm5leHRNb250aE5hdik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRNb250aE5hdigpIHtcbiAgICAgICAgICAgIHNlbGYubW9udGhOYXYgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLW1vbnRoc1wiKTtcbiAgICAgICAgICAgIHNlbGYueWVhckVsZW1lbnRzID0gW107XG4gICAgICAgICAgICBzZWxmLm1vbnRoRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIHNlbGYucHJldk1vbnRoTmF2ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItcHJldi1tb250aFwiKTtcbiAgICAgICAgICAgIHNlbGYucHJldk1vbnRoTmF2LmlubmVySFRNTCA9IHNlbGYuY29uZmlnLnByZXZBcnJvdztcbiAgICAgICAgICAgIHNlbGYubmV4dE1vbnRoTmF2ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItbmV4dC1tb250aFwiKTtcbiAgICAgICAgICAgIHNlbGYubmV4dE1vbnRoTmF2LmlubmVySFRNTCA9IHNlbGYuY29uZmlnLm5leHRBcnJvdztcbiAgICAgICAgICAgIGJ1aWxkTW9udGhzKCk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgXCJfaGlkZVByZXZNb250aEFycm93XCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuX19oaWRlUHJldk1vbnRoQXJyb3c7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fX2hpZGVQcmV2TW9udGhBcnJvdyAhPT0gYm9vbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5wcmV2TW9udGhOYXYsIFwiZGlzYWJsZWRcIiwgYm9vbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9faGlkZVByZXZNb250aEFycm93ID0gYm9vbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIFwiX2hpZGVOZXh0TW9udGhBcnJvd1wiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLl9faGlkZU5leHRNb250aEFycm93OyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX19oaWRlTmV4dE1vbnRoQXJyb3cgIT09IGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYubmV4dE1vbnRoTmF2LCBcImRpc2FibGVkXCIsIGJvb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fX2hpZGVOZXh0TW9udGhBcnJvdyA9IGJvb2w7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXJFbGVtZW50ID0gc2VsZi55ZWFyRWxlbWVudHNbMF07XG4gICAgICAgICAgICB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5tb250aE5hdjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZFRpbWUoKSB7XG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoYXNUaW1lXCIpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIpXG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibm9DYWxlbmRhclwiKTtcbiAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItdGltZVwiKTtcbiAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLXRpbWUtc2VwYXJhdG9yXCIsIFwiOlwiKTtcbiAgICAgICAgICAgIHZhciBob3VySW5wdXQgPSBjcmVhdGVOdW1iZXJJbnB1dChcImZsYXRwaWNrci1ob3VyXCIpO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudCA9IGhvdXJJbnB1dC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdO1xuICAgICAgICAgICAgdmFyIG1pbnV0ZUlucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJmbGF0cGlja3ItbWludXRlXCIpO1xuICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50ID0gbWludXRlSW5wdXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQudGFiSW5kZXggPSBzZWxmLm1pbnV0ZUVsZW1lbnQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQudmFsdWUgPSBwYWQoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmpcbiAgICAgICAgICAgICAgICA/IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLmdldEhvdXJzKClcbiAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLnRpbWVfMjRoclxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLmRlZmF1bHRIb3VyXG4gICAgICAgICAgICAgICAgICAgIDogbWlsaXRhcnkyYW1wbShzZWxmLmNvbmZpZy5kZWZhdWx0SG91cikpO1xuICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50LnZhbHVlID0gcGFkKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqXG4gICAgICAgICAgICAgICAgPyBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iai5nZXRNaW51dGVzKClcbiAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLmRlZmF1bHRNaW51dGUpO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdGVwXCIsIHNlbGYuY29uZmlnLmhvdXJJbmNyZW1lbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3RlcFwiLCBzZWxmLmNvbmZpZy5taW51dGVJbmNyZW1lbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1pblwiLCBzZWxmLmNvbmZpZy50aW1lXzI0aHIgPyBcIjBcIiA6IFwiMVwiKTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWF4XCIsIHNlbGYuY29uZmlnLnRpbWVfMjRociA/IFwiMjNcIiA6IFwiMTJcIik7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWluXCIsIFwiMFwiKTtcbiAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtYXhcIiwgXCI1OVwiKTtcbiAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChob3VySW5wdXQpO1xuICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlcGFyYXRvcik7XG4gICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQobWludXRlSW5wdXQpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRpbWVfMjRocilcbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuY2xhc3NMaXN0LmFkZChcInRpbWUyNGhyXCIpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc1NlY29uZHNcIik7XG4gICAgICAgICAgICAgICAgdmFyIHNlY29uZElucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJmbGF0cGlja3Itc2Vjb25kXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudCA9IHNlY29uZElucHV0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF07XG4gICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LnZhbHVlID0gcGFkKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmouZ2V0U2Vjb25kcygpXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGVmYXVsdFNlY29uZHMpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdGVwXCIsIHNlbGYubWludXRlRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzdGVwXCIpKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWluXCIsIFwiMFwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWF4XCIsIFwiNTlcIik7XG4gICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLXRpbWUtc2VwYXJhdG9yXCIsIFwiOlwiKSk7XG4gICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlY29uZElucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcudGltZV8yNGhyKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHNlbGYuYW1QTSBpZiBhcHByb3ByaWF0ZVxuICAgICAgICAgICAgICAgIHNlbGYuYW1QTSA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLWFtLXBtXCIsIHNlbGYubDEwbi5hbVBNW2ludCgoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmpcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmhvdXJFbGVtZW50LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGVmYXVsdEhvdXIpID4gMTEpXSk7XG4gICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRpdGxlID0gc2VsZi5sMTBuLnRvZ2dsZVRpdGxlO1xuICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxmLmFtUE0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGYudGltZUNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZFdlZWtkYXlzKCkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLndlZWtkYXlDb250YWluZXIpXG4gICAgICAgICAgICAgICAgc2VsZi53ZWVrZGF5Q29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci13ZWVrZGF5c1wiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjbGVhck5vZGUoc2VsZi53ZWVrZGF5Q29udGFpbmVyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd2Vla2RheWNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLndlZWtkYXlDb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVdlZWtkYXlzKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi53ZWVrZGF5Q29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVdlZWtkYXlzKCkge1xuICAgICAgICAgICAgdmFyIGZpcnN0RGF5T2ZXZWVrID0gc2VsZi5sMTBuLmZpcnN0RGF5T2ZXZWVrO1xuICAgICAgICAgICAgdmFyIHdlZWtkYXlzID0gc2VsZi5sMTBuLndlZWtkYXlzLnNob3J0aGFuZC5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKGZpcnN0RGF5T2ZXZWVrID4gMCAmJiBmaXJzdERheU9mV2VlayA8IHdlZWtkYXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlzID0gd2Vla2RheXMuc3BsaWNlKGZpcnN0RGF5T2ZXZWVrLCB3ZWVrZGF5cy5sZW5ndGgpLmNvbmNhdCh3ZWVrZGF5cy5zcGxpY2UoMCwgZmlyc3REYXlPZldlZWspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgc2VsZi53ZWVrZGF5Q29udGFpbmVyLmNoaWxkcmVuW2ldLmlubmVySFRNTCA9IFwiXFxuICAgICAgPHNwYW4gY2xhc3M9J2ZsYXRwaWNrci13ZWVrZGF5Jz5cXG4gICAgICAgIFwiICsgd2Vla2RheXMuam9pbihcIjwvc3Bhbj48c3BhbiBjbGFzcz0nZmxhdHBpY2tyLXdlZWtkYXknPlwiKSArIFwiXFxuICAgICAgPC9zcGFuPlxcbiAgICAgIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkV2Vla3MoKSB7XG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoYXNXZWVrc1wiKTtcbiAgICAgICAgICAgIHZhciB3ZWVrV3JhcHBlciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd2Vla3dyYXBwZXJcIik7XG4gICAgICAgICAgICB3ZWVrV3JhcHBlci5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci13ZWVrZGF5XCIsIHNlbGYubDEwbi53ZWVrQWJicmV2aWF0aW9uKSk7XG4gICAgICAgICAgICB2YXIgd2Vla051bWJlcnMgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdlZWtzXCIpO1xuICAgICAgICAgICAgd2Vla1dyYXBwZXIuYXBwZW5kQ2hpbGQod2Vla051bWJlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3ZWVrV3JhcHBlcjogd2Vla1dyYXBwZXIsXG4gICAgICAgICAgICAgICAgd2Vla051bWJlcnM6IHdlZWtOdW1iZXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoYW5nZU1vbnRoKHZhbHVlLCBpc19vZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChpc19vZmZzZXQgPT09IHZvaWQgMCkgeyBpc19vZmZzZXQgPSB0cnVlOyB9XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBpc19vZmZzZXQgPyB2YWx1ZSA6IHZhbHVlIC0gc2VsZi5jdXJyZW50TW9udGg7XG4gICAgICAgICAgICBpZiAoKGRlbHRhIDwgMCAmJiBzZWxmLl9oaWRlUHJldk1vbnRoQXJyb3cgPT09IHRydWUpIHx8XG4gICAgICAgICAgICAgICAgKGRlbHRhID4gMCAmJiBzZWxmLl9oaWRlTmV4dE1vbnRoQXJyb3cgPT09IHRydWUpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoICs9IGRlbHRhO1xuICAgICAgICAgICAgaWYgKHNlbGYuY3VycmVudE1vbnRoIDwgMCB8fCBzZWxmLmN1cnJlbnRNb250aCA+IDExKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciArPSBzZWxmLmN1cnJlbnRNb250aCA+IDExID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0gKHNlbGYuY3VycmVudE1vbnRoICsgMTIpICUgMTI7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25ZZWFyQ2hhbmdlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVpbGREYXlzKCk7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk1vbnRoQ2hhbmdlXCIpO1xuICAgICAgICAgICAgdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsZWFyKHRyaWdnZXJDaGFuZ2VFdmVudCwgdG9Jbml0aWFsKSB7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZUV2ZW50ID09PSB2b2lkIDApIHsgdHJpZ2dlckNoYW5nZUV2ZW50ID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKHRvSW5pdGlhbCA9PT0gdm9pZCAwKSB7IHRvSW5pdGlhbCA9IHRydWU7IH1cbiAgICAgICAgICAgIHNlbGYuaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChzZWxmLm1vYmlsZUlucHV0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRvSW5pdGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBzZWxmLl9pbml0aWFsRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0gc2VsZi5faW5pdGlhbERhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuc2hvd1RpbWVJbnB1dCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzZXREZWZhdWx0SG91cnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZUV2ZW50KVxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXJDaGFuZ2VFdmVudCBpcyB0cnVlIChkZWZhdWx0KSBvciBhbiBFdmVudFxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICAgICAgc2VsZi5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghc2VsZi5pc01vYmlsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNhbGVuZGFyQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwib3BlblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2lucHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5wdXQuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNsb3NlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkRlc3Ryb3lcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc2VsZi5faGFuZGxlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIGggPSBzZWxmLl9oYW5kbGVyc1tpXTtcbiAgICAgICAgICAgICAgICBoLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihoLmV2ZW50LCBoLmhhbmRsZXIsIGgub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9oYW5kbGVycyA9IFtdO1xuICAgICAgICAgICAgaWYgKHNlbGYubW9iaWxlSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsZi5tb2JpbGVJbnB1dCk7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgJiYgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnN0YXRpYyAmJiBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIubGFzdENoaWxkICYmIHdyYXBwZXIucmVtb3ZlQ2hpbGQod3JhcHBlci5sYXN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod3JhcHBlci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUod3JhcHBlci5maXJzdENoaWxkLCB3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmFsdElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGYuYWx0SW5wdXQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmFsdElucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnR5cGUgPSBzZWxmLmlucHV0Ll90eXBlO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuY2xhc3NMaXN0LnJlbW92ZShcImZsYXRwaWNrci1pbnB1dFwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShcInJlYWRvbmx5XCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiX3Nob3dUaW1lSW5wdXRcIixcbiAgICAgICAgICAgICAgICBcImxhdGVzdFNlbGVjdGVkRGF0ZU9ialwiLFxuICAgICAgICAgICAgICAgIFwiX2hpZGVOZXh0TW9udGhBcnJvd1wiLFxuICAgICAgICAgICAgICAgIFwiX2hpZGVQcmV2TW9udGhBcnJvd1wiLFxuICAgICAgICAgICAgICAgIFwiX19oaWRlTmV4dE1vbnRoQXJyb3dcIixcbiAgICAgICAgICAgICAgICBcIl9faGlkZVByZXZNb250aEFycm93XCIsXG4gICAgICAgICAgICAgICAgXCJpc01vYmlsZVwiLFxuICAgICAgICAgICAgICAgIFwiaXNPcGVuXCIsXG4gICAgICAgICAgICAgICAgXCJzZWxlY3RlZERhdGVFbGVtXCIsXG4gICAgICAgICAgICAgICAgXCJtaW5EYXRlSGFzVGltZVwiLFxuICAgICAgICAgICAgICAgIFwibWF4RGF0ZUhhc1RpbWVcIixcbiAgICAgICAgICAgICAgICBcImRheXNcIixcbiAgICAgICAgICAgICAgICBcImRheXNDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcIl9pbnB1dFwiLFxuICAgICAgICAgICAgICAgIFwiX3Bvc2l0aW9uRWxlbWVudFwiLFxuICAgICAgICAgICAgICAgIFwiaW5uZXJDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcInJDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcIm1vbnRoTmF2XCIsXG4gICAgICAgICAgICAgICAgXCJ0b2RheURhdGVFbGVtXCIsXG4gICAgICAgICAgICAgICAgXCJjYWxlbmRhckNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwid2Vla2RheUNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwicHJldk1vbnRoTmF2XCIsXG4gICAgICAgICAgICAgICAgXCJuZXh0TW9udGhOYXZcIixcbiAgICAgICAgICAgICAgICBcImN1cnJlbnRNb250aEVsZW1lbnRcIixcbiAgICAgICAgICAgICAgICBcImN1cnJlbnRZZWFyRWxlbWVudFwiLFxuICAgICAgICAgICAgICAgIFwibmF2aWdhdGlvbkN1cnJlbnRNb250aFwiLFxuICAgICAgICAgICAgICAgIFwic2VsZWN0ZWREYXRlRWxlbVwiLFxuICAgICAgICAgICAgICAgIFwiY29uZmlnXCIsXG4gICAgICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2VsZltrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNDYWxlbmRhckVsZW0oZWxlbSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFwcGVuZFRvICYmIHNlbGYuY29uZmlnLmFwcGVuZFRvLmNvbnRhaW5zKGVsZW0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY29udGFpbnMoZWxlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnRDbGljayhlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc09wZW4gJiYgIXNlbGYuY29uZmlnLmlubGluZSkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudFRhcmdldF8xID0gZ2V0RXZlbnRUYXJnZXQoZSk7XG4gICAgICAgICAgICAgICAgdmFyIGlzQ2FsZW5kYXJFbGVtZW50ID0gaXNDYWxlbmRhckVsZW0oZXZlbnRUYXJnZXRfMSk7XG4gICAgICAgICAgICAgICAgdmFyIGlzSW5wdXQgPSBldmVudFRhcmdldF8xID09PSBzZWxmLmlucHV0IHx8XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0XzEgPT09IHNlbGYuYWx0SW5wdXQgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbGVtZW50LmNvbnRhaW5zKGV2ZW50VGFyZ2V0XzEpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlYiBjb21wb25lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGUucGF0aCBpcyBub3QgcHJlc2VudCBpbiBhbGwgYnJvd3NlcnMuIGNpcmN1bXZlbnRpbmcgdHlwZWNoZWNrc1xuICAgICAgICAgICAgICAgICAgICAoZS5wYXRoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnBhdGguaW5kZXhPZiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKH5lLnBhdGguaW5kZXhPZihzZWxmLmlucHV0KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5lLnBhdGguaW5kZXhPZihzZWxmLmFsdElucHV0KSkpO1xuICAgICAgICAgICAgICAgIHZhciBsb3N0Rm9jdXMgPSBlLnR5cGUgPT09IFwiYmx1clwiXG4gICAgICAgICAgICAgICAgICAgID8gaXNJbnB1dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNDYWxlbmRhckVsZW0oZS5yZWxhdGVkVGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICA6ICFpc0lucHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNDYWxlbmRhckVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc0NhbGVuZGFyRWxlbShlLnJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICAgICAgICAgIHZhciBpc0lnbm9yZWQgPSAhc2VsZi5jb25maWcuaWdub3JlZEZvY3VzRWxlbWVudHMuc29tZShmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5jb250YWlucyhldmVudFRhcmdldF8xKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobG9zdEZvY3VzICYmIGlzSWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIgJiYgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoYW5nZVllYXIobmV3WWVhcikge1xuICAgICAgICAgICAgaWYgKCFuZXdZZWFyIHx8XG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1pbkRhdGUgJiYgbmV3WWVhciA8IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSkgfHxcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWF4RGF0ZSAmJiBuZXdZZWFyID4gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbmV3WWVhck51bSA9IG5ld1llYXIsIGlzTmV3WWVhciA9IHNlbGYuY3VycmVudFllYXIgIT09IG5ld1llYXJOdW07XG4gICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID0gbmV3WWVhck51bSB8fCBzZWxmLmN1cnJlbnRZZWFyO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1heERhdGUgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID09PSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IE1hdGgubWluKHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TW9udGgoKSwgc2VsZi5jdXJyZW50TW9udGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jb25maWcubWluRGF0ZSAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0gTWF0aC5tYXgoc2VsZi5jb25maWcubWluRGF0ZS5nZXRNb250aCgpLCBzZWxmLmN1cnJlbnRNb250aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOZXdZZWFyKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblllYXJDaGFuZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNFbmFibGVkKGRhdGUsIHRpbWVsZXNzKSB7XG4gICAgICAgICAgICBpZiAodGltZWxlc3MgPT09IHZvaWQgMCkgeyB0aW1lbGVzcyA9IHRydWU7IH1cbiAgICAgICAgICAgIHZhciBkYXRlVG9DaGVjayA9IHNlbGYucGFyc2VEYXRlKGRhdGUsIHVuZGVmaW5lZCwgdGltZWxlc3MpOyAvLyB0aW1lbGVzc1xuICAgICAgICAgICAgaWYgKChzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgZGF0ZVRvQ2hlY2sgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZVRvQ2hlY2ssIHNlbGYuY29uZmlnLm1pbkRhdGUsIHRpbWVsZXNzICE9PSB1bmRlZmluZWQgPyB0aW1lbGVzcyA6ICFzZWxmLm1pbkRhdGVIYXNUaW1lKSA8IDApIHx8XG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1heERhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVRvQ2hlY2sgJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKGRhdGVUb0NoZWNrLCBzZWxmLmNvbmZpZy5tYXhEYXRlLCB0aW1lbGVzcyAhPT0gdW5kZWZpbmVkID8gdGltZWxlc3MgOiAhc2VsZi5tYXhEYXRlSGFzVGltZSkgPiAwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlLmxlbmd0aCA9PT0gMCAmJiBzZWxmLmNvbmZpZy5kaXNhYmxlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChkYXRlVG9DaGVjayA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBib29sID0gc2VsZi5jb25maWcuZW5hYmxlLmxlbmd0aCA+IDAsIGFycmF5ID0gYm9vbCA/IHNlbGYuY29uZmlnLmVuYWJsZSA6IHNlbGYuY29uZmlnLmRpc2FibGU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZCA9IHZvaWQgMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZCA9IGFycmF5W2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgIGQoZGF0ZVRvQ2hlY2spIC8vIGRpc2FibGVkIGJ5IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9vbDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkIGluc3RhbmNlb2YgRGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRlVG9DaGVjayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIGQuZ2V0VGltZSgpID09PSBkYXRlVG9DaGVjay5nZXRUaW1lKCkpXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIGJ5IGRhdGVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvb2w7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQgPT09IFwic3RyaW5nXCIgJiYgZGF0ZVRvQ2hlY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlZCBieSBkYXRlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gc2VsZi5wYXJzZURhdGUoZCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZCAmJiBwYXJzZWQuZ2V0VGltZSgpID09PSBkYXRlVG9DaGVjay5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYm9vbFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAhYm9vbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgYnkgcmFuZ2VcbiAgICAgICAgICAgICAgICB0eXBlb2YgZCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRlVG9DaGVjayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIGQuZnJvbSAmJlxuICAgICAgICAgICAgICAgICAgICBkLnRvICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVUb0NoZWNrLmdldFRpbWUoKSA+PSBkLmZyb20uZ2V0VGltZSgpICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVUb0NoZWNrLmdldFRpbWUoKSA8PSBkLnRvLmdldFRpbWUoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIWJvb2w7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNJblZpZXcoZWxlbSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuZGF5c0NvbnRhaW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiAoZWxlbS5jbGFzc05hbWUuaW5kZXhPZihcImhpZGRlblwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXlzQ29udGFpbmVyLmNvbnRhaW5zKGVsZW0pKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgICAgICAgICAgLy8gZS5rZXkgICAgICAgICAgICAgICAgICAgICAgZS5rZXlDb2RlXG4gICAgICAgICAgICAvLyBcIkJhY2tzcGFjZVwiICAgICAgICAgICAgICAgICAgICAgICAgOFxuICAgICAgICAgICAgLy8gXCJUYWJcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDlcbiAgICAgICAgICAgIC8vIFwiRW50ZXJcIiAgICAgICAgICAgICAgICAgICAgICAgICAgIDEzXG4gICAgICAgICAgICAvLyBcIkVzY2FwZVwiICAgICAoSUUgXCJFc2NcIikgICAgICAgICAgIDI3XG4gICAgICAgICAgICAvLyBcIkFycm93TGVmdFwiICAoSUUgXCJMZWZ0XCIpICAgICAgICAgIDM3XG4gICAgICAgICAgICAvLyBcIkFycm93VXBcIiAgICAoSUUgXCJVcFwiKSAgICAgICAgICAgIDM4XG4gICAgICAgICAgICAvLyBcIkFycm93UmlnaHRcIiAoSUUgXCJSaWdodFwiKSAgICAgICAgIDM5XG4gICAgICAgICAgICAvLyBcIkFycm93RG93blwiICAoSUUgXCJEb3duXCIpICAgICAgICAgIDQwXG4gICAgICAgICAgICAvLyBcIkRlbGV0ZVwiICAgICAoSUUgXCJEZWxcIikgICAgICAgICAgIDQ2XG4gICAgICAgICAgICB2YXIgaXNJbnB1dCA9IGUudGFyZ2V0ID09PSBzZWxmLl9pbnB1dDtcbiAgICAgICAgICAgIHZhciBhbGxvd0lucHV0ID0gc2VsZi5jb25maWcuYWxsb3dJbnB1dDtcbiAgICAgICAgICAgIHZhciBhbGxvd0tleWRvd24gPSBzZWxmLmlzT3BlbiAmJiAoIWFsbG93SW5wdXQgfHwgIWlzSW5wdXQpO1xuICAgICAgICAgICAgdmFyIGFsbG93SW5saW5lS2V5ZG93biA9IHNlbGYuY29uZmlnLmlubGluZSAmJiBpc0lucHV0ICYmICFhbGxvd0lucHV0O1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMgJiYgaXNJbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd0lucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0RGF0ZShzZWxmLl9pbnB1dC52YWx1ZSwgdHJ1ZSwgZS50YXJnZXQgPT09IHNlbGYuYWx0SW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcuYWx0Rm9ybWF0XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS50YXJnZXQuYmx1cigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHNlbGYub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNDYWxlbmRhckVsZW0oZS50YXJnZXQpIHx8XG4gICAgICAgICAgICAgICAgYWxsb3dLZXlkb3duIHx8XG4gICAgICAgICAgICAgICAgYWxsb3dJbmxpbmVLZXlkb3duKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzVGltZU9iaiA9ICEhc2VsZi50aW1lQ29udGFpbmVyICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1RpbWVPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdERhdGUoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNzogLy8gZXNjYXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZENsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ2OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5wdXQgJiYgIXNlbGYuY29uZmlnLmFsbG93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVGltZU9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFsbG93SW5wdXQgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBpc0luVmlldyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YV8xID0gZS5rZXlDb2RlID09PSAzOSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlLmN0cmxLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c09uRGF5KHVuZGVmaW5lZCwgZGVsdGFfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZU1vbnRoKGRlbHRhXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNPbkRheShnZXRGaXJzdEF2YWlsYWJsZURheSgxKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxmLmhvdXJFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gZS5rZXlDb2RlID09PSA0MCA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoc2VsZi5kYXlzQ29udGFpbmVyICYmIGUudGFyZ2V0LiRpICE9PSB1bmRlZmluZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQgPT09IHNlbGYuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVllYXIoc2VsZi5jdXJyZW50WWVhciAtIGRlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNPbkRheShnZXRGaXJzdEF2YWlsYWJsZURheSgxKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1RpbWVPYmopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzT25EYXkodW5kZWZpbmVkLCBkZWx0YSAqIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNUaW1lT2JqICYmIHNlbGYuaG91ckVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUaW1lKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2RlYm91bmNlZENoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1RpbWVPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFtUE0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZWxlbXMuaW5kZXhPZihlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlbGVtc1tpICsgKGUuc2hpZnRLZXkgPyAtMSA6IDEpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9pbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQgJiYgZS50YXJnZXQgPT09IHNlbGYuYW1QTSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLmwxMG4uYW1QTVswXS5jaGFyQXQoMCk6XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5sMTBuLmFtUE1bMF0uY2hhckF0KDApLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPSBzZWxmLmwxMG4uYW1QTVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEhvdXJzRnJvbUlucHV0cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYubDEwbi5hbVBNWzFdLmNoYXJBdCgwKTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLmwxMG4uYW1QTVsxXS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50ZXh0Q29udGVudCA9IHNlbGYubDEwbi5hbVBNWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SG91cnNGcm9tSW5wdXRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25LZXlEb3duXCIsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uTW91c2VPdmVyKGVsZW0pIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgICAgICAgICAgKGVsZW0gJiZcbiAgICAgICAgICAgICAgICAgICAgKCFlbGVtLmNsYXNzTGlzdC5jb250YWlucyhcImZsYXRwaWNrci1kYXlcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGlzYWJsZWRcIikpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaG92ZXJEYXRlID0gZWxlbVxuICAgICAgICAgICAgICAgID8gZWxlbS5kYXRlT2JqLmdldFRpbWUoKVxuICAgICAgICAgICAgICAgIDogc2VsZi5kYXlzLmZpcnN0RWxlbWVudENoaWxkLmRhdGVPYmouZ2V0VGltZSgpLCBpbml0aWFsRGF0ZSA9IHNlbGYucGFyc2VEYXRlKHNlbGYuc2VsZWN0ZWREYXRlc1swXSwgdW5kZWZpbmVkLCB0cnVlKS5nZXRUaW1lKCksIHJhbmdlU3RhcnREYXRlID0gTWF0aC5taW4oaG92ZXJEYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0VGltZSgpKSwgcmFuZ2VFbmREYXRlID0gTWF0aC5tYXgoaG92ZXJEYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0VGltZSgpKSwgbGFzdERhdGUgPSBzZWxmLmRheXNDb250YWluZXIubGFzdENoaWxkXG4gICAgICAgICAgICAgICAgLmxhc3RDaGlsZC5kYXRlT2JqLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHZhciBjb250YWluc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbWluUmFuZ2UgPSAwLCBtYXhSYW5nZSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gcmFuZ2VTdGFydERhdGU7IHQgPCBsYXN0RGF0ZTsgdCArPSBkdXJhdGlvbi5EQVkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRW5hYmxlZChuZXcgRGF0ZSh0KSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnNEaXNhYmxlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluc0Rpc2FibGVkIHx8ICh0ID4gcmFuZ2VTdGFydERhdGUgJiYgdCA8IHJhbmdlRW5kRGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0IDwgaW5pdGlhbERhdGUgJiYgKCFtaW5SYW5nZSB8fCB0ID4gbWluUmFuZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWluUmFuZ2UgPSB0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0ID4gaW5pdGlhbERhdGUgJiYgKCFtYXhSYW5nZSB8fCB0IDwgbWF4UmFuZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4UmFuZ2UgPSB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgc2VsZi5jb25maWcuc2hvd01vbnRoczsgbSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gc2VsZi5kYXlzQ29udGFpbmVyLmNoaWxkcmVuW21dO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2TW9udGggPSBzZWxmLmRheXNDb250YWluZXIuY2hpbGRyZW5bbSAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGksIGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRheUVsZW0gPSBtb250aC5jaGlsZHJlbltpXSwgZGF0ZSA9IGRheUVsZW0uZGF0ZU9iajtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0T2ZSYW5nZSA9IChtaW5SYW5nZSA+IDAgJiYgdGltZXN0YW1wIDwgbWluUmFuZ2UpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAobWF4UmFuZ2UgPiAwICYmIHRpbWVzdGFtcCA+IG1heFJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dE9mUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LmFkZChcIm5vdEFsbG93ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBbXCJpblJhbmdlXCIsIFwic3RhcnRSYW5nZVwiLCBcImVuZFJhbmdlXCJdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGFpbnNEaXNhYmxlZCAmJiAhb3V0T2ZSYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgIFtcInN0YXJ0UmFuZ2VcIiwgXCJpblJhbmdlXCIsIFwiZW5kUmFuZ2VcIiwgXCJub3RBbGxvd2VkXCJdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZChob3ZlckRhdGUgPCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcInN0YXJ0UmFuZ2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJlbmRSYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb250aC5jb250YWlucyhlbGVtKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEobSA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldk1vbnRoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZNb250aC5sYXN0Q2hpbGQuZGF0ZU9iai5nZXRUaW1lKCkgPj0gdGltZXN0YW1wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsRGF0ZSA8IGhvdmVyRGF0ZSAmJiB0aW1lc3RhbXAgPT09IGluaXRpYWxEYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoXCJzdGFydFJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluaXRpYWxEYXRlID4gaG92ZXJEYXRlICYmIHRpbWVzdGFtcCA9PT0gaW5pdGlhbERhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LmFkZChcImVuZFJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPj0gbWluUmFuZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1heFJhbmdlID09PSAwIHx8IHRpbWVzdGFtcCA8PSBtYXhSYW5nZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNCZXR3ZWVuKHRpbWVzdGFtcCwgaW5pdGlhbERhdGUsIGhvdmVyRGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LmFkZChcImluUmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbW9udGguY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9sb29wXzEoaSwgbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNPcGVuICYmICFzZWxmLmNvbmZpZy5zdGF0aWMgJiYgIXNlbGYuY29uZmlnLmlubGluZSlcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNhbGVuZGFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0RGVmYXVsdFRpbWUoKSB7XG4gICAgICAgICAgICBzZWxmLnNldERhdGUoc2VsZi5jb25maWcubWluRGF0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBuZXcgRGF0ZShzZWxmLmNvbmZpZy5taW5EYXRlLmdldFRpbWUoKSlcbiAgICAgICAgICAgICAgICA6IG5ldyBEYXRlKCksIGZhbHNlKTtcbiAgICAgICAgICAgIHNldERlZmF1bHRIb3VycygpO1xuICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvcGVuKGUsIHBvc2l0aW9uRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uRWxlbWVudCA9PT0gdm9pZCAwKSB7IHBvc2l0aW9uRWxlbWVudCA9IHNlbGYuX3Bvc2l0aW9uRWxlbWVudDsgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaXNNb2JpbGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0ICYmIGUudGFyZ2V0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubW9iaWxlSW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQuY2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25PcGVuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLl9pbnB1dC5kaXNhYmxlZCB8fCBzZWxmLmNvbmZpZy5pbmxpbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHdhc09wZW4gPSBzZWxmLmlzT3BlbjtcbiAgICAgICAgICAgIHNlbGYuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghd2FzT3Blbikge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm9wZW5cIik7XG4gICAgICAgICAgICAgICAgc2VsZi5faW5wdXQuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk9wZW5cIik7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25DYWxlbmRhcihwb3NpdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgPT09IHRydWUgJiYgc2VsZi5jb25maWcubm9DYWxlbmRhciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldERlZmF1bHRUaW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hbGxvd0lucHV0ID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICAgICAoZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhc2VsZi50aW1lQ29udGFpbmVyLmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5ob3VyRWxlbWVudC5zZWxlY3QoKTsgfSwgNTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtaW5NYXhEYXRlU2V0dGVyKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlT2JqID0gKHNlbGYuY29uZmlnW1wiX1wiICsgdHlwZSArIFwiRGF0ZVwiXSA9IHNlbGYucGFyc2VEYXRlKGRhdGUsIHNlbGYuY29uZmlnLmRhdGVGb3JtYXQpKTtcbiAgICAgICAgICAgICAgICB2YXIgaW52ZXJzZURhdGVPYmogPSBzZWxmLmNvbmZpZ1tcIl9cIiArICh0eXBlID09PSBcIm1pblwiID8gXCJtYXhcIiA6IFwibWluXCIpICsgXCJEYXRlXCJdO1xuICAgICAgICAgICAgICAgIGlmIChkYXRlT2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZlt0eXBlID09PSBcIm1pblwiID8gXCJtaW5EYXRlSGFzVGltZVwiIDogXCJtYXhEYXRlSGFzVGltZVwiXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlT2JqLmdldEhvdXJzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU9iai5nZXRNaW51dGVzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU9iai5nZXRTZWNvbmRzKCkgPiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcyA9IHNlbGYuc2VsZWN0ZWREYXRlcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGlzRW5hYmxlZChkKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCAmJiB0eXBlID09PSBcIm1pblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SG91cnNGcm9tRGF0ZShkYXRlT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZGF5c0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZWRyYXcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGVPYmogIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXJFbGVtZW50W3R5cGVdID0gZGF0ZU9iai5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXJFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhckVsZW1lbnQuZGlzYWJsZWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgISFpbnZlcnNlRGF0ZU9iaiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVPYmogIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmVyc2VEYXRlT2JqLmdldEZ1bGxZZWFyKCkgPT09IGRhdGVPYmouZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlQ29uZmlnKCkge1xuICAgICAgICAgICAgdmFyIGJvb2xPcHRzID0gW1xuICAgICAgICAgICAgICAgIFwid3JhcFwiLFxuICAgICAgICAgICAgICAgIFwid2Vla051bWJlcnNcIixcbiAgICAgICAgICAgICAgICBcImFsbG93SW5wdXRcIixcbiAgICAgICAgICAgICAgICBcImNsaWNrT3BlbnNcIixcbiAgICAgICAgICAgICAgICBcInRpbWVfMjRoclwiLFxuICAgICAgICAgICAgICAgIFwiZW5hYmxlVGltZVwiLFxuICAgICAgICAgICAgICAgIFwibm9DYWxlbmRhclwiLFxuICAgICAgICAgICAgICAgIFwiYWx0SW5wdXRcIixcbiAgICAgICAgICAgICAgICBcInNob3J0aGFuZEN1cnJlbnRNb250aFwiLFxuICAgICAgICAgICAgICAgIFwiaW5saW5lXCIsXG4gICAgICAgICAgICAgICAgXCJzdGF0aWNcIixcbiAgICAgICAgICAgICAgICBcImVuYWJsZVNlY29uZHNcIixcbiAgICAgICAgICAgICAgICBcImRpc2FibGVNb2JpbGVcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgdXNlckNvbmZpZyA9IF9fYXNzaWduKHt9LCBpbnN0YW5jZUNvbmZpZywgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbGVtZW50LmRhdGFzZXQgfHwge30pKSk7XG4gICAgICAgICAgICB2YXIgZm9ybWF0cyA9IHt9O1xuICAgICAgICAgICAgc2VsZi5jb25maWcucGFyc2VEYXRlID0gdXNlckNvbmZpZy5wYXJzZURhdGU7XG4gICAgICAgICAgICBzZWxmLmNvbmZpZy5mb3JtYXREYXRlID0gdXNlckNvbmZpZy5mb3JtYXREYXRlO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcImVuYWJsZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmNvbmZpZy5fZW5hYmxlOyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLl9lbmFibGUgPSBwYXJzZURhdGVSdWxlcyhkYXRlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwiZGlzYWJsZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmNvbmZpZy5fZGlzYWJsZTsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlcykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5fZGlzYWJsZSA9IHBhcnNlRGF0ZVJ1bGVzKGRhdGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB0aW1lTW9kZSA9IHVzZXJDb25maWcubW9kZSA9PT0gXCJ0aW1lXCI7XG4gICAgICAgICAgICBpZiAoIXVzZXJDb25maWcuZGF0ZUZvcm1hdCAmJiAodXNlckNvbmZpZy5lbmFibGVUaW1lIHx8IHRpbWVNb2RlKSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHMuZGF0ZUZvcm1hdCA9XG4gICAgICAgICAgICAgICAgICAgIHVzZXJDb25maWcubm9DYWxlbmRhciB8fCB0aW1lTW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIkg6aVwiICsgKHVzZXJDb25maWcuZW5hYmxlU2Vjb25kcyA/IFwiOlNcIiA6IFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnLmRhdGVGb3JtYXQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIEg6aVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodXNlckNvbmZpZy5lbmFibGVTZWNvbmRzID8gXCI6U1wiIDogXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlckNvbmZpZy5hbHRJbnB1dCAmJlxuICAgICAgICAgICAgICAgICh1c2VyQ29uZmlnLmVuYWJsZVRpbWUgfHwgdGltZU1vZGUpICYmXG4gICAgICAgICAgICAgICAgIXVzZXJDb25maWcuYWx0Rm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0cy5hbHRGb3JtYXQgPVxuICAgICAgICAgICAgICAgICAgICB1c2VyQ29uZmlnLm5vQ2FsZW5kYXIgfHwgdGltZU1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJoOmlcIiArICh1c2VyQ29uZmlnLmVuYWJsZVNlY29uZHMgPyBcIjpTIEtcIiA6IFwiIEtcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmxhdHBpY2tyLmRlZmF1bHRDb25maWcuYWx0Rm9ybWF0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCIgaDppXCIgKyAodXNlckNvbmZpZy5lbmFibGVTZWNvbmRzID8gXCI6U1wiIDogXCJcIikgKyBcIiBLXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcIm1pbkRhdGVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5jb25maWcuX21pbkRhdGU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBtaW5NYXhEYXRlU2V0dGVyKFwibWluXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJtYXhEYXRlXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9tYXhEYXRlOyB9LFxuICAgICAgICAgICAgICAgIHNldDogbWluTWF4RGF0ZVNldHRlcihcIm1heFwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbWluTWF4VGltZVNldHRlciA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWdbdHlwZSA9PT0gXCJtaW5cIiA/IFwiX21pblRpbWVcIiA6IFwiX21heFRpbWVcIl0gPSBzZWxmLnBhcnNlRGF0ZSh2YWwsIFwiSDppXCIpO1xuICAgICAgICAgICAgfTsgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJtaW5UaW1lXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9taW5UaW1lOyB9LFxuICAgICAgICAgICAgICAgIHNldDogbWluTWF4VGltZVNldHRlcihcIm1pblwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwibWF4VGltZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmNvbmZpZy5fbWF4VGltZTsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IG1pbk1heFRpbWVTZXR0ZXIoXCJtYXhcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHVzZXJDb25maWcubW9kZSA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5ub0NhbGVuZGFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5lbmFibGVUaW1lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VsZi5jb25maWcsIGZvcm1hdHMsIHVzZXJDb25maWcpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29sT3B0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1tib29sT3B0c1tpXV0gPVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1tib29sT3B0c1tpXV0gPT09IHRydWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2Jvb2xPcHRzW2ldXSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgICAgICBIT09LUy5maWx0ZXIoZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIHNlbGYuY29uZmlnW2hvb2tdICE9PSB1bmRlZmluZWQ7IH0pLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1tob29rXSA9IGFycmF5aWZ5KHNlbGYuY29uZmlnW2hvb2tdIHx8IFtdKS5tYXAoYmluZFRvSW5zdGFuY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLmlzTW9iaWxlID1cbiAgICAgICAgICAgICAgICAhc2VsZi5jb25maWcuZGlzYWJsZU1vYmlsZSAmJlxuICAgICAgICAgICAgICAgICAgICAhc2VsZi5jb25maWcuaW5saW5lICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1vZGUgPT09IFwic2luZ2xlXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLmRpc2FibGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy53ZWVrTnVtYmVycyAmJlxuICAgICAgICAgICAgICAgICAgICAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGx1Z2luQ29uZiA9IHNlbGYuY29uZmlnLnBsdWdpbnNbaV0oc2VsZikgfHwge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHBsdWdpbkNvbmYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEhPT0tTLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1trZXldID0gYXJyYXlpZnkocGx1Z2luQ29uZltrZXldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoYmluZFRvSW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChzZWxmLmNvbmZpZ1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdXNlckNvbmZpZ1trZXldID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWdba2V5XSA9IHBsdWdpbkNvbmZba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblBhcnNlQ29uZmlnXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwTG9jYWxlKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLmNvbmZpZy5sb2NhbGUgIT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZmxhdHBpY2tyLmwxMG5zW3NlbGYuY29uZmlnLmxvY2FsZV0gPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihcImZsYXRwaWNrcjogaW52YWxpZCBsb2NhbGUgXCIgKyBzZWxmLmNvbmZpZy5sb2NhbGUpKTtcbiAgICAgICAgICAgIHNlbGYubDEwbiA9IF9fYXNzaWduKHt9LCBmbGF0cGlja3IubDEwbnNbXCJkZWZhdWx0XCJdLCAodHlwZW9mIHNlbGYuY29uZmlnLmxvY2FsZSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcubG9jYWxlXG4gICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5sb2NhbGUgIT09IFwiZGVmYXVsdFwiXG4gICAgICAgICAgICAgICAgICAgID8gZmxhdHBpY2tyLmwxMG5zW3NlbGYuY29uZmlnLmxvY2FsZV1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIHRva2VuUmVnZXguSyA9IFwiKFwiICsgc2VsZi5sMTBuLmFtUE1bMF0gKyBcInxcIiArIHNlbGYubDEwbi5hbVBNWzFdICsgXCJ8XCIgKyBzZWxmLmwxMG4uYW1QTVswXS50b0xvd2VyQ2FzZSgpICsgXCJ8XCIgKyBzZWxmLmwxMG4uYW1QTVsxXS50b0xvd2VyQ2FzZSgpICsgXCIpXCI7XG4gICAgICAgICAgICBzZWxmLmZvcm1hdERhdGUgPSBjcmVhdGVEYXRlRm9ybWF0dGVyKHNlbGYpO1xuICAgICAgICAgICAgc2VsZi5wYXJzZURhdGUgPSBjcmVhdGVEYXRlUGFyc2VyKHsgY29uZmlnOiBzZWxmLmNvbmZpZywgbDEwbjogc2VsZi5sMTBuIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBvc2l0aW9uQ2FsZW5kYXIoY3VzdG9tUG9zaXRpb25FbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jYWxlbmRhckNvbnRhaW5lciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uUHJlQ2FsZW5kYXJQb3NpdGlvblwiKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkVsZW1lbnQgPSBjdXN0b21Qb3NpdGlvbkVsZW1lbnQgfHwgc2VsZi5fcG9zaXRpb25FbGVtZW50O1xuICAgICAgICAgICAgdmFyIGNhbGVuZGFySGVpZ2h0ID0gQXJyYXkucHJvdG90eXBlLnJlZHVjZS5jYWxsKHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2hpbGRyZW4sIChmdW5jdGlvbiAoYWNjLCBjaGlsZCkgeyByZXR1cm4gYWNjICsgY2hpbGQub2Zmc2V0SGVpZ2h0OyB9KSwgMCksIGNhbGVuZGFyV2lkdGggPSBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLm9mZnNldFdpZHRoLCBjb25maWdQb3MgPSBzZWxmLmNvbmZpZy5wb3NpdGlvbi5zcGxpdChcIiBcIiksIGNvbmZpZ1Bvc1ZlcnRpY2FsID0gY29uZmlnUG9zWzBdLCBjb25maWdQb3NIb3Jpem9udGFsID0gY29uZmlnUG9zLmxlbmd0aCA+IDEgPyBjb25maWdQb3NbMV0gOiBudWxsLCBpbnB1dEJvdW5kcyA9IHBvc2l0aW9uRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZGlzdGFuY2VGcm9tQm90dG9tID0gd2luZG93LmlubmVySGVpZ2h0IC0gaW5wdXRCb3VuZHMuYm90dG9tLCBzaG93T25Ub3AgPSBjb25maWdQb3NWZXJ0aWNhbCA9PT0gXCJhYm92ZVwiIHx8XG4gICAgICAgICAgICAgICAgKGNvbmZpZ1Bvc1ZlcnRpY2FsICE9PSBcImJlbG93XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VGcm9tQm90dG9tIDwgY2FsZW5kYXJIZWlnaHQgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRCb3VuZHMudG9wID4gY2FsZW5kYXJIZWlnaHQpO1xuICAgICAgICAgICAgdmFyIHRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCArXG4gICAgICAgICAgICAgICAgaW5wdXRCb3VuZHMudG9wICtcbiAgICAgICAgICAgICAgICAoIXNob3dPblRvcCA/IHBvc2l0aW9uRWxlbWVudC5vZmZzZXRIZWlnaHQgKyAyIDogLWNhbGVuZGFySGVpZ2h0IC0gMik7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcImFycm93VG9wXCIsICFzaG93T25Ub3ApO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJhcnJvd0JvdHRvbVwiLCBzaG93T25Ub3ApO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmlubGluZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCArXG4gICAgICAgICAgICAgICAgaW5wdXRCb3VuZHMubGVmdCAtXG4gICAgICAgICAgICAgICAgKGNvbmZpZ1Bvc0hvcml6b250YWwgIT0gbnVsbCAmJiBjb25maWdQb3NIb3Jpem9udGFsID09PSBcImNlbnRlclwiXG4gICAgICAgICAgICAgICAgICAgID8gKGNhbGVuZGFyV2lkdGggLSBpbnB1dEJvdW5kcy53aWR0aCkgLyAyXG4gICAgICAgICAgICAgICAgICAgIDogMCk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCAtIGlucHV0Qm91bmRzLnJpZ2h0O1xuICAgICAgICAgICAgdmFyIHJpZ2h0TW9zdCA9IGxlZnQgKyBjYWxlbmRhcldpZHRoID4gd2luZG93LmRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB2YXIgY2VudGVyTW9zdCA9IHJpZ2h0ICsgY2FsZW5kYXJXaWR0aCA+IHdpbmRvdy5kb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJyaWdodE1vc3RcIiwgcmlnaHRNb3N0KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5zdGF0aWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgICAgICBpZiAoIXJpZ2h0TW9zdCkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWNlbnRlck1vc3QpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLmxlZnQgPSBcImF1dG9cIjtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnJpZ2h0ID0gcmlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gZG9jdW1lbnQuc3R5bGVTaGVldHNbMF07XG4gICAgICAgICAgICAgICAgLy8gc29tZSB0ZXN0aW5nIGVudmlyb25tZW50cyBkb24ndCBoYXZlIGNzcyBzdXBwb3J0XG4gICAgICAgICAgICAgICAgaWYgKGRvYyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGJvZHlXaWR0aCA9IHdpbmRvdy5kb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJMZWZ0ID0gTWF0aC5tYXgoMCwgYm9keVdpZHRoIC8gMiAtIGNhbGVuZGFyV2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyQmVmb3JlID0gXCIuZmxhdHBpY2tyLWNhbGVuZGFyLmNlbnRlck1vc3Q6YmVmb3JlXCI7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlckFmdGVyID0gXCIuZmxhdHBpY2tyLWNhbGVuZGFyLmNlbnRlck1vc3Q6YWZ0ZXJcIjtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVySW5kZXggPSBkb2MuY3NzUnVsZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJTdHlsZSA9IFwie2xlZnQ6XCIgKyBpbnB1dEJvdW5kcy5sZWZ0ICsgXCJweDtyaWdodDphdXRvO31cIjtcbiAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcInJpZ2h0TW9zdFwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJjZW50ZXJNb3N0XCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGRvYy5pbnNlcnRSdWxlKGNlbnRlckJlZm9yZSArIFwiLFwiICsgY2VudGVyQWZ0ZXIgKyBjZW50ZXJTdHlsZSwgY2VudGVySW5kZXgpO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUubGVmdCA9IGNlbnRlckxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlZHJhdygpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5ub0NhbGVuZGFyIHx8IHNlbGYuaXNNb2JpbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICAgICAgYnVpbGREYXlzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZm9jdXNBbmRDbG9zZSgpIHtcbiAgICAgICAgICAgIHNlbGYuX2lucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUVcIikgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGhhY2sgLSBidWdzIGluIHRoZSB3YXkgSUUgaGFuZGxlcyBmb2N1cyBrZWVwcyB0aGUgY2FsZW5kYXIgb3BlblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoc2VsZi5jbG9zZSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2VsZWN0RGF0ZShlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdmFyIGlzU2VsZWN0YWJsZSA9IGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF5LmNsYXNzTGlzdCAmJlxuICAgICAgICAgICAgICAgICAgICBkYXkuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZmxhdHBpY2tyLWRheVwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAhZGF5LmNsYXNzTGlzdC5jb250YWlucyhcImRpc2FibGVkXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICFkYXkuY2xhc3NMaXN0LmNvbnRhaW5zKFwibm90QWxsb3dlZFwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdCA9IGZpbmRQYXJlbnQoZS50YXJnZXQsIGlzU2VsZWN0YWJsZSk7XG4gICAgICAgICAgICBpZiAodCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0O1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkRGF0ZSA9IChzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiA9IG5ldyBEYXRlKHRhcmdldC5kYXRlT2JqLmdldFRpbWUoKSkpO1xuICAgICAgICAgICAgdmFyIHNob3VsZENoYW5nZU1vbnRoID0gKHNlbGVjdGVkRGF0ZS5nZXRNb250aCgpIDwgc2VsZi5jdXJyZW50TW9udGggfHxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZERhdGUuZ2V0TW9udGgoKSA+XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoICsgc2VsZi5jb25maWcuc2hvd01vbnRocyAtIDEpICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubW9kZSAhPT0gXCJyYW5nZVwiO1xuICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVFbGVtID0gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwic2luZ2xlXCIpXG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzID0gW3NlbGVjdGVkRGF0ZV07XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcIm11bHRpcGxlXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRJbmRleCA9IGlzRGF0ZVNlbGVjdGVkKHNlbGVjdGVkRGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5zcGxpY2UocGFyc2VJbnQoc2VsZWN0ZWRJbmRleCksIDEpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLnB1c2goc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIikge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYXIoZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPSBzZWxlY3RlZERhdGU7XG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLnB1c2goc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgICAgICAgICAvLyB1bmxlc3Mgc2VsZWN0aW5nIHNhbWUgZGF0ZSB0d2ljZSwgc29ydCBhc2NlbmRpbmdseVxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlRGF0ZXMoc2VsZWN0ZWREYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0sIHRydWUpICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5nZXRUaW1lKCkgLSBiLmdldFRpbWUoKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRIb3Vyc0Zyb21JbnB1dHMoKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRDaGFuZ2VNb250aCkge1xuICAgICAgICAgICAgICAgIHZhciBpc05ld1llYXIgPSBzZWxmLmN1cnJlbnRZZWFyICE9PSBzZWxlY3RlZERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID0gc2VsZWN0ZWREYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBzZWxlY3RlZERhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOZXdZZWFyKVxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblllYXJDaGFuZ2VcIik7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25Nb250aENoYW5nZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKTtcbiAgICAgICAgICAgIGJ1aWxkRGF5cygpO1xuICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGVUaW1lKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gKHNlbGYuc2hvd1RpbWVJbnB1dCA9IHRydWUpOyB9LCA1MCk7XG4gICAgICAgICAgICAvLyBtYWludGFpbiBmb2N1c1xuICAgICAgICAgICAgaWYgKCFzaG91bGRDaGFuZ2VNb250aCAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1vZGUgIT09IFwicmFuZ2VcIiAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLnNob3dNb250aHMgPT09IDEpXG4gICAgICAgICAgICAgICAgZm9jdXNPbkRheUVsZW0odGFyZ2V0KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuc2VsZWN0ZWREYXRlRWxlbSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVFbGVtICYmIHNlbGYuc2VsZWN0ZWREYXRlRWxlbS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaG91ckVsZW1lbnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgc2VsZi5ob3VyRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmNsb3NlT25TZWxlY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlID0gc2VsZi5jb25maWcubW9kZSA9PT0gXCJzaW5nbGVcIiAmJiAhc2VsZi5jb25maWcuZW5hYmxlVGltZTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgICAgICAhc2VsZi5jb25maWcuZW5hYmxlVGltZTtcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlIHx8IHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIENBTExCQUNLUyA9IHtcbiAgICAgICAgICAgIGxvY2FsZTogW3NldHVwTG9jYWxlLCB1cGRhdGVXZWVrZGF5c10sXG4gICAgICAgICAgICBzaG93TW9udGhzOiBbYnVpbGRNb250aHMsIHNldENhbGVuZGFyV2lkdGgsIGJ1aWxkV2Vla2RheXNdXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHNldChvcHRpb24sIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uICE9PSBudWxsICYmIHR5cGVvZiBvcHRpb24gPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZWxmLmNvbmZpZywgb3B0aW9uKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW29wdGlvbl0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoQ0FMTEJBQ0tTW29wdGlvbl0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgQ0FMTEJBQ0tTW29wdGlvbl0uZm9yRWFjaChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCgpOyB9KTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChIT09LUy5pbmRleE9mKG9wdGlvbikgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWdbb3B0aW9uXSA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICB1cGRhdGVWYWx1ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0U2VsZWN0ZWREYXRlKGlucHV0RGF0ZSwgZm9ybWF0KSB7XG4gICAgICAgICAgICB2YXIgZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChpbnB1dERhdGUgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICBkYXRlcyA9IGlucHV0RGF0ZS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHNlbGYucGFyc2VEYXRlKGQsIGZvcm1hdCk7IH0pO1xuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXREYXRlIGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2YgaW5wdXREYXRlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIGRhdGVzID0gW3NlbGYucGFyc2VEYXRlKGlucHV0RGF0ZSwgZm9ybWF0KV07XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXREYXRlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZWxmLmNvbmZpZy5tb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzaW5nbGVcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRpbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVzID0gW3NlbGYucGFyc2VEYXRlKGlucHV0RGF0ZSwgZm9ybWF0KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm11bHRpcGxlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlcyA9IGlucHV0RGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdChzZWxmLmNvbmZpZy5jb25qdW5jdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBzZWxmLnBhcnNlRGF0ZShkYXRlLCBmb3JtYXQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmFuZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVzID0gaW5wdXREYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KHNlbGYubDEwbi5yYW5nZVNlcGFyYXRvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBzZWxmLnBhcnNlRGF0ZShkYXRlLCBmb3JtYXQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmVycm9ySGFuZGxlcihuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgc3VwcGxpZWQ6IFwiICsgSlNPTi5zdHJpbmdpZnkoaW5wdXREYXRlKSkpO1xuICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzID0gZGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkIGluc3RhbmNlb2YgRGF0ZSAmJiBpc0VuYWJsZWQoZCwgZmFsc2UpOyB9KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpXG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuZ2V0VGltZSgpIC0gYi5nZXRUaW1lKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldERhdGUoZGF0ZSwgdHJpZ2dlckNoYW5nZSwgZm9ybWF0KSB7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSA9PT0gdm9pZCAwKSB7IHRyaWdnZXJDaGFuZ2UgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gdm9pZCAwKSB7IGZvcm1hdCA9IHNlbGYuY29uZmlnLmRhdGVGb3JtYXQ7IH1cbiAgICAgICAgICAgIGlmICgoZGF0ZSAhPT0gMCAmJiAhZGF0ZSkgfHwgKGRhdGUgaW5zdGFuY2VvZiBBcnJheSAmJiBkYXRlLmxlbmd0aCA9PT0gMCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2xlYXIodHJpZ2dlckNoYW5nZSk7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZERhdGUoZGF0ZSwgZm9ybWF0KTtcbiAgICAgICAgICAgIHNlbGYuc2hvd1RpbWVJbnB1dCA9IHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPSBzZWxmLnNlbGVjdGVkRGF0ZXNbMF07XG4gICAgICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICAgICAganVtcFRvRGF0ZSgpO1xuICAgICAgICAgICAgc2V0SG91cnNGcm9tRGF0ZSgpO1xuICAgICAgICAgICAgdXBkYXRlVmFsdWUodHJpZ2dlckNoYW5nZSk7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSlcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNoYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwYXJzZURhdGVSdWxlcyhhcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJcbiAgICAgICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUgPT09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJ1bGUgPT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgcnVsZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucGFyc2VEYXRlKHJ1bGUsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJ1bGUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5mcm9tICYmXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUudG8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBzZWxmLnBhcnNlRGF0ZShydWxlLmZyb20sIHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogc2VsZi5wYXJzZURhdGUocnVsZS50bywgdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KTsgLy8gcmVtb3ZlIGZhbHN5IHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwRGF0ZXMoKSB7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIHNlbGYubm93ID0gc2VsZi5wYXJzZURhdGUoc2VsZi5jb25maWcubm93KSB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBJRTExIHNldHRpbmcgcGxhY2Vob2xkZXIgYXMgdGhlIGlucHV0J3MgdmFsdWVcbiAgICAgICAgICAgIHZhciBwcmVsb2FkZWREYXRlID0gc2VsZi5jb25maWcuZGVmYXVsdERhdGUgfHxcbiAgICAgICAgICAgICAgICAoKHNlbGYuaW5wdXQubm9kZU5hbWUgPT09IFwiSU5QVVRcIiB8fFxuICAgICAgICAgICAgICAgICAgICBzZWxmLmlucHV0Lm5vZGVOYW1lID09PSBcIlRFWFRBUkVBXCIpICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQucGxhY2Vob2xkZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC52YWx1ZSA9PT0gc2VsZi5pbnB1dC5wbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmlucHV0LnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChwcmVsb2FkZWREYXRlKVxuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkRGF0ZShwcmVsb2FkZWREYXRlLCBzZWxmLmNvbmZpZy5kYXRlRm9ybWF0KTtcbiAgICAgICAgICAgIHNlbGYuX2luaXRpYWxEYXRlID1cbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuc2VsZWN0ZWREYXRlc1swXVxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0VGltZSgpID4gc2VsZi5ub3cuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1pbkRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWF4RGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heERhdGUuZ2V0VGltZSgpIDwgc2VsZi5ub3cuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5tYXhEYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLm5vdztcbiAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBzZWxmLl9pbml0aWFsRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBzZWxmLl9pbml0aWFsRGF0ZS5nZXRNb250aCgpO1xuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID0gc2VsZi5zZWxlY3RlZERhdGVzWzBdO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1pblRpbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5UaW1lID0gc2VsZi5wYXJzZURhdGUoc2VsZi5jb25maWcubWluVGltZSwgXCJIOmlcIik7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWF4VGltZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heFRpbWUgPSBzZWxmLnBhcnNlRGF0ZShzZWxmLmNvbmZpZy5tYXhUaW1lLCBcIkg6aVwiKTtcbiAgICAgICAgICAgIHNlbGYubWluRGF0ZUhhc1RpbWUgPVxuICAgICAgICAgICAgICAgICEhc2VsZi5jb25maWcubWluRGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWluRGF0ZS5nZXRIb3VycygpID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWluRGF0ZS5nZXRNaW51dGVzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5EYXRlLmdldFNlY29uZHMoKSA+IDApO1xuICAgICAgICAgICAgc2VsZi5tYXhEYXRlSGFzVGltZSA9XG4gICAgICAgICAgICAgICAgISFzZWxmLmNvbmZpZy5tYXhEYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEhvdXJzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldE1pbnV0ZXMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heERhdGUuZ2V0U2Vjb25kcygpID4gMCk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgXCJzaG93VGltZUlucHV0XCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuX3Nob3dUaW1lSW5wdXQ7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9zaG93VGltZUlucHV0ID0gYm9vbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcInNob3dUaW1lSW5wdXRcIiwgYm9vbCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaXNPcGVuICYmIHBvc2l0aW9uQ2FsZW5kYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR1cElucHV0cygpIHtcbiAgICAgICAgICAgIHNlbGYuaW5wdXQgPSBzZWxmLmNvbmZpZy53cmFwXG4gICAgICAgICAgICAgICAgPyBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1pbnB1dF1cIilcbiAgICAgICAgICAgICAgICA6IGVsZW1lbnQ7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgZWxlbWVudCBzcGVjaWZpZWRcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhY2s6IHN0b3JlIHByZXZpb3VzIHR5cGUgdG8gcmVzdG9yZSBpdCBhZnRlciBkZXN0cm95KClcbiAgICAgICAgICAgIHNlbGYuaW5wdXQuX3R5cGUgPSBzZWxmLmlucHV0LnR5cGU7XG4gICAgICAgICAgICBzZWxmLmlucHV0LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICAgIHNlbGYuaW5wdXQuY2xhc3NMaXN0LmFkZChcImZsYXRwaWNrci1pbnB1dFwiKTtcbiAgICAgICAgICAgIHNlbGYuX2lucHV0ID0gc2VsZi5pbnB1dDtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hbHRJbnB1dCkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxpY2F0ZSBzZWxmLmVsZW1lbnRcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0ID0gY3JlYXRlRWxlbWVudChzZWxmLmlucHV0Lm5vZGVOYW1lLCBzZWxmLmlucHV0LmNsYXNzTmFtZSArIFwiIFwiICsgc2VsZi5jb25maWcuYWx0SW5wdXRDbGFzcyk7XG4gICAgICAgICAgICAgICAgc2VsZi5faW5wdXQgPSBzZWxmLmFsdElucHV0O1xuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQucGxhY2Vob2xkZXIgPSBzZWxmLmlucHV0LnBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQuZGlzYWJsZWQgPSBzZWxmLmlucHV0LmRpc2FibGVkO1xuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQucmVxdWlyZWQgPSBzZWxmLmlucHV0LnJlcXVpcmVkO1xuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQudGFiSW5kZXggPSBzZWxmLmlucHV0LnRhYkluZGV4O1xuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYuY29uZmlnLnN0YXRpYyAmJiBzZWxmLmlucHV0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2VsZi5hbHRJbnB1dCwgc2VsZi5pbnB1dC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGYuY29uZmlnLmFsbG93SW5wdXQpXG4gICAgICAgICAgICAgICAgc2VsZi5faW5wdXQuc2V0QXR0cmlidXRlKFwicmVhZG9ubHlcIiwgXCJyZWFkb25seVwiKTtcbiAgICAgICAgICAgIHNlbGYuX3Bvc2l0aW9uRWxlbWVudCA9IHNlbGYuY29uZmlnLnBvc2l0aW9uRWxlbWVudCB8fCBzZWxmLl9pbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR1cE1vYmlsZSgpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFR5cGUgPSBzZWxmLmNvbmZpZy5lbmFibGVUaW1lXG4gICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5ub0NhbGVuZGFyXG4gICAgICAgICAgICAgICAgICAgID8gXCJ0aW1lXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcImRhdGV0aW1lLWxvY2FsXCJcbiAgICAgICAgICAgICAgICA6IFwiZGF0ZVwiO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dCA9IGNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBzZWxmLmlucHV0LmNsYXNzTmFtZSArIFwiIGZsYXRwaWNrci1tb2JpbGVcIik7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnN0ZXAgPSBzZWxmLmlucHV0LmdldEF0dHJpYnV0ZShcInN0ZXBcIikgfHwgXCJhbnlcIjtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQudGFiSW5kZXggPSAxO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC50eXBlID0gaW5wdXRUeXBlO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5kaXNhYmxlZCA9IHNlbGYuaW5wdXQuZGlzYWJsZWQ7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnJlcXVpcmVkID0gc2VsZi5pbnB1dC5yZXF1aXJlZDtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQucGxhY2Vob2xkZXIgPSBzZWxmLmlucHV0LnBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVGb3JtYXRTdHIgPVxuICAgICAgICAgICAgICAgIGlucHV0VHlwZSA9PT0gXCJkYXRldGltZS1sb2NhbFwiXG4gICAgICAgICAgICAgICAgICAgID8gXCJZLW0tZFxcXFxUSDppOlNcIlxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0VHlwZSA9PT0gXCJkYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJZLW0tZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiSDppOlNcIjtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQuZGVmYXVsdFZhbHVlID0gc2VsZi5tb2JpbGVJbnB1dC52YWx1ZSA9IHNlbGYuZm9ybWF0RGF0ZShzZWxmLnNlbGVjdGVkRGF0ZXNbMF0sIHNlbGYubW9iaWxlRm9ybWF0U3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5taW5EYXRlKVxuICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQubWluID0gc2VsZi5mb3JtYXREYXRlKHNlbGYuY29uZmlnLm1pbkRhdGUsIFwiWS1tLWRcIik7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWF4RGF0ZSlcbiAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0Lm1heCA9IHNlbGYuZm9ybWF0RGF0ZShzZWxmLmNvbmZpZy5tYXhEYXRlLCBcIlktbS1kXCIpO1xuICAgICAgICAgICAgc2VsZi5pbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgIGlmIChzZWxmLmFsdElucHV0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaW5wdXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzZWxmLm1vYmlsZUlucHV0LCBzZWxmLmlucHV0Lm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICBiaW5kKHNlbGYubW9iaWxlSW5wdXQsIFwiY2hhbmdlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXREYXRlKGUudGFyZ2V0LnZhbHVlLCBmYWxzZSwgc2VsZi5tb2JpbGVGb3JtYXRTdHIpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2xvc2VcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0b2dnbGUoZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNPcGVuID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICBzZWxmLm9wZW4oZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJpZ2dlckV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkIGFscmVhZHksIGFsbCBob29rcyBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGhvb2tzID0gc2VsZi5jb25maWdbZXZlbnRdO1xuICAgICAgICAgICAgaWYgKGhvb2tzICE9PSB1bmRlZmluZWQgJiYgaG9va3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBob29rc1tpXSAmJiBpIDwgaG9va3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzW2ldKHNlbGYuc2VsZWN0ZWREYXRlcywgc2VsZi5pbnB1dC52YWx1ZSwgc2VsZiwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09IFwib25DaGFuZ2VcIikge1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuZGlzcGF0Y2hFdmVudChjcmVhdGVFdmVudChcImNoYW5nZVwiKSk7XG4gICAgICAgICAgICAgICAgLy8gbWFueSBmcm9udC1lbmQgZnJhbWV3b3JrcyBiaW5kIHRvIHRoZSBpbnB1dCBldmVudFxuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuZGlzcGF0Y2hFdmVudChjcmVhdGVFdmVudChcImlucHV0XCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVFdmVudChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgICAgICAgICBlLmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRGF0ZVNlbGVjdGVkKGRhdGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVEYXRlcyhzZWxmLnNlbGVjdGVkRGF0ZXNbaV0sIGRhdGUpID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIiArIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNEYXRlSW5SYW5nZShkYXRlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSAhPT0gXCJyYW5nZVwiIHx8IHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPCAyKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiAoY29tcGFyZURhdGVzKGRhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1swXSkgPj0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMV0pIDw9IDApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubm9DYWxlbmRhciB8fCBzZWxmLmlzTW9iaWxlIHx8ICFzZWxmLm1vbnRoTmF2KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNlbGYueWVhckVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKHllYXJFbGVtZW50LCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZShzZWxmLmN1cnJlbnRZZWFyLCBzZWxmLmN1cnJlbnRNb250aCwgMSk7XG4gICAgICAgICAgICAgICAgZC5zZXRNb250aChzZWxmLmN1cnJlbnRNb250aCArIGkpO1xuICAgICAgICAgICAgICAgIHNlbGYubW9udGhFbGVtZW50c1tpXS50ZXh0Q29udGVudCA9XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoVG9TdHIoZC5nZXRNb250aCgpLCBzZWxmLmNvbmZpZy5zaG9ydGhhbmRDdXJyZW50TW9udGgsIHNlbGYubDEwbikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgXCI7XG4gICAgICAgICAgICAgICAgeWVhckVsZW1lbnQudmFsdWUgPSBkLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5faGlkZVByZXZNb250aEFycm93ID1cbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5EYXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmN1cnJlbnRNb250aCA8PSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1vbnRoKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jdXJyZW50WWVhciA8IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSk7XG4gICAgICAgICAgICBzZWxmLl9oaWRlTmV4dE1vbnRoQXJyb3cgPVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heERhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAoc2VsZi5jdXJyZW50WWVhciA9PT0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY3VycmVudE1vbnRoICsgMSA+IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TW9udGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmN1cnJlbnRZZWFyID4gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXREYXRlU3RyKGZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2VsZWN0ZWREYXRlc1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRPYmopIHsgcmV0dXJuIHNlbGYuZm9ybWF0RGF0ZShkT2JqLCBmb3JtYXQpOyB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGQsIGksIGFycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZW5hYmxlVGltZSB8fFxuICAgICAgICAgICAgICAgICAgICBhcnIuaW5kZXhPZihkKSA9PT0gaTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oc2VsZi5jb25maWcubW9kZSAhPT0gXCJyYW5nZVwiXG4gICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5jb25qdW5jdGlvblxuICAgICAgICAgICAgICAgIDogc2VsZi5sMTBuLnJhbmdlU2VwYXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgdmFsdWVzIG9mIGlucHV0cyBhc3NvY2lhdGVkIHdpdGggdGhlIGNhbGVuZGFyXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB1cGRhdGVWYWx1ZSh0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSA9PT0gdm9pZCAwKSB7IHRyaWdnZXJDaGFuZ2UgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jbGVhcih0cmlnZ2VyQ2hhbmdlKTtcbiAgICAgICAgICAgIGlmIChzZWxmLm1vYmlsZUlucHV0ICE9PSB1bmRlZmluZWQgJiYgc2VsZi5tb2JpbGVGb3JtYXRTdHIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmZvcm1hdERhdGUoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmosIHNlbGYubW9iaWxlRm9ybWF0U3RyKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5pbnB1dC52YWx1ZSA9IGdldERhdGVTdHIoc2VsZi5jb25maWcuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbHRJbnB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC52YWx1ZSA9IGdldERhdGVTdHIoc2VsZi5jb25maWcuYWx0Rm9ybWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblZhbHVlVXBkYXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uTW9udGhOYXZDbGljayhlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgaXNQcmV2TW9udGggPSBzZWxmLnByZXZNb250aE5hdi5jb250YWlucyhlLnRhcmdldCk7XG4gICAgICAgICAgICB2YXIgaXNOZXh0TW9udGggPSBzZWxmLm5leHRNb250aE5hdi5jb250YWlucyhlLnRhcmdldCk7XG4gICAgICAgICAgICBpZiAoaXNQcmV2TW9udGggfHwgaXNOZXh0TW9udGgpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VNb250aChpc1ByZXZNb250aCA/IC0xIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxmLnllYXJFbGVtZW50cy5pbmRleE9mKGUudGFyZ2V0KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZS50YXJnZXQuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJhcnJvd1VwXCIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jaGFuZ2VZZWFyKHNlbGYuY3VycmVudFllYXIgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImFycm93RG93blwiKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlWWVhcihzZWxmLmN1cnJlbnRZZWFyIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGltZVdyYXBwZXIoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIGlzS2V5RG93biA9IGUudHlwZSA9PT0gXCJrZXlkb3duXCIsIGlucHV0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQgJiYgZS50YXJnZXQgPT09IHNlbGYuYW1QTSkge1xuICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50ZXh0Q29udGVudCA9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubDEwbi5hbVBNW2ludChzZWxmLmFtUE0udGV4dENvbnRlbnQgPT09IHNlbGYubDEwbi5hbVBNWzBdKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWluID0gcGFyc2VGbG9hdChpbnB1dC5nZXRBdHRyaWJ1dGUoXCJtaW5cIikpLCBtYXggPSBwYXJzZUZsb2F0KGlucHV0LmdldEF0dHJpYnV0ZShcIm1heFwiKSksIHN0ZXAgPSBwYXJzZUZsb2F0KGlucHV0LmdldEF0dHJpYnV0ZShcInN0ZXBcIikpLCBjdXJWYWx1ZSA9IHBhcnNlSW50KGlucHV0LnZhbHVlLCAxMCksIGRlbHRhID0gZS5kZWx0YSB8fFxuICAgICAgICAgICAgICAgIChpc0tleURvd24gPyAoZS53aGljaCA9PT0gMzggPyAxIDogLTEpIDogMCk7XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXJWYWx1ZSArIHN0ZXAgKiBkZWx0YTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgJiYgaW5wdXQudmFsdWUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzSG91ckVsZW0gPSBpbnB1dCA9PT0gc2VsZi5ob3VyRWxlbWVudCwgaXNNaW51dGVFbGVtID0gaW5wdXQgPT09IHNlbGYubWludXRlRWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50KCFpc0hvdXJFbGVtKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGludChpc0hvdXJFbGVtKSAmJiBpbnQoIXNlbGYuYW1QTSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNaW51dGVFbGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50TnVtSW5wdXQodW5kZWZpbmVkLCAtMSwgc2VsZi5ob3VyRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld1ZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0ID09PSBzZWxmLmhvdXJFbGVtZW50ID8gbmV3VmFsdWUgLSBtYXggLSBpbnQoIXNlbGYuYW1QTSkgOiBtaW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01pbnV0ZUVsZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnROdW1JbnB1dCh1bmRlZmluZWQsIDEsIHNlbGYuaG91ckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hbVBNICYmXG4gICAgICAgICAgICAgICAgICAgIGlzSG91ckVsZW0gJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0ZXAgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3VmFsdWUgKyBjdXJWYWx1ZSA9PT0gMjNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5hYnMobmV3VmFsdWUgLSBjdXJWYWx1ZSkgPiBzdGVwKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sMTBuLmFtUE1baW50KHNlbGYuYW1QTS50ZXh0Q29udGVudCA9PT0gc2VsZi5sMTBuLmFtUE1bMF0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBwYWQobmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluaXQoKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZnVuY3Rpb24gX2ZsYXRwaWNrcihub2RlTGlzdCwgY29uZmlnKSB7XG4gICAgICAgIC8vIHN0YXRpYyBsaXN0XG4gICAgICAgIHZhciBub2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgICAgICAgLmNhbGwobm9kZUxpc3QpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7IH0pO1xuICAgICAgICB2YXIgaW5zdGFuY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZnAtb21pdFwiKSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuX2ZsYXRwaWNrciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2ZsYXRwaWNrci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2ZsYXRwaWNrciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5fZmxhdHBpY2tyID0gRmxhdHBpY2tySW5zdGFuY2Uobm9kZSwgY29uZmlnIHx8IHt9KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXMucHVzaChub2RlLl9mbGF0cGlja3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZXMubGVuZ3RoID09PSAxID8gaW5zdGFuY2VzWzBdIDogaW5zdGFuY2VzO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gYnJvd3NlciBlbnZcbiAgICAgICAgSFRNTENvbGxlY3Rpb24ucHJvdG90eXBlLmZsYXRwaWNrciA9IE5vZGVMaXN0LnByb3RvdHlwZS5mbGF0cGlja3IgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcih0aGlzLCBjb25maWcpO1xuICAgICAgICB9O1xuICAgICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuZmxhdHBpY2tyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3IoW3RoaXNdLCBjb25maWcpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHZhciBmbGF0cGlja3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGNvbmZpZykge1xuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcih3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0b3IgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcihbc2VsZWN0b3JdLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3Ioc2VsZWN0b3IsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZmxhdHBpY2tyLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0cztcbiAgICBmbGF0cGlja3IubDEwbnMgPSB7XG4gICAgICAgIGVuOiBfX2Fzc2lnbih7fSwgZW5nbGlzaCksXG4gICAgICAgIFwiZGVmYXVsdFwiOiBfX2Fzc2lnbih7fSwgZW5nbGlzaClcbiAgICB9O1xuICAgIGZsYXRwaWNrci5sb2NhbGl6ZSA9IGZ1bmN0aW9uIChsMTBuKSB7XG4gICAgICAgIGZsYXRwaWNrci5sMTBuc1tcImRlZmF1bHRcIl0gPSBfX2Fzc2lnbih7fSwgZmxhdHBpY2tyLmwxMG5zW1wiZGVmYXVsdFwiXSwgbDEwbik7XG4gICAgfTtcbiAgICBmbGF0cGlja3Iuc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnID0gX19hc3NpZ24oe30sIGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnLCBjb25maWcpO1xuICAgIH07XG4gICAgZmxhdHBpY2tyLnBhcnNlRGF0ZSA9IGNyZWF0ZURhdGVQYXJzZXIoe30pO1xuICAgIGZsYXRwaWNrci5mb3JtYXREYXRlID0gY3JlYXRlRGF0ZUZvcm1hdHRlcih7fSk7XG4gICAgZmxhdHBpY2tyLmNvbXBhcmVEYXRlcyA9IGNvbXBhcmVEYXRlcztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGpRdWVyeS5mbi5mbGF0cGlja3IgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcih0aGlzLCBjb25maWcpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBEYXRlLnByb3RvdHlwZS5mcF9pbmNyID0gZnVuY3Rpb24gKGRheXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSwgdGhpcy5nZXRNb250aCgpLCB0aGlzLmdldERhdGUoKSArICh0eXBlb2YgZGF5cyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlSW50KGRheXMsIDEwKSA6IGRheXMpKTtcbiAgICB9O1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHdpbmRvdy5mbGF0cGlja3IgPSBmbGF0cGlja3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsYXRwaWNrcjtcblxufSkpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmRlID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmcCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmZsYXRwaWNrciAhPT0gdW5kZWZpbmVkXG4gICAgICA/IHdpbmRvdy5mbGF0cGlja3JcbiAgICAgIDoge1xuICAgICAgICAgIGwxMG5zOiB7fVxuICAgICAgfTtcbiAgdmFyIEdlcm1hbiA9IHtcbiAgICAgIHdlZWtkYXlzOiB7XG4gICAgICAgICAgc2hvcnRoYW5kOiBbXCJTb1wiLCBcIk1vXCIsIFwiRGlcIiwgXCJNaVwiLCBcIkRvXCIsIFwiRnJcIiwgXCJTYVwiXSxcbiAgICAgICAgICBsb25naGFuZDogW1xuICAgICAgICAgICAgICBcIlNvbm50YWdcIixcbiAgICAgICAgICAgICAgXCJNb250YWdcIixcbiAgICAgICAgICAgICAgXCJEaWVuc3RhZ1wiLFxuICAgICAgICAgICAgICBcIk1pdHR3b2NoXCIsXG4gICAgICAgICAgICAgIFwiRG9ubmVyc3RhZ1wiLFxuICAgICAgICAgICAgICBcIkZyZWl0YWdcIixcbiAgICAgICAgICAgICAgXCJTYW1zdGFnXCIsXG4gICAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIG1vbnRoczoge1xuICAgICAgICAgIHNob3J0aGFuZDogW1xuICAgICAgICAgICAgICBcIkphblwiLFxuICAgICAgICAgICAgICBcIkZlYlwiLFxuICAgICAgICAgICAgICBcIk3DpHJcIixcbiAgICAgICAgICAgICAgXCJBcHJcIixcbiAgICAgICAgICAgICAgXCJNYWlcIixcbiAgICAgICAgICAgICAgXCJKdW5cIixcbiAgICAgICAgICAgICAgXCJKdWxcIixcbiAgICAgICAgICAgICAgXCJBdWdcIixcbiAgICAgICAgICAgICAgXCJTZXBcIixcbiAgICAgICAgICAgICAgXCJPa3RcIixcbiAgICAgICAgICAgICAgXCJOb3ZcIixcbiAgICAgICAgICAgICAgXCJEZXpcIixcbiAgICAgICAgICBdLFxuICAgICAgICAgIGxvbmdoYW5kOiBbXG4gICAgICAgICAgICAgIFwiSmFudWFyXCIsXG4gICAgICAgICAgICAgIFwiRmVicnVhclwiLFxuICAgICAgICAgICAgICBcIk3DpHJ6XCIsXG4gICAgICAgICAgICAgIFwiQXByaWxcIixcbiAgICAgICAgICAgICAgXCJNYWlcIixcbiAgICAgICAgICAgICAgXCJKdW5pXCIsXG4gICAgICAgICAgICAgIFwiSnVsaVwiLFxuICAgICAgICAgICAgICBcIkF1Z3VzdFwiLFxuICAgICAgICAgICAgICBcIlNlcHRlbWJlclwiLFxuICAgICAgICAgICAgICBcIk9rdG9iZXJcIixcbiAgICAgICAgICAgICAgXCJOb3ZlbWJlclwiLFxuICAgICAgICAgICAgICBcIkRlemVtYmVyXCIsXG4gICAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIGZpcnN0RGF5T2ZXZWVrOiAxLFxuICAgICAgd2Vla0FiYnJldmlhdGlvbjogXCJLV1wiLFxuICAgICAgcmFuZ2VTZXBhcmF0b3I6IFwiIGJpcyBcIixcbiAgICAgIHNjcm9sbFRpdGxlOiBcIlp1bSDDhG5kZXJuIHNjcm9sbGVuXCIsXG4gICAgICB0b2dnbGVUaXRsZTogXCJadW0gVW1zY2hhbHRlbiBrbGlja2VuXCJcbiAgfTtcbiAgZnAubDEwbnMuZGUgPSBHZXJtYW47XG4gIHZhciBkZSA9IGZwLmwxMG5zO1xuXG4gIGV4cG9ydHMuR2VybWFuID0gR2VybWFuO1xuICBleHBvcnRzLmRlZmF1bHQgPSBkZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZnIgPSB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZwID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZmxhdHBpY2tyICE9PSB1bmRlZmluZWRcbiAgICAgID8gd2luZG93LmZsYXRwaWNrclxuICAgICAgOiB7XG4gICAgICAgICAgbDEwbnM6IHt9XG4gICAgICB9O1xuICB2YXIgRnJlbmNoID0ge1xuICAgICAgZmlyc3REYXlPZldlZWs6IDEsXG4gICAgICB3ZWVrZGF5czoge1xuICAgICAgICAgIHNob3J0aGFuZDogW1wiZGltXCIsIFwibHVuXCIsIFwibWFyXCIsIFwibWVyXCIsIFwiamV1XCIsIFwidmVuXCIsIFwic2FtXCJdLFxuICAgICAgICAgIGxvbmdoYW5kOiBbXG4gICAgICAgICAgICAgIFwiZGltYW5jaGVcIixcbiAgICAgICAgICAgICAgXCJsdW5kaVwiLFxuICAgICAgICAgICAgICBcIm1hcmRpXCIsXG4gICAgICAgICAgICAgIFwibWVyY3JlZGlcIixcbiAgICAgICAgICAgICAgXCJqZXVkaVwiLFxuICAgICAgICAgICAgICBcInZlbmRyZWRpXCIsXG4gICAgICAgICAgICAgIFwic2FtZWRpXCIsXG4gICAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIG1vbnRoczoge1xuICAgICAgICAgIHNob3J0aGFuZDogW1xuICAgICAgICAgICAgICBcImphbnZcIixcbiAgICAgICAgICAgICAgXCJmw6l2clwiLFxuICAgICAgICAgICAgICBcIm1hcnNcIixcbiAgICAgICAgICAgICAgXCJhdnJcIixcbiAgICAgICAgICAgICAgXCJtYWlcIixcbiAgICAgICAgICAgICAgXCJqdWluXCIsXG4gICAgICAgICAgICAgIFwianVpbFwiLFxuICAgICAgICAgICAgICBcImFvw7t0XCIsXG4gICAgICAgICAgICAgIFwic2VwdFwiLFxuICAgICAgICAgICAgICBcIm9jdFwiLFxuICAgICAgICAgICAgICBcIm5vdlwiLFxuICAgICAgICAgICAgICBcImTDqWNcIixcbiAgICAgICAgICBdLFxuICAgICAgICAgIGxvbmdoYW5kOiBbXG4gICAgICAgICAgICAgIFwiamFudmllclwiLFxuICAgICAgICAgICAgICBcImbDqXZyaWVyXCIsXG4gICAgICAgICAgICAgIFwibWFyc1wiLFxuICAgICAgICAgICAgICBcImF2cmlsXCIsXG4gICAgICAgICAgICAgIFwibWFpXCIsXG4gICAgICAgICAgICAgIFwianVpblwiLFxuICAgICAgICAgICAgICBcImp1aWxsZXRcIixcbiAgICAgICAgICAgICAgXCJhb8O7dFwiLFxuICAgICAgICAgICAgICBcInNlcHRlbWJyZVwiLFxuICAgICAgICAgICAgICBcIm9jdG9icmVcIixcbiAgICAgICAgICAgICAgXCJub3ZlbWJyZVwiLFxuICAgICAgICAgICAgICBcImTDqWNlbWJyZVwiLFxuICAgICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnRoKSB7XG4gICAgICAgICAgaWYgKG50aCA+IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIHJldHVybiBcImVyXCI7XG4gICAgICB9LFxuICAgICAgcmFuZ2VTZXBhcmF0b3I6IFwiIGF1IFwiLFxuICAgICAgd2Vla0FiYnJldmlhdGlvbjogXCJTZW1cIixcbiAgICAgIHNjcm9sbFRpdGxlOiBcIkTDqWZpbGVyIHBvdXIgYXVnbWVudGVyIGxhIHZhbGV1clwiLFxuICAgICAgdG9nZ2xlVGl0bGU6IFwiQ2xpcXVlciBwb3VyIGJhc2N1bGVyXCJcbiAgfTtcbiAgZnAubDEwbnMuZnIgPSBGcmVuY2g7XG4gIHZhciBmciA9IGZwLmwxMG5zO1xuXG4gIGV4cG9ydHMuRnJlbmNoID0gRnJlbmNoO1xuICBleHBvcnRzLmRlZmF1bHQgPSBmcjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuaXQgPSB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZwID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZmxhdHBpY2tyICE9PSB1bmRlZmluZWRcbiAgICAgID8gd2luZG93LmZsYXRwaWNrclxuICAgICAgOiB7XG4gICAgICAgICAgbDEwbnM6IHt9XG4gICAgICB9O1xuICB2YXIgSXRhbGlhbiA9IHtcbiAgICAgIHdlZWtkYXlzOiB7XG4gICAgICAgICAgc2hvcnRoYW5kOiBbXCJEb21cIiwgXCJMdW5cIiwgXCJNYXJcIiwgXCJNZXJcIiwgXCJHaW9cIiwgXCJWZW5cIiwgXCJTYWJcIl0sXG4gICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgXCJEb21lbmljYVwiLFxuICAgICAgICAgICAgICBcIkx1bmVkw6xcIixcbiAgICAgICAgICAgICAgXCJNYXJ0ZWTDrFwiLFxuICAgICAgICAgICAgICBcIk1lcmNvbGVkw6xcIixcbiAgICAgICAgICAgICAgXCJHaW92ZWTDrFwiLFxuICAgICAgICAgICAgICBcIlZlbmVyZMOsXCIsXG4gICAgICAgICAgICAgIFwiU2FiYXRvXCIsXG4gICAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIG1vbnRoczoge1xuICAgICAgICAgIHNob3J0aGFuZDogW1xuICAgICAgICAgICAgICBcIkdlblwiLFxuICAgICAgICAgICAgICBcIkZlYlwiLFxuICAgICAgICAgICAgICBcIk1hclwiLFxuICAgICAgICAgICAgICBcIkFwclwiLFxuICAgICAgICAgICAgICBcIk1hZ1wiLFxuICAgICAgICAgICAgICBcIkdpdVwiLFxuICAgICAgICAgICAgICBcIkx1Z1wiLFxuICAgICAgICAgICAgICBcIkFnb1wiLFxuICAgICAgICAgICAgICBcIlNldFwiLFxuICAgICAgICAgICAgICBcIk90dFwiLFxuICAgICAgICAgICAgICBcIk5vdlwiLFxuICAgICAgICAgICAgICBcIkRpY1wiLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgXCJHZW5uYWlvXCIsXG4gICAgICAgICAgICAgIFwiRmViYnJhaW9cIixcbiAgICAgICAgICAgICAgXCJNYXJ6b1wiLFxuICAgICAgICAgICAgICBcIkFwcmlsZVwiLFxuICAgICAgICAgICAgICBcIk1hZ2dpb1wiLFxuICAgICAgICAgICAgICBcIkdpdWdub1wiLFxuICAgICAgICAgICAgICBcIkx1Z2xpb1wiLFxuICAgICAgICAgICAgICBcIkFnb3N0b1wiLFxuICAgICAgICAgICAgICBcIlNldHRlbWJyZVwiLFxuICAgICAgICAgICAgICBcIk90dG9icmVcIixcbiAgICAgICAgICAgICAgXCJOb3ZlbWJyZVwiLFxuICAgICAgICAgICAgICBcIkRpY2VtYnJlXCIsXG4gICAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIGZpcnN0RGF5T2ZXZWVrOiAxLFxuICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCLCsFwiOyB9LFxuICAgICAgcmFuZ2VTZXBhcmF0b3I6IFwiIGFsIFwiLFxuICAgICAgd2Vla0FiYnJldmlhdGlvbjogXCJTZVwiLFxuICAgICAgc2Nyb2xsVGl0bGU6IFwiU2Nyb2xsYSBwZXIgYXVtZW50YXJlXCIsXG4gICAgICB0b2dnbGVUaXRsZTogXCJDbGljY2EgcGVyIGNhbWJpYXJlXCJcbiAgfTtcbiAgZnAubDEwbnMuaXQgPSBJdGFsaWFuO1xuICB2YXIgaXQgPSBmcC5sMTBucztcblxuICBleHBvcnRzLkl0YWxpYW4gPSBJdGFsaWFuO1xuICBleHBvcnRzLmRlZmF1bHQgPSBpdDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjE2LjFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmVkZXJpY28gWml2b2xvIGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuUG9wcGVyID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJztcblxudmFyIHRpbWVvdXREdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxvbmdlclRpbWVvdXRCcm93c2VycyA9IFsnRWRnZScsICdUcmlkZW50JywgJ0ZpcmVmb3gnXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb25nZXJUaW1lb3V0QnJvd3NlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoaXNCcm93c2VyICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihsb25nZXJUaW1lb3V0QnJvd3NlcnNbaV0pID49IDApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn0oKTtcblxuZnVuY3Rpb24gbWljcm90YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB3aW5kb3cuUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGZuKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRhc2tEZWJvdW5jZShmbikge1xuICB2YXIgc2NoZWR1bGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIGZuKCk7XG4gICAgICB9LCB0aW1lb3V0RHVyYXRpb24pO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHN1cHBvcnRzTWljcm9UYXNrcyA9IGlzQnJvd3NlciAmJiB3aW5kb3cuUHJvbWlzZTtcblxuLyoqXG4qIENyZWF0ZSBhIGRlYm91bmNlZCB2ZXJzaW9uIG9mIGEgbWV0aG9kLCB0aGF0J3MgYXN5bmNocm9ub3VzbHkgZGVmZXJyZWRcbiogYnV0IGNhbGxlZCBpbiB0aGUgbWluaW11bSB0aW1lIHBvc3NpYmxlLlxuKlxuKiBAbWV0aG9kXG4qIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiogQGFyZ3VtZW50IHtGdW5jdGlvbn0gZm5cbiogQHJldHVybnMge0Z1bmN0aW9ufVxuKi9cbnZhciBkZWJvdW5jZSA9IHN1cHBvcnRzTWljcm9UYXNrcyA/IG1pY3JvdGFza0RlYm91bmNlIDogdGFza0RlYm91bmNlO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FueX0gZnVuY3Rpb25Ub0NoZWNrIC0gdmFyaWFibGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG86IGlzIGEgZnVuY3Rpb24/XG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG4gIHZhciBnZXRUeXBlID0ge307XG4gIHJldHVybiBmdW5jdGlvblRvQ2hlY2sgJiYgZ2V0VHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogR2V0IENTUyBjb21wdXRlZCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIHdpbmRvdyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgdmFyIGNzcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICByZXR1cm4gcHJvcGVydHkgPyBjc3NbcHJvcGVydHldIDogY3NzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcmVudE5vZGUgb3IgdGhlIGhvc3Qgb2YgdGhlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjcm9sbGluZyBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHNjcm9sbCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gUmV0dXJuIGJvZHksIGBnZXRTY3JvbGxgIHdpbGwgdGFrZSBjYXJlIHRvIGdldCB0aGUgY29ycmVjdCBgc2Nyb2xsVG9wYCBmcm9tIGl0XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgc3dpdGNoIChlbGVtZW50Lm5vZGVOYW1lKSB7XG4gICAgY2FzZSAnSFRNTCc6XG4gICAgY2FzZSAnQk9EWSc6XG4gICAgICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgIHJldHVybiBlbGVtZW50LmJvZHk7XG4gIH1cblxuICAvLyBGaXJlZm94IHdhbnQgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcblxuICB2YXIgX2dldFN0eWxlQ29tcHV0ZWRQcm9wID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WTtcblxuICBpZiAoLyhhdXRvfHNjcm9sbHxvdmVybGF5KS8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVmZXJlbmNlIG5vZGUgb2YgdGhlIHJlZmVyZW5jZSBvYmplY3QsIG9yIHRoZSByZWZlcmVuY2Ugb2JqZWN0IGl0c2VsZi5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSB7XG4gIHJldHVybiByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLnJlZmVyZW5jZU5vZGUgPyByZWZlcmVuY2UucmVmZXJlbmNlTm9kZSA6IHJlZmVyZW5jZTtcbn1cblxudmFyIGlzSUUxMSA9IGlzQnJvd3NlciAmJiAhISh3aW5kb3cuTVNJbnB1dE1ldGhvZENvbnRleHQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcbnZhciBpc0lFMTAgPSBpc0Jyb3dzZXIgJiYgL01TSUUgMTAvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3JlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZlcnNpb24gdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpc0lFXG4gKi9cbmZ1bmN0aW9uIGlzSUUodmVyc2lvbikge1xuICBpZiAodmVyc2lvbiA9PT0gMTEpIHtcbiAgICByZXR1cm4gaXNJRTExO1xuICB9XG4gIGlmICh2ZXJzaW9uID09PSAxMCkge1xuICAgIHJldHVybiBpc0lFMTA7XG4gIH1cbiAgcmV0dXJuIGlzSUUxMSB8fCBpc0lFMTA7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb2Zmc2V0IHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgdmFyIG5vT2Zmc2V0UGFyZW50ID0gaXNJRSgxMCkgPyBkb2N1bWVudC5ib2R5IDogbnVsbDtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgbnVsbDtcbiAgLy8gU2tpcCBoaWRkZW4gZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhbiBvZmZzZXRQYXJlbnRcbiAgd2hpbGUgKG9mZnNldFBhcmVudCA9PT0gbm9PZmZzZXRQYXJlbnQgJiYgZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSAoZWxlbWVudCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5vZmZzZXRQYXJlbnQ7XG4gIH1cblxuICB2YXIgbm9kZU5hbWUgPSBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50Lm5vZGVOYW1lO1xuXG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBUSCwgVEQgb3IgVEFCTEUgaW4gY2FzZVxuICAvLyBubyBvZmZzZXRQYXJlbnQgaXMgcHJlc2VudCwgSSBoYXRlIHRoaXMgam9iLi4uXG4gIGlmIChbJ1RIJywgJ1REJywgJ1RBQkxFJ10uaW5kZXhPZihvZmZzZXRQYXJlbnQubm9kZU5hbWUpICE9PSAtMSAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50O1xufVxuXG5mdW5jdGlvbiBpc09mZnNldENvbnRhaW5lcihlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnSFRNTCcgfHwgZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBlbGVtZW50O1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSByb290IG5vZGUgKGRvY3VtZW50LCBzaGFkb3dET00gcm9vdCkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0VsZW1lbnR9IHJvb3Qgbm9kZVxuICovXG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRSb290KG5vZGUucGFyZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgb2Zmc2V0IHBhcmVudCBjb21tb24gdG8gdGhlIHR3byBwcm92aWRlZCBub2Rlc1xuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MVxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MlxuICogQHJldHVybnMge0VsZW1lbnR9IGNvbW1vbiBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGVsZW1lbnQyKSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQxIHx8ICFlbGVtZW50MS5ub2RlVHlwZSB8fCAhZWxlbWVudDIgfHwgIWVsZW1lbnQyLm5vZGVUeXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIEhlcmUgd2UgbWFrZSBzdXJlIHRvIGdpdmUgYXMgXCJzdGFydFwiIHRoZSBlbGVtZW50IHRoYXQgY29tZXMgZmlyc3QgaW4gdGhlIERPTVxuICB2YXIgb3JkZXIgPSBlbGVtZW50MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50MikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgdmFyIHN0YXJ0ID0gb3JkZXIgPyBlbGVtZW50MSA6IGVsZW1lbnQyO1xuICB2YXIgZW5kID0gb3JkZXIgPyBlbGVtZW50MiA6IGVsZW1lbnQxO1xuXG4gIC8vIEdldCBjb21tb24gYW5jZXN0b3IgY29udGFpbmVyXG4gIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIHJhbmdlLnNldFN0YXJ0KHN0YXJ0LCAwKTtcbiAgcmFuZ2Uuc2V0RW5kKGVuZCwgMCk7XG4gIHZhciBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gIC8vIEJvdGggbm9kZXMgYXJlIGluc2lkZSAjZG9jdW1lbnRcblxuICBpZiAoZWxlbWVudDEgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyICYmIGVsZW1lbnQyICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciB8fCBzdGFydC5jb250YWlucyhlbmQpKSB7XG4gICAgaWYgKGlzT2Zmc2V0Q29udGFpbmVyKGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICB9XG5cbiAgLy8gb25lIG9mIHRoZSBub2RlcyBpcyBpbnNpZGUgc2hhZG93RE9NLCBmaW5kIHdoaWNoIG9uZVxuICB2YXIgZWxlbWVudDFyb290ID0gZ2V0Um9vdChlbGVtZW50MSk7XG4gIGlmIChlbGVtZW50MXJvb3QuaG9zdCkge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxcm9vdC5ob3N0LCBlbGVtZW50Mik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGdldFJvb3QoZWxlbWVudDIpLmhvc3QpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50IGluIHRoZSBnaXZlbiBzaWRlICh0b3AgYW5kIGxlZnQpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzaWRlIGB0b3BgIG9yIGBsZWZ0YFxuICogQHJldHVybnMge251bWJlcn0gYW1vdW50IG9mIHNjcm9sbGVkIHBpeGVsc1xuICovXG5mdW5jdGlvbiBnZXRTY3JvbGwoZWxlbWVudCkge1xuICB2YXIgc2lkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3RvcCc7XG5cbiAgdmFyIHVwcGVyU2lkZSA9IHNpZGUgPT09ICd0b3AnID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGh0bWw7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnRbdXBwZXJTaWRlXTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50W3VwcGVyU2lkZV07XG59XG5cbi8qXG4gKiBTdW0gb3Igc3VidHJhY3QgdGhlIGVsZW1lbnQgc2Nyb2xsIHZhbHVlcyAobGVmdCBhbmQgdG9wKSBmcm9tIGEgZ2l2ZW4gcmVjdCBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IC0gUmVjdCBvYmplY3QgeW91IHdhbnQgdG8gY2hhbmdlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgZnJvbSB0aGUgZnVuY3Rpb24gcmVhZHMgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VidHJhY3QgLSBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBzdWJ0cmFjdCB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHJldHVybiB7T2JqZWN0fSByZWN0IC0gVGhlIG1vZGlmaWVyIHJlY3Qgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVTY3JvbGwocmVjdCwgZWxlbWVudCkge1xuICB2YXIgc3VidHJhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICB2YXIgbW9kaWZpZXIgPSBzdWJ0cmFjdCA/IC0xIDogMTtcbiAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbi8qXG4gKiBIZWxwZXIgdG8gZGV0ZWN0IGJvcmRlcnMgb2YgYSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xuICogUmVzdWx0IG9mIGBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHlgIG9uIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYXhpcyAtIGB4YCBvciBgeWBcbiAqIEByZXR1cm4ge251bWJlcn0gYm9yZGVycyAtIFRoZSBib3JkZXJzIHNpemUgb2YgdGhlIGdpdmVuIGF4aXNcbiAqL1xuXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsIGF4aXMpIHtcbiAgdmFyIHNpZGVBID0gYXhpcyA9PT0gJ3gnID8gJ0xlZnQnIDogJ1RvcCc7XG4gIHZhciBzaWRlQiA9IHNpZGVBID09PSAnTGVmdCcgPyAnUmlnaHQnIDogJ0JvdHRvbSc7XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUEgKyAnV2lkdGgnXSkgKyBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVCICsgJ1dpZHRoJ10pO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplKGF4aXMsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGJvZHlbJ29mZnNldCcgKyBheGlzXSwgYm9keVsnc2Nyb2xsJyArIGF4aXNdLCBodG1sWydjbGllbnQnICsgYXhpc10sIGh0bWxbJ29mZnNldCcgKyBheGlzXSwgaHRtbFsnc2Nyb2xsJyArIGF4aXNdLCBpc0lFKDEwKSA/IHBhcnNlSW50KGh0bWxbJ29mZnNldCcgKyBheGlzXSkgKyBwYXJzZUludChjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ1RvcCcgOiAnTGVmdCcpXSkgKyBwYXJzZUludChjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ0JvdHRvbScgOiAnUmlnaHQnKV0pIDogMCk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1NpemVzKGRvY3VtZW50KSB7XG4gIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgdmFyIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gaXNJRSgxMCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShodG1sKTtcblxuICByZXR1cm4ge1xuICAgIGhlaWdodDogZ2V0U2l6ZSgnSGVpZ2h0JywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSksXG4gICAgd2lkdGg6IGdldFNpemUoJ1dpZHRoJywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSlcbiAgfTtcbn1cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdpdmVuIGVsZW1lbnQgb2Zmc2V0cywgZ2VuZXJhdGUgYW4gb3V0cHV0IHNpbWlsYXIgdG8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gb2Zmc2V0c1xuICogQHJldHVybnMge09iamVjdH0gQ2xpZW50UmVjdCBsaWtlIG91dHB1dFxuICovXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0KG9mZnNldHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBvZmZzZXRzLCB7XG4gICAgcmlnaHQ6IG9mZnNldHMubGVmdCArIG9mZnNldHMud2lkdGgsXG4gICAgYm90dG9tOiBvZmZzZXRzLnRvcCArIG9mZnNldHMuaGVpZ2h0XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBib3VuZGluZyBjbGllbnQgcmVjdCBvZiBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9IGNsaWVudCByZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0ge307XG5cbiAgLy8gSUUxMCAxMCBGSVg6IFBsZWFzZSwgZG9uJ3QgYXNrLCB0aGUgZWxlbWVudCBpc24ndFxuICAvLyBjb25zaWRlcmVkIGluIERPTSBpbiBzb21lIGNpcmN1bXN0YW5jZXMuLi5cbiAgLy8gVGhpcyBpc24ndCByZXByb2R1Y2libGUgaW4gSUUxMCBjb21wYXRpYmlsaXR5IG1vZGUgb2YgSUUxMVxuICB0cnkge1xuICAgIGlmIChpc0lFKDEwKSkge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gICAgICByZWN0LnRvcCArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdDtcbiAgICAgIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gIH07XG5cbiAgLy8gc3VidHJhY3Qgc2Nyb2xsYmFyIHNpemUgZnJvbSBzaXplc1xuICB2YXIgc2l6ZXMgPSBlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcgPyBnZXRXaW5kb3dTaXplcyhlbGVtZW50Lm93bmVyRG9jdW1lbnQpIDoge307XG4gIHZhciB3aWR0aCA9IHNpemVzLndpZHRoIHx8IGVsZW1lbnQuY2xpZW50V2lkdGggfHwgcmVzdWx0LndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gc2l6ZXMuaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IHJlc3VsdC5oZWlnaHQ7XG5cbiAgdmFyIGhvcml6U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIHdpZHRoO1xuICB2YXIgdmVydFNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gaGVpZ2h0O1xuXG4gIC8vIGlmIGFuIGh5cG90aGV0aWNhbCBzY3JvbGxiYXIgaXMgZGV0ZWN0ZWQsIHdlIG11c3QgYmUgc3VyZSBpdCdzIG5vdCBhIGBib3JkZXJgXG4gIC8vIHdlIG1ha2UgdGhpcyBjaGVjayBjb25kaXRpb25hbCBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICBpZiAoaG9yaXpTY3JvbGxiYXIgfHwgdmVydFNjcm9sbGJhcikge1xuICAgIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCk7XG4gICAgaG9yaXpTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneCcpO1xuICAgIHZlcnRTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneScpO1xuXG4gICAgcmVzdWx0LndpZHRoIC09IGhvcml6U2Nyb2xsYmFyO1xuICAgIHJlc3VsdC5oZWlnaHQgLT0gdmVydFNjcm9sbGJhcjtcbiAgfVxuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShjaGlsZHJlbiwgcGFyZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICB2YXIgaXNJRTEwID0gaXNJRSgxMCk7XG4gIHZhciBpc0hUTUwgPSBwYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJztcbiAgdmFyIGNoaWxkcmVuUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChjaGlsZHJlbik7XG4gIHZhciBwYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHBhcmVudCk7XG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoY2hpbGRyZW4pO1xuXG4gIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkocGFyZW50KTtcbiAgdmFyIGJvcmRlclRvcFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyVG9wV2lkdGgpO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKTtcblxuICAvLyBJbiBjYXNlcyB3aGVyZSB0aGUgcGFyZW50IGlzIGZpeGVkLCB3ZSBtdXN0IGlnbm9yZSBuZWdhdGl2ZSBzY3JvbGwgaW4gb2Zmc2V0IGNhbGNcbiAgaWYgKGZpeGVkUG9zaXRpb24gJiYgaXNIVE1MKSB7XG4gICAgcGFyZW50UmVjdC50b3AgPSBNYXRoLm1heChwYXJlbnRSZWN0LnRvcCwgMCk7XG4gICAgcGFyZW50UmVjdC5sZWZ0ID0gTWF0aC5tYXgocGFyZW50UmVjdC5sZWZ0LCAwKTtcbiAgfVxuICB2YXIgb2Zmc2V0cyA9IGdldENsaWVudFJlY3Qoe1xuICAgIHRvcDogY2hpbGRyZW5SZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wIC0gYm9yZGVyVG9wV2lkdGgsXG4gICAgbGVmdDogY2hpbGRyZW5SZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQgLSBib3JkZXJMZWZ0V2lkdGgsXG4gICAgd2lkdGg6IGNoaWxkcmVuUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IGNoaWxkcmVuUmVjdC5oZWlnaHRcbiAgfSk7XG4gIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gMDtcblxuICAvLyBTdWJ0cmFjdCBtYXJnaW5zIG9mIGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGl0J3MgYmVpbmcgdXNlZCBhcyBwYXJlbnRcbiAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gIC8vIHRoZSBib3ggb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgaW4gdGhlIG90aGVyIGNhc2VzIG5vdC5cbiAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCk7XG4gICAgdmFyIG1hcmdpbkxlZnQgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0KTtcblxuICAgIG9mZnNldHMudG9wIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMuYm90dG9tIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubGVmdCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuICAgIG9mZnNldHMucmlnaHQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcblxuICAgIC8vIEF0dGFjaCBtYXJnaW5Ub3AgYW5kIG1hcmdpbkxlZnQgYmVjYXVzZSBpbiBzb21lIGNpcmN1bXN0YW5jZXMgd2UgbWF5IG5lZWQgdGhlbVxuICAgIG9mZnNldHMubWFyZ2luVG9wID0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubWFyZ2luTGVmdCA9IG1hcmdpbkxlZnQ7XG4gIH1cblxuICBpZiAoaXNJRTEwICYmICFmaXhlZFBvc2l0aW9uID8gcGFyZW50LmNvbnRhaW5zKHNjcm9sbFBhcmVudCkgOiBwYXJlbnQgPT09IHNjcm9sbFBhcmVudCAmJiBzY3JvbGxQYXJlbnQubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgIG9mZnNldHMgPSBpbmNsdWRlU2Nyb2xsKG9mZnNldHMsIHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKGVsZW1lbnQpIHtcbiAgdmFyIGV4Y2x1ZGVTY3JvbGwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGVsZW1lbnQsIGh0bWwpO1xuICB2YXIgd2lkdGggPSBNYXRoLm1heChodG1sLmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGh0bWwuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG5cbiAgdmFyIHNjcm9sbFRvcCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwpIDogMDtcbiAgdmFyIHNjcm9sbExlZnQgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sLCAnbGVmdCcpIDogMDtcblxuICB2YXIgb2Zmc2V0ID0ge1xuICAgIHRvcDogc2Nyb2xsVG9wIC0gcmVsYXRpdmVPZmZzZXQudG9wICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luVG9wLFxuICAgIGxlZnQ6IHNjcm9sbExlZnQgLSByZWxhdGl2ZU9mZnNldC5sZWZ0ICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luTGVmdCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChvZmZzZXQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGZpeGVkIG9yIGlzIGluc2lkZSBhIGZpeGVkIHBhcmVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGN1c3RvbUNvbnRhaW5lclxuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0byBcImlzRml4ZWQ/XCJcbiAqL1xuZnVuY3Rpb24gaXNGaXhlZChlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkKHBhcmVudE5vZGUpO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBwYXJlbnQgb2YgYW4gZWxlbWVudCB0aGF0IGhhcyBhIHRyYW5zZm9ybWVkIHByb3BlcnR5IGRlZmluZWRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IGZpcnN0IHRyYW5zZm9ybWVkIHBhcmVudCBvciBkb2N1bWVudEVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnRFbGVtZW50IHx8IGlzSUUoKSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cbiAgdmFyIGVsID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICB3aGlsZSAoZWwgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsLCAndHJhbnNmb3JtJykgPT09ICdub25lJykge1xuICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWwgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xufVxuXG4vKipcbiAqIENvbXB1dGVkIHRoZSBib3VuZGFyaWVzIGxpbWl0cyBhbmQgcmV0dXJuIHRoZW1cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQgLSBFbGVtZW50IHVzZWQgdG8gZGVmaW5lIHRoZSBib3VuZGFyaWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZpeGVkUG9zaXRpb24gLSBJcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgYm91bmRhcmllc1xuICovXG5mdW5jdGlvbiBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcblxuICB2YXIgYm91bmRhcmllcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSk7XG5cbiAgLy8gSGFuZGxlIHZpZXdwb3J0IGNhc2VcbiAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgYm91bmRhcmllcyA9IGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIEhhbmRsZSBvdGhlciBjYXNlcyBiYXNlZCBvbiBET00gZWxlbWVudCB1c2VkIGFzIGJvdW5kYXJpZXNcbiAgICB2YXIgYm91bmRhcmllc05vZGUgPSB2b2lkIDA7XG4gICAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShyZWZlcmVuY2UpKTtcbiAgICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd3aW5kb3cnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBib3VuZGFyaWVzRWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0cyA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShib3VuZGFyaWVzTm9kZSwgb2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcblxuICAgIC8vIEluIGNhc2Ugb2YgSFRNTCwgd2UgbmVlZCBhIGRpZmZlcmVudCBjb21wdXRhdGlvblxuICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnICYmICFpc0ZpeGVkKG9mZnNldFBhcmVudCkpIHtcbiAgICAgIHZhciBfZ2V0V2luZG93U2l6ZXMgPSBnZXRXaW5kb3dTaXplcyhwb3BwZXIub3duZXJEb2N1bWVudCksXG4gICAgICAgICAgaGVpZ2h0ID0gX2dldFdpbmRvd1NpemVzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcblxuICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gaGVpZ2h0ICsgb2Zmc2V0cy50b3A7XG4gICAgICBib3VuZGFyaWVzLmxlZnQgKz0gb2Zmc2V0cy5sZWZ0IC0gb2Zmc2V0cy5tYXJnaW5MZWZ0O1xuICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgYWxsIHRoZSBvdGhlciBET00gZWxlbWVudHMsIHRoaXMgb25lIGlzIGdvb2RcbiAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nc1xuICBwYWRkaW5nID0gcGFkZGluZyB8fCAwO1xuICB2YXIgaXNQYWRkaW5nTnVtYmVyID0gdHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInO1xuICBib3VuZGFyaWVzLmxlZnQgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcubGVmdCB8fCAwO1xuICBib3VuZGFyaWVzLnRvcCArPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy50b3AgfHwgMDtcbiAgYm91bmRhcmllcy5yaWdodCAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5yaWdodCB8fCAwO1xuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5ib3R0b20gfHwgMDtcblxuICByZXR1cm4gYm91bmRhcmllcztcbn1cblxuZnVuY3Rpb24gZ2V0QXJlYShfcmVmKSB7XG4gIHZhciB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodDtcblxuICByZXR1cm4gd2lkdGggKiBoZWlnaHQ7XG59XG5cbi8qKlxuICogVXRpbGl0eSB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgYGF1dG9gIHBsYWNlbWVudCB0byB0aGUgcGxhY2VtZW50IHdpdGggbW9yZVxuICogYXZhaWxhYmxlIHNwYWNlLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQocGxhY2VtZW50LCByZWZSZWN0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG5cbiAgaWYgKHBsYWNlbWVudC5pbmRleE9mKCdhdXRvJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpO1xuXG4gIHZhciByZWN0cyA9IHtcbiAgICB0b3A6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWZSZWN0LnRvcCAtIGJvdW5kYXJpZXMudG9wXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMucmlnaHQgLSByZWZSZWN0LnJpZ2h0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5ib3R0b20gLSByZWZSZWN0LmJvdHRvbVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgd2lkdGg6IHJlZlJlY3QubGVmdCAtIGJvdW5kYXJpZXMubGVmdCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNvcnRlZEFyZWFzID0gT2JqZWN0LmtleXMocmVjdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleToga2V5XG4gICAgfSwgcmVjdHNba2V5XSwge1xuICAgICAgYXJlYTogZ2V0QXJlYShyZWN0c1trZXldKVxuICAgIH0pO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuYXJlYSAtIGEuYXJlYTtcbiAgfSk7XG5cbiAgdmFyIGZpbHRlcmVkQXJlYXMgPSBzb3J0ZWRBcmVhcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodDtcbiAgICByZXR1cm4gd2lkdGggPj0gcG9wcGVyLmNsaWVudFdpZHRoICYmIGhlaWdodCA+PSBwb3BwZXIuY2xpZW50SGVpZ2h0O1xuICB9KTtcblxuICB2YXIgY29tcHV0ZWRQbGFjZW1lbnQgPSBmaWx0ZXJlZEFyZWFzLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZEFyZWFzWzBdLmtleSA6IHNvcnRlZEFyZWFzWzBdLmtleTtcblxuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgcmV0dXJuIGNvbXB1dGVkUGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7RWxlbWVudH0gZml4ZWRQb3NpdGlvbiAtIGlzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlKSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHZhciBjb21tb25PZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSk7XG4gIHJldHVybiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUocmVmZXJlbmNlLCBjb21tb25PZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3V0ZXIgc2l6ZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQgKG9mZnNldCBzaXplICsgbWFyZ2lucylcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVyU2l6ZXMoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wIHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luQm90dG9tIHx8IDApO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCB8fCAwKTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksXG4gICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCArIHhcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudFxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgdmFyIGhhc2ggPSB7IGxlZnQ6ICdyaWdodCcsIHJpZ2h0OiAnbGVmdCcsIGJvdHRvbTogJ3RvcCcsIHRvcDogJ2JvdHRvbScgfTtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0gQ1NTIHBvc2l0aW9uIHRoZSBQb3BwZXIgd2lsbCBnZXQgYXBwbGllZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0cyAtIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhY2VtZW50IC0gb25lIG9mIHRoZSB2YWxpZCBwbGFjZW1lbnQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gcG9wcGVyT2Zmc2V0cyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFBvcHBlck9mZnNldHMocG9wcGVyLCByZWZlcmVuY2VPZmZzZXRzLCBwbGFjZW1lbnQpIHtcbiAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgLy8gR2V0IHBvcHBlciBub2RlIHNpemVzXG4gIHZhciBwb3BwZXJSZWN0ID0gZ2V0T3V0ZXJTaXplcyhwb3BwZXIpO1xuXG4gIC8vIEFkZCBwb3NpdGlvbiwgd2lkdGggYW5kIGhlaWdodCB0byBvdXIgb2Zmc2V0cyBvYmplY3RcbiAgdmFyIHBvcHBlck9mZnNldHMgPSB7XG4gICAgd2lkdGg6IHBvcHBlclJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBwb3BwZXJSZWN0LmhlaWdodFxuICB9O1xuXG4gIC8vIGRlcGVuZGluZyBieSB0aGUgcG9wcGVyIHBsYWNlbWVudCB3ZSBoYXZlIHRvIGNvbXB1dGUgaXRzIG9mZnNldHMgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgdmFyIGlzSG9yaXogPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgbWFpblNpZGUgPSBpc0hvcml6ID8gJ3RvcCcgOiAnbGVmdCc7XG4gIHZhciBzZWNvbmRhcnlTaWRlID0gaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2Vjb25kYXJ5TWVhc3VyZW1lbnQgPSAhaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBwb3BwZXJPZmZzZXRzW21haW5TaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbbWFpblNpZGVdICsgcmVmZXJlbmNlT2Zmc2V0c1ttZWFzdXJlbWVudF0gLyAyIC0gcG9wcGVyUmVjdFttZWFzdXJlbWVudF0gLyAyO1xuICBpZiAocGxhY2VtZW50ID09PSBzZWNvbmRhcnlTaWRlKSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gLSBwb3BwZXJSZWN0W3NlY29uZGFyeU1lYXN1cmVtZW50XTtcbiAgfSBlbHNlIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tnZXRPcHBvc2l0ZVBsYWNlbWVudChzZWNvbmRhcnlTaWRlKV07XG4gIH1cblxuICByZXR1cm4gcG9wcGVyT2Zmc2V0cztcbn1cblxuLyoqXG4gKiBNaW1pY3MgdGhlIGBmaW5kYCBtZXRob2Qgb2YgQXJyYXlcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZChhcnIsIGNoZWNrKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgcmV0dXJuIGFyci5maW5kKGNoZWNrKTtcbiAgfVxuXG4gIC8vIHVzZSBgZmlsdGVyYCB0byBvYnRhaW4gdGhlIHNhbWUgYmVoYXZpb3Igb2YgYGZpbmRgXG4gIHJldHVybiBhcnIuZmlsdGVyKGNoZWNrKVswXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBtYXRjaGluZyBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFyciwgcHJvcCwgdmFsdWUpIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kSW5kZXggaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoZnVuY3Rpb24gKGN1cikge1xuICAgICAgcmV0dXJuIGN1cltwcm9wXSA9PT0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvLyB1c2UgYGZpbmRgICsgYGluZGV4T2ZgIGlmIGBmaW5kSW5kZXhgIGlzbid0IHN1cHBvcnRlZFxuICB2YXIgbWF0Y2ggPSBmaW5kKGFyciwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmpbcHJvcF0gPT09IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGFyci5pbmRleE9mKG1hdGNoKTtcbn1cblxuLyoqXG4gKiBMb29wIHRyb3VnaCB0aGUgbGlzdCBvZiBtb2RpZmllcnMgYW5kIHJ1biB0aGVtIGluIG9yZGVyLFxuICogZWFjaCBvZiB0aGVtIHdpbGwgdGhlbiBlZGl0IHRoZSBkYXRhIG9iamVjdC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5kcyAtIE9wdGlvbmFsIG1vZGlmaWVyIG5hbWUgdXNlZCBhcyBzdG9wcGVyXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH1cbiAqL1xuZnVuY3Rpb24gcnVuTW9kaWZpZXJzKG1vZGlmaWVycywgZGF0YSwgZW5kcykge1xuICB2YXIgbW9kaWZpZXJzVG9SdW4gPSBlbmRzID09PSB1bmRlZmluZWQgPyBtb2RpZmllcnMgOiBtb2RpZmllcnMuc2xpY2UoMCwgZmluZEluZGV4KG1vZGlmaWVycywgJ25hbWUnLCBlbmRzKSk7XG5cbiAgbW9kaWZpZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAobW9kaWZpZXJbJ2Z1bmN0aW9uJ10pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICBjb25zb2xlLndhcm4oJ2Btb2RpZmllci5mdW5jdGlvbmAgaXMgZGVwcmVjYXRlZCwgdXNlIGBtb2RpZmllci5mbmAhJyk7XG4gICAgfVxuICAgIHZhciBmbiA9IG1vZGlmaWVyWydmdW5jdGlvbiddIHx8IG1vZGlmaWVyLmZuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIGlmIChtb2RpZmllci5lbmFibGVkICYmIGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICAvLyBBZGQgcHJvcGVydGllcyB0byBvZmZzZXRzIHRvIG1ha2UgdGhlbSBhIGNvbXBsZXRlIGNsaWVudFJlY3Qgb2JqZWN0XG4gICAgICAvLyB3ZSBkbyB0aGlzIGJlZm9yZSBlYWNoIG1vZGlmaWVyIHRvIG1ha2Ugc3VyZSB0aGUgcHJldmlvdXMgb25lIGRvZXNuJ3RcbiAgICAgIC8vIG1lc3Mgd2l0aCB0aGVzZSB2YWx1ZXNcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuICAgICAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSk7XG5cbiAgICAgIGRhdGEgPSBmbihkYXRhLCBtb2RpZmllcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLCBjb21wdXRpbmcgdGhlIG5ldyBvZmZzZXRzIGFuZCBhcHBseWluZ1xuICogdGhlIG5ldyBzdHlsZS48YnIgLz5cbiAqIFByZWZlciBgc2NoZWR1bGVVcGRhdGVgIG92ZXIgYHVwZGF0ZWAgYmVjYXVzZSBvZiBwZXJmb3JtYW5jZSByZWFzb25zLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiB1cGRhdGUoKSB7XG4gIC8vIGlmIHBvcHBlciBpcyBkZXN0cm95ZWQsIGRvbid0IHBlcmZvcm0gYW55IGZ1cnRoZXIgdXBkYXRlXG4gIGlmICh0aGlzLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRhdGEgPSB7XG4gICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgc3R5bGVzOiB7fSxcbiAgICBhcnJvd1N0eWxlczoge30sXG4gICAgYXR0cmlidXRlczoge30sXG4gICAgZmxpcHBlZDogZmFsc2UsXG4gICAgb2Zmc2V0czoge31cbiAgfTtcblxuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZU9mZnNldHModGhpcy5zdGF0ZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIGRhdGEucGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQodGhpcy5vcHRpb25zLnBsYWNlbWVudCwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICAvLyBzdG9yZSB0aGUgY29tcHV0ZWQgcGxhY2VtZW50IGluc2lkZSBgb3JpZ2luYWxQbGFjZW1lbnRgXG4gIGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcblxuICBkYXRhLnBvc2l0aW9uRml4ZWQgPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZDtcblxuICAvLyBjb21wdXRlIHRoZSBwb3BwZXIgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0UG9wcGVyT2Zmc2V0cyh0aGlzLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIucG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnO1xuXG4gIC8vIHJ1biB0aGUgbW9kaWZpZXJzXG4gIGRhdGEgPSBydW5Nb2RpZmllcnModGhpcy5tb2RpZmllcnMsIGRhdGEpO1xuXG4gIC8vIHRoZSBmaXJzdCBgdXBkYXRlYCB3aWxsIGNhbGwgYG9uQ3JlYXRlYCBjYWxsYmFja1xuICAvLyB0aGUgb3RoZXIgb25lcyB3aWxsIGNhbGwgYG9uVXBkYXRlYCBjYWxsYmFja1xuICBpZiAoIXRoaXMuc3RhdGUuaXNDcmVhdGVkKSB7XG4gICAgdGhpcy5zdGF0ZS5pc0NyZWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy5vbkNyZWF0ZShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUoZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBpcyBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJFbmFibGVkKG1vZGlmaWVycywgbW9kaWZpZXJOYW1lKSB7XG4gIHJldHVybiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICBlbmFibGVkID0gX3JlZi5lbmFibGVkO1xuICAgIHJldHVybiBlbmFibGVkICYmIG5hbWUgPT09IG1vZGlmaWVyTmFtZTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmVmaXhlZCBzdXBwb3J0ZWQgcHJvcGVydHkgbmFtZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5IChjYW1lbENhc2UpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBwcmVmaXhlZCBwcm9wZXJ0eSAoY2FtZWxDYXNlIG9yIFBhc2NhbENhc2UsIGRlcGVuZGluZyBvbiB0aGUgdmVuZG9yIHByZWZpeClcbiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXhlcyA9IFtmYWxzZSwgJ21zJywgJ1dlYmtpdCcsICdNb3onLCAnTyddO1xuICB2YXIgdXBwZXJQcm9wID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgIHZhciB0b0NoZWNrID0gcHJlZml4ID8gJycgKyBwcmVmaXggKyB1cHBlclByb3AgOiBwcm9wZXJ0eTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGVbdG9DaGVja10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdG9DaGVjaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIHBvcHBlci5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXRseSBhc2tlZCBmb3IgdGhlIGRlbGV0aW9uIG9uIGRlc3Ryb3lcbiAgLy8gZG8gbm90IHVzZSBgcmVtb3ZlYCBiZWNhdXNlIElFMTEgZG9lc24ndCBzdXBwb3J0IGl0XG4gIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlT25EZXN0cm95KSB7XG4gICAgdGhpcy5wb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHBlcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogR2V0IHRoZSB3aW5kb3cgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyhlbGVtZW50KSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxQYXJlbnQsIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cykge1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50Lm5vZGVOYW1lID09PSAnQk9EWSc7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBzY3JvbGxQYXJlbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHNjcm9sbFBhcmVudDtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgaWYgKCFpc0JvZHkpIHtcbiAgICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoZ2V0U2Nyb2xsUGFyZW50KHRhcmdldC5wYXJlbnROb2RlKSwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKTtcbiAgfVxuICBzY3JvbGxQYXJlbnRzLnB1c2godGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBTZXR1cCBuZWVkZWQgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBvcHRpb25zLCBzdGF0ZSwgdXBkYXRlQm91bmQpIHtcbiAgLy8gUmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBzdGF0ZS51cGRhdGVCb3VuZCA9IHVwZGF0ZUJvdW5kO1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIC8vIFNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICB2YXIgc2Nyb2xsRWxlbWVudCA9IGdldFNjcm9sbFBhcmVudChyZWZlcmVuY2UpO1xuICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsRWxlbWVudCwgJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kLCBzdGF0ZS5zY3JvbGxQYXJlbnRzKTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IHNjcm9sbEVsZW1lbnQ7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSB0cnVlO1xuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIGFkZCByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgc3RhcnQgcmVjYWxjdWxhdGluZ1xuICogcG9zaXRpb24gb2YgdGhlIHBvcHBlciBlbGVtZW50IHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKCF0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICB0aGlzLnN0YXRlID0gc2V0dXBFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLCB0aGlzLnN0YXRlLCB0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBzdGF0ZSkge1xuICAvLyBSZW1vdmUgcmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG5cbiAgLy8gUmVtb3ZlIHNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG4gIH0pO1xuXG4gIC8vIFJlc2V0IHN0YXRlXG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gbnVsbDtcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IFtdO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGZhbHNlO1xuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCByZW1vdmUgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHdvbid0IHJlY2FsY3VsYXRlIHBvcHBlciBwb3NpdGlvblxuICogd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuIEl0IGFsc28gd29uJ3QgdHJpZ2dlciBgb25VcGRhdGVgIGNhbGxiYWNrIGFueW1vcmUsXG4gKiB1bmxlc3MgeW91IGNhbGwgYHVwZGF0ZWAgbWV0aG9kIG1hbnVhbGx5LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgICB0aGlzLnN0YXRlID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMuc3RhdGUpO1xuICB9XG59XG5cbi8qKlxuICogVGVsbHMgaWYgYSBnaXZlbiBpbnB1dCBpcyBhIG51bWJlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHsqfSBpbnB1dCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuIG4gIT09ICcnICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHN0eWxlIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB1bml0ID0gJyc7XG4gICAgLy8gYWRkIHVuaXQgaWYgdGhlIHZhbHVlIGlzIG51bWVyaWMgYW5kIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAgaWYgKFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLmluZGV4T2YocHJvcCkgIT09IC0xICYmIGlzTnVtZXJpYyhzdHlsZXNbcHJvcF0pKSB7XG4gICAgICB1bml0ID0gJ3B4JztcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXSArIHVuaXQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGVzIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5zdHlsZXMgLSBMaXN0IG9mIHN0eWxlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLmF0dHJpYnV0ZXMgLSBMaXN0IG9mIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2FtZSBkYXRhIG9iamVjdFxuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlKGRhdGEpIHtcbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuc3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gaW4gdGhpcyB3YXkgd2UgY2FuIG1ha2UgdGhlIDNyZCBwYXJ0eSBtb2RpZmllcnMgYWRkIGN1c3RvbSBzdHlsZXMgdG8gaXRcbiAgLy8gQmUgYXdhcmUsIG1vZGlmaWVycyBjb3VsZCBvdmVycmlkZSB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoZSBwcmV2aW91c1xuICAvLyBsaW5lcyBvZiB0aGlzIG1vZGlmaWVyIVxuICBzZXRTdHlsZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuc3R5bGVzKTtcblxuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5hdHRyaWJ1dGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gdGhleSB3aWxsIGJlIHNldCBhcyBIVE1MIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgc2V0QXR0cmlidXRlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgZGVmaW5lZCBhbmQgYXJyb3dTdHlsZXMgaGFzIHNvbWUgcHJvcGVydGllc1xuICBpZiAoZGF0YS5hcnJvd0VsZW1lbnQgJiYgT2JqZWN0LmtleXMoZGF0YS5hcnJvd1N0eWxlcykubGVuZ3RoKSB7XG4gICAgc2V0U3R5bGVzKGRhdGEuYXJyb3dFbGVtZW50LCBkYXRhLmFycm93U3R5bGVzKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gKiB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyIG1hcmdpbnMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBnZXQgdGhlXG4gKiBjb3JyZWN0IHBvcHBlciBvZmZzZXRzLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUG9wcGVyLmpzIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZU9uTG9hZChyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBzdGF0ZSkge1xuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgdmFyIHJlZmVyZW5jZU9mZnNldHMgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgdmFyIHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KG9wdGlvbnMucGxhY2VtZW50LCByZWZlcmVuY2VPZmZzZXRzLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHBsYWNlbWVudCk7XG5cbiAgLy8gQXBwbHkgYHBvc2l0aW9uYCB0byBwb3BwZXIgYmVmb3JlIGFueXRoaW5nIGVsc2UgYmVjYXVzZVxuICAvLyB3aXRob3V0IHRoZSBwb3NpdGlvbiBhcHBsaWVkIHdlIGNhbid0IGd1YXJhbnRlZSBjb3JyZWN0IGNvbXB1dGF0aW9uc1xuICBzZXRTdHlsZXMocG9wcGVyLCB7IHBvc2l0aW9uOiBvcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJyB9KTtcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gc2hvdWxkUm91bmQgLSBJZiB0aGUgb2Zmc2V0cyBzaG91bGQgYmUgcm91bmRlZCBhdCBhbGxcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwb3BwZXIncyBwb3NpdGlvbiBvZmZzZXRzIHJvdW5kZWRcbiAqXG4gKiBUaGUgdGFsZSBvZiBwaXhlbC1wZXJmZWN0IHBvc2l0aW9uaW5nLiBJdCdzIHN0aWxsIG5vdCAxMDAlIHBlcmZlY3QsIGJ1dCBhc1xuICogZ29vZCBhcyBpdCBjYW4gYmUgd2l0aGluIHJlYXNvbi5cbiAqIERpc2N1c3Npb24gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvcHVsbC83MTVcbiAqXG4gKiBMb3cgRFBJIHNjcmVlbnMgY2F1c2UgYSBwb3BwZXIgdG8gYmUgYmx1cnJ5IGlmIG5vdCB1c2luZyBmdWxsIHBpeGVscyAoU2FmYXJpXG4gKiBhcyB3ZWxsIG9uIEhpZ2ggRFBJIHNjcmVlbnMpLlxuICpcbiAqIEZpcmVmb3ggcHJlZmVycyBubyByb3VuZGluZyBmb3IgcG9zaXRpb25pbmcgYW5kIGRvZXMgbm90IGhhdmUgYmx1cnJpbmVzcyBvblxuICogaGlnaCBEUEkgc2NyZWVucy5cbiAqXG4gKiBPbmx5IGhvcml6b250YWwgcGxhY2VtZW50IGFuZCBsZWZ0L3JpZ2h0IHZhbHVlcyBuZWVkIHRvIGJlIGNvbnNpZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFJvdW5kZWRPZmZzZXRzKGRhdGEsIHNob3VsZFJvdW5kKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICAgIGZsb29yID0gTWF0aC5mbG9vcjtcblxuICB2YXIgbm9Sb3VuZCA9IGZ1bmN0aW9uIG5vUm91bmQodikge1xuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIHZhciByZWZlcmVuY2VXaWR0aCA9IHJvdW5kKHJlZmVyZW5jZS53aWR0aCk7XG4gIHZhciBwb3BwZXJXaWR0aCA9IHJvdW5kKHBvcHBlci53aWR0aCk7XG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGRhdGEucGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBpc1ZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LmluZGV4T2YoJy0nKSAhPT0gLTE7XG4gIHZhciBzYW1lV2lkdGhQYXJpdHkgPSByZWZlcmVuY2VXaWR0aCAlIDIgPT09IHBvcHBlcldpZHRoICUgMjtcbiAgdmFyIGJvdGhPZGRXaWR0aCA9IHJlZmVyZW5jZVdpZHRoICUgMiA9PT0gMSAmJiBwb3BwZXJXaWR0aCAlIDIgPT09IDE7XG5cbiAgdmFyIGhvcml6b250YWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogaXNWZXJ0aWNhbCB8fCBpc1ZhcmlhdGlvbiB8fCBzYW1lV2lkdGhQYXJpdHkgPyByb3VuZCA6IGZsb29yO1xuICB2YXIgdmVydGljYWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogcm91bmQ7XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBob3Jpem9udGFsVG9JbnRlZ2VyKGJvdGhPZGRXaWR0aCAmJiAhaXNWYXJpYXRpb24gJiYgc2hvdWxkUm91bmQgPyBwb3BwZXIubGVmdCAtIDEgOiBwb3BwZXIubGVmdCksXG4gICAgdG9wOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIudG9wKSxcbiAgICBib3R0b206IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci5ib3R0b20pLFxuICAgIHJpZ2h0OiBob3Jpem9udGFsVG9JbnRlZ2VyKHBvcHBlci5yaWdodClcbiAgfTtcbn1cblxudmFyIGlzRmlyZWZveCA9IGlzQnJvd3NlciAmJiAvRmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciB4ID0gb3B0aW9ucy54LFxuICAgICAgeSA9IG9wdGlvbnMueTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVnYWN5IHN1cHBvcnQgaW4gUG9wcGVyLmpzIHYyXG5cbiAgdmFyIGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAnYXBwbHlTdHlsZSc7XG4gIH0pLmdwdUFjY2VsZXJhdGlvbjtcbiAgaWYgKGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgZ3B1QWNjZWxlcmF0aW9uYCBvcHRpb24gbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXIgYW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgUG9wcGVyLmpzIScpO1xuICB9XG4gIHZhciBncHVBY2NlbGVyYXRpb24gPSBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCA/IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA6IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uO1xuXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuXG4gIC8vIFN0eWxlc1xuICB2YXIgc3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBwb3BwZXIucG9zaXRpb25cbiAgfTtcblxuICB2YXIgb2Zmc2V0cyA9IGdldFJvdW5kZWRPZmZzZXRzKGRhdGEsIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDwgMiB8fCAhaXNGaXJlZm94KTtcblxuICB2YXIgc2lkZUEgPSB4ID09PSAnYm90dG9tJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gIHZhciBzaWRlQiA9IHkgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gIC8vIGlmIGdwdUFjY2VsZXJhdGlvbiBpcyBzZXQgdG8gYHRydWVgIGFuZCB0cmFuc2Zvcm0gaXMgc3VwcG9ydGVkLFxuICAvLyAgd2UgdXNlIGB0cmFuc2xhdGUzZGAgdG8gYXBwbHkgdGhlIHBvc2l0aW9uIHRvIHRoZSBwb3BwZXIgd2VcbiAgLy8gYXV0b21hdGljYWxseSB1c2UgdGhlIHN1cHBvcnRlZCBwcmVmaXhlZCB2ZXJzaW9uIGlmIG5lZWRlZFxuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG5cbiAgLy8gbm93LCBsZXQncyBtYWtlIGEgc3RlcCBiYWNrIGFuZCBsb29rIGF0IHRoaXMgY29kZSBjbG9zZWx5ICh3dGY/KVxuICAvLyBJZiB0aGUgY29udGVudCBvZiB0aGUgcG9wcGVyIGdyb3dzIG9uY2UgaXQncyBiZWVuIHBvc2l0aW9uZWQsIGl0XG4gIC8vIG1heSBoYXBwZW4gdGhhdCB0aGUgcG9wcGVyIGdldHMgbWlzcGxhY2VkIGJlY2F1c2Ugb2YgdGhlIG5ldyBjb250ZW50XG4gIC8vIG92ZXJmbG93aW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUbyBhdm9pZCB0aGlzIHByb2JsZW0sIHdlIHByb3ZpZGUgdHdvIG9wdGlvbnMgKHggYW5kIHkpLCB3aGljaCBhbGxvd1xuICAvLyB0aGUgY29uc3VtZXIgdG8gZGVmaW5lIHRoZSBvZmZzZXQgb3JpZ2luLlxuICAvLyBJZiB3ZSBwb3NpdGlvbiBhIHBvcHBlciBvbiB0b3Agb2YgYSByZWZlcmVuY2UgZWxlbWVudCwgd2UgY2FuIHNldFxuICAvLyBgeGAgdG8gYHRvcGAgdG8gbWFrZSB0aGUgcG9wcGVyIGdyb3cgdG93YXJkcyBpdHMgdG9wIGluc3RlYWQgb2ZcbiAgLy8gaXRzIGJvdHRvbS5cbiAgdmFyIGxlZnQgPSB2b2lkIDAsXG4gICAgICB0b3AgPSB2b2lkIDA7XG4gIGlmIChzaWRlQSA9PT0gJ2JvdHRvbScpIHtcbiAgICAvLyB3aGVuIG9mZnNldFBhcmVudCBpcyA8aHRtbD4gdGhlIHBvc2l0aW9uaW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiAoZXhjbHVkaW5nIHRoZSBzY3JvbGxiYXIpXG4gICAgLy8gYW5kIG5vdCB0aGUgYm90dG9tIG9mIHRoZSBodG1sIGVsZW1lbnRcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnRSZWN0LmhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBvZmZzZXRzLnRvcDtcbiAgfVxuICBpZiAoc2lkZUIgPT09ICdyaWdodCcpIHtcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnRSZWN0LndpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVmdCA9IG9mZnNldHMubGVmdDtcbiAgfVxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uICYmIHByZWZpeGVkUHJvcGVydHkpIHtcbiAgICBzdHlsZXNbcHJlZml4ZWRQcm9wZXJ0eV0gPSAndHJhbnNsYXRlM2QoJyArIGxlZnQgKyAncHgsICcgKyB0b3AgKyAncHgsIDApJztcbiAgICBzdHlsZXNbc2lkZUFdID0gMDtcbiAgICBzdHlsZXNbc2lkZUJdID0gMDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aHdlcmlzZSwgd2UgdXNlIHRoZSBzdGFuZGFyZCBgdG9wYCwgYGxlZnRgLCBgYm90dG9tYCBhbmQgYHJpZ2h0YCBwcm9wZXJ0aWVzXG4gICAgdmFyIGludmVydFRvcCA9IHNpZGVBID09PSAnYm90dG9tJyA/IC0xIDogMTtcbiAgICB2YXIgaW52ZXJ0TGVmdCA9IHNpZGVCID09PSAncmlnaHQnID8gLTEgOiAxO1xuICAgIHN0eWxlc1tzaWRlQV0gPSB0b3AgKiBpbnZlcnRUb3A7XG4gICAgc3R5bGVzW3NpZGVCXSA9IGxlZnQgKiBpbnZlcnRMZWZ0O1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gc2lkZUEgKyAnLCAnICsgc2lkZUI7XG4gIH1cblxuICAvLyBBdHRyaWJ1dGVzXG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICd4LXBsYWNlbWVudCc6IGRhdGEucGxhY2VtZW50XG4gIH07XG5cbiAgLy8gVXBkYXRlIGBkYXRhYCBhdHRyaWJ1dGVzLCBzdHlsZXMgYW5kIGFycm93U3R5bGVzXG4gIGRhdGEuYXR0cmlidXRlcyA9IF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCBkYXRhLmF0dHJpYnV0ZXMpO1xuICBkYXRhLnN0eWxlcyA9IF9leHRlbmRzKHt9LCBzdHlsZXMsIGRhdGEuc3R5bGVzKTtcbiAgZGF0YS5hcnJvd1N0eWxlcyA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMuYXJyb3csIGRhdGEuYXJyb3dTdHlsZXMpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGRlcGVuZHMgZnJvbSBhbm90aGVyIG9uZS48YnIgLz5cbiAqIEl0IGNoZWNrcyBpZiB0aGUgbmVlZGVkIG1vZGlmaWVyIGlzIGxpc3RlZCBhbmQgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVycyAtIGxpc3Qgb2YgbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGluZ05hbWUgLSBuYW1lIG9mIHJlcXVlc3RpbmcgbW9kaWZpZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0ZWROYW1lIC0gbmFtZSBvZiByZXF1ZXN0ZWQgbW9kaWZpZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyUmVxdWlyZWQobW9kaWZpZXJzLCByZXF1ZXN0aW5nTmFtZSwgcmVxdWVzdGVkTmFtZSkge1xuICB2YXIgcmVxdWVzdGluZyA9IGZpbmQobW9kaWZpZXJzLCBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgIHJldHVybiBuYW1lID09PSByZXF1ZXN0aW5nTmFtZTtcbiAgfSk7XG5cbiAgdmFyIGlzUmVxdWlyZWQgPSAhIXJlcXVlc3RpbmcgJiYgbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09IHJlcXVlc3RlZE5hbWUgJiYgbW9kaWZpZXIuZW5hYmxlZCAmJiBtb2RpZmllci5vcmRlciA8IHJlcXVlc3Rpbmcub3JkZXI7XG4gIH0pO1xuXG4gIGlmICghaXNSZXF1aXJlZCkge1xuICAgIHZhciBfcmVxdWVzdGluZyA9ICdgJyArIHJlcXVlc3RpbmdOYW1lICsgJ2AnO1xuICAgIHZhciByZXF1ZXN0ZWQgPSAnYCcgKyByZXF1ZXN0ZWROYW1lICsgJ2AnO1xuICAgIGNvbnNvbGUud2FybihyZXF1ZXN0ZWQgKyAnIG1vZGlmaWVyIGlzIHJlcXVpcmVkIGJ5ICcgKyBfcmVxdWVzdGluZyArICcgbW9kaWZpZXIgaW4gb3JkZXIgdG8gd29yaywgYmUgc3VyZSB0byBpbmNsdWRlIGl0IGJlZm9yZSAnICsgX3JlcXVlc3RpbmcgKyAnIScpO1xuICB9XG4gIHJldHVybiBpc1JlcXVpcmVkO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gYXJyb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyRhcnJvdztcblxuICAvLyBhcnJvdyBkZXBlbmRzIG9uIGtlZXBUb2dldGhlciBpbiBvcmRlciB0byB3b3JrXG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnYXJyb3cnLCAna2VlcFRvZ2V0aGVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBhcnJvd0VsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGEgc3RyaW5nLCBzdXBwb3NlIGl0J3MgYSBDU1Mgc2VsZWN0b3JcbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIG5vdCBmb3VuZCwgZG9uJ3QgcnVuIHRoZSBtb2RpZmllclxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgdGhlIGFycm93RWxlbWVudCBpc24ndCBhIHF1ZXJ5IHNlbGVjdG9yIHdlIG11c3QgY2hlY2sgdGhhdCB0aGVcbiAgICAvLyBwcm92aWRlZCBET00gbm9kZSBpcyBjaGlsZCBvZiBpdHMgcG9wcGVyIG5vZGVcbiAgICBpZiAoIWRhdGEuaW5zdGFuY2UucG9wcGVyLmNvbnRhaW5zKGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGFycm93LmVsZW1lbnRgIG11c3QgYmUgY2hpbGQgb2YgaXRzIHBvcHBlciBlbGVtZW50IScpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzaWRlQ2FwaXRhbGl6ZWQgPSBpc1ZlcnRpY2FsID8gJ1RvcCcgOiAnTGVmdCc7XG4gIHZhciBzaWRlID0gc2lkZUNhcGl0YWxpemVkLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhbHRTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgdmFyIGFycm93RWxlbWVudFNpemUgPSBnZXRPdXRlclNpemVzKGFycm93RWxlbWVudClbbGVuXTtcblxuICAvL1xuICAvLyBleHRlbmRzIGtlZXBUb2dldGhlciBiZWhhdmlvciBtYWtpbmcgc3VyZSB0aGUgcG9wcGVyIGFuZCBpdHNcbiAgLy8gcmVmZXJlbmNlIGhhdmUgZW5vdWdoIHBpeGVscyBpbiBjb25qdW5jdGlvblxuICAvL1xuXG4gIC8vIHRvcC9sZWZ0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSA8IHBvcHBlcltzaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLT0gcG9wcGVyW3NpZGVdIC0gKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSk7XG4gIH1cbiAgLy8gYm90dG9tL3JpZ2h0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgPiBwb3BwZXJbb3BTaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gKz0gcmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSAtIHBvcHBlcltvcFNpZGVdO1xuICB9XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuXG4gIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgdmFyIGNlbnRlciA9IHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVtsZW5dIC8gMiAtIGFycm93RWxlbWVudFNpemUgLyAyO1xuXG4gIC8vIENvbXB1dGUgdGhlIHNpZGVWYWx1ZSB1c2luZyB0aGUgdXBkYXRlZCBwb3BwZXIgb2Zmc2V0c1xuICAvLyB0YWtlIHBvcHBlciBtYXJnaW4gaW4gYWNjb3VudCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgdGhpcyBpbmZvIGF2YWlsYWJsZVxuICB2YXIgY3NzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIHBvcHBlck1hcmdpblNpZGUgPSBwYXJzZUZsb2F0KGNzc1snbWFyZ2luJyArIHNpZGVDYXBpdGFsaXplZF0pO1xuICB2YXIgcG9wcGVyQm9yZGVyU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydib3JkZXInICsgc2lkZUNhcGl0YWxpemVkICsgJ1dpZHRoJ10pO1xuICB2YXIgc2lkZVZhbHVlID0gY2VudGVyIC0gZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtIHBvcHBlck1hcmdpblNpZGUgLSBwb3BwZXJCb3JkZXJTaWRlO1xuXG4gIC8vIHByZXZlbnQgYXJyb3dFbGVtZW50IGZyb20gYmVpbmcgcGxhY2VkIG5vdCBjb250aWd1b3VzbHkgdG8gaXRzIHBvcHBlclxuICBzaWRlVmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihwb3BwZXJbbGVuXSAtIGFycm93RWxlbWVudFNpemUsIHNpZGVWYWx1ZSksIDApO1xuXG4gIGRhdGEuYXJyb3dFbGVtZW50ID0gYXJyb3dFbGVtZW50O1xuICBkYXRhLm9mZnNldHMuYXJyb3cgPSAoX2RhdGEkb2Zmc2V0cyRhcnJvdyA9IHt9LCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBzaWRlLCBNYXRoLnJvdW5kKHNpZGVWYWx1ZSkpLCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBhbHRTaWRlLCAnJyksIF9kYXRhJG9mZnNldHMkYXJyb3cpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IHZhcmlhdGlvbiBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IHZhcmlhdGlvblxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbikge1xuICBpZiAodmFyaWF0aW9uID09PSAnZW5kJykge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9IGVsc2UgaWYgKHZhcmlhdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgIHJldHVybiAnZW5kJztcbiAgfVxuICByZXR1cm4gdmFyaWF0aW9uO1xufVxuXG4vKipcbiAqIExpc3Qgb2YgYWNjZXB0ZWQgcGxhY2VtZW50cyB0byB1c2UgYXMgdmFsdWVzIG9mIHRoZSBgcGxhY2VtZW50YCBvcHRpb24uPGJyIC8+XG4gKiBWYWxpZCBwbGFjZW1lbnRzIGFyZTpcbiAqIC0gYGF1dG9gXG4gKiAtIGB0b3BgXG4gKiAtIGByaWdodGBcbiAqIC0gYGJvdHRvbWBcbiAqIC0gYGxlZnRgXG4gKlxuICogRWFjaCBwbGFjZW1lbnQgY2FuIGhhdmUgYSB2YXJpYXRpb24gZnJvbSB0aGlzIGxpc3Q6XG4gKiAtIGAtc3RhcnRgXG4gKiAtIGAtZW5kYFxuICpcbiAqIFZhcmlhdGlvbnMgYXJlIGludGVycHJldGVkIGVhc2lseSBpZiB5b3UgdGhpbmsgb2YgdGhlbSBhcyB0aGUgbGVmdCB0byByaWdodFxuICogd3JpdHRlbiBsYW5ndWFnZXMuIEhvcml6b250YWxseSAoYHRvcGAgYW5kIGBib3R0b21gKSwgYHN0YXJ0YCBpcyBsZWZ0IGFuZCBgZW5kYFxuICogaXMgcmlnaHQuPGJyIC8+XG4gKiBWZXJ0aWNhbGx5IChgbGVmdGAgYW5kIGByaWdodGApLCBgc3RhcnRgIGlzIHRvcCBhbmQgYGVuZGAgaXMgYm90dG9tLlxuICpcbiAqIFNvbWUgdmFsaWQgZXhhbXBsZXMgYXJlOlxuICogLSBgdG9wLWVuZGAgKG9uIHRvcCBvZiByZWZlcmVuY2UsIHJpZ2h0IGFsaWduZWQpXG4gKiAtIGByaWdodC1zdGFydGAgKG9uIHJpZ2h0IG9mIHJlZmVyZW5jZSwgdG9wIGFsaWduZWQpXG4gKiAtIGBib3R0b21gIChvbiBib3R0b20sIGNlbnRlcmVkKVxuICogLSBgYXV0by1lbmRgIChvbiB0aGUgc2lkZSB3aXRoIG1vcmUgc3BhY2UgYXZhaWxhYmxlLCBhbGlnbm1lbnQgZGVwZW5kcyBieSBwbGFjZW1lbnQpXG4gKlxuICogQHN0YXRpY1xuICogQHR5cGUge0FycmF5fVxuICogQGVudW0ge1N0cmluZ31cbiAqIEByZWFkb25seVxuICogQG1ldGhvZCBwbGFjZW1lbnRzXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBwbGFjZW1lbnRzID0gWydhdXRvLXN0YXJ0JywgJ2F1dG8nLCAnYXV0by1lbmQnLCAndG9wLXN0YXJ0JywgJ3RvcCcsICd0b3AtZW5kJywgJ3JpZ2h0LXN0YXJ0JywgJ3JpZ2h0JywgJ3JpZ2h0LWVuZCcsICdib3R0b20tZW5kJywgJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnbGVmdC1lbmQnLCAnbGVmdCcsICdsZWZ0LXN0YXJ0J107XG5cbi8vIEdldCByaWQgb2YgYGF1dG9gIGBhdXRvLXN0YXJ0YCBhbmQgYGF1dG8tZW5kYFxudmFyIHZhbGlkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuc2xpY2UoMyk7XG5cbi8qKlxuICogR2l2ZW4gYW4gaW5pdGlhbCBwbGFjZW1lbnQsIHJldHVybnMgYWxsIHRoZSBzdWJzZXF1ZW50IHBsYWNlbWVudHNcbiAqIGNsb2Nrd2lzZSAob3IgY291bnRlci1jbG9ja3dpc2UpLlxuICpcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgLSBBIHZhbGlkIHBsYWNlbWVudCAoaXQgYWNjZXB0cyB2YXJpYXRpb25zKVxuICogQGFyZ3VtZW50IHtCb29sZWFufSBjb3VudGVyIC0gU2V0IHRvIHRydWUgdG8gd2FsayB0aGUgcGxhY2VtZW50cyBjb3VudGVyY2xvY2t3aXNlXG4gKiBAcmV0dXJucyB7QXJyYXl9IHBsYWNlbWVudHMgaW5jbHVkaW5nIHRoZWlyIHZhcmlhdGlvbnNcbiAqL1xuZnVuY3Rpb24gY2xvY2t3aXNlKHBsYWNlbWVudCkge1xuICB2YXIgY291bnRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGluZGV4ID0gdmFsaWRQbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KTtcbiAgdmFyIGFyciA9IHZhbGlkUGxhY2VtZW50cy5zbGljZShpbmRleCArIDEpLmNvbmNhdCh2YWxpZFBsYWNlbWVudHMuc2xpY2UoMCwgaW5kZXgpKTtcbiAgcmV0dXJuIGNvdW50ZXIgPyBhcnIucmV2ZXJzZSgpIDogYXJyO1xufVxuXG52YXIgQkVIQVZJT1JTID0ge1xuICBGTElQOiAnZmxpcCcsXG4gIENMT0NLV0lTRTogJ2Nsb2Nrd2lzZScsXG4gIENPVU5URVJDTE9DS1dJU0U6ICdjb3VudGVyY2xvY2t3aXNlJ1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGZsaXAoZGF0YSwgb3B0aW9ucykge1xuICAvLyBpZiBgaW5uZXJgIG1vZGlmaWVyIGlzIGVuYWJsZWQsIHdlIGNhbid0IHVzZSB0aGUgYGZsaXBgIG1vZGlmaWVyXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2lubmVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGlmIChkYXRhLmZsaXBwZWQgJiYgZGF0YS5wbGFjZW1lbnQgPT09IGRhdGEub3JpZ2luYWxQbGFjZW1lbnQpIHtcbiAgICAvLyBzZWVtcyBsaWtlIGZsaXAgaXMgdHJ5aW5nIHRvIGxvb3AsIHByb2JhYmx5IHRoZXJlJ3Mgbm90IGVub3VnaCBzcGFjZSBvbiBhbnkgb2YgdGhlIGZsaXBwYWJsZSBzaWRlc1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVsxXSB8fCAnJztcblxuICB2YXIgZmxpcE9yZGVyID0gW107XG5cbiAgc3dpdGNoIChvcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgY2FzZSBCRUhBVklPUlMuRkxJUDpcbiAgICAgIGZsaXBPcmRlciA9IFtwbGFjZW1lbnQsIHBsYWNlbWVudE9wcG9zaXRlXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ09VTlRFUkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZsaXBPcmRlciA9IG9wdGlvbnMuYmVoYXZpb3I7XG4gIH1cblxuICBmbGlwT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCwgaW5kZXgpIHtcbiAgICBpZiAocGxhY2VtZW50ICE9PSBzdGVwIHx8IGZsaXBPcmRlci5sZW5ndGggPT09IGluZGV4ICsgMSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG4gICAgdmFyIHJlZk9mZnNldHMgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuXG4gICAgLy8gdXNpbmcgZmxvb3IgYmVjYXVzZSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgbWF5IGNvbnRhaW4gZGVjaW1hbHMgd2UgYXJlIG5vdCBnb2luZyB0byBjb25zaWRlciBoZXJlXG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgb3ZlcmxhcHNSZWYgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKHJlZk9mZnNldHMubGVmdCkgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihyZWZPZmZzZXRzLnJpZ2h0KSB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKHJlZk9mZnNldHMudG9wKSB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKHJlZk9mZnNldHMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NMZWZ0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKGJvdW5kYXJpZXMubGVmdCk7XG4gICAgdmFyIG92ZXJmbG93c1JpZ2h0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihib3VuZGFyaWVzLnJpZ2h0KTtcbiAgICB2YXIgb3ZlcmZsb3dzVG9wID0gZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IoYm91bmRhcmllcy50b3ApO1xuICAgIHZhciBvdmVyZmxvd3NCb3R0b20gPSBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihib3VuZGFyaWVzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzQm91bmRhcmllcyA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIG92ZXJmbG93c0xlZnQgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIG92ZXJmbG93c1JpZ2h0IHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgb3ZlcmZsb3dzVG9wIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgb3ZlcmZsb3dzQm90dG9tO1xuXG4gICAgLy8gZmxpcCB0aGUgdmFyaWF0aW9uIGlmIHJlcXVpcmVkXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgLy8gZmxpcHMgdmFyaWF0aW9uIGlmIHJlZmVyZW5jZSBlbGVtZW50IG92ZXJmbG93cyBib3VuZGFyaWVzXG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb25CeVJlZiA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1RvcCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0JvdHRvbSk7XG5cbiAgICAvLyBmbGlwcyB2YXJpYXRpb24gaWYgcG9wcGVyIGNvbnRlbnQgb3ZlcmZsb3dzIGJvdW5kYXJpZXNcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbkJ5Q29udGVudCA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9uc0J5Q29udGVudCAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0xlZnQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0JvdHRvbSB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1RvcCk7XG5cbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbiA9IGZsaXBwZWRWYXJpYXRpb25CeVJlZiB8fCBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50O1xuXG4gICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMgfHwgZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgLy8gdGhpcyBib29sZWFuIHRvIGRldGVjdCBhbnkgZmxpcCBsb29wXG4gICAgICBkYXRhLmZsaXBwZWQgPSB0cnVlO1xuXG4gICAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcykge1xuICAgICAgICBwbGFjZW1lbnQgPSBmbGlwT3JkZXJbaW5kZXggKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgdmFyaWF0aW9uID0gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5wbGFjZW1lbnQgPSBwbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xuXG4gICAgICAvLyB0aGlzIG9iamVjdCBjb250YWlucyBgcG9zaXRpb25gLCB3ZSB3YW50IHRvIHByZXNlcnZlIGl0IGFsb25nIHdpdGhcbiAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHByb3BlcnR5IHdlIG1heSBhZGQgaW4gdGhlIGZ1dHVyZVxuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMucG9wcGVyLCBnZXRQb3BwZXJPZmZzZXRzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCkpO1xuXG4gICAgICBkYXRhID0gcnVuTW9kaWZpZXJzKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBkYXRhLCAnZmxpcCcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24ga2VlcFRvZ2V0aGVyKGRhdGEpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdyaWdodCcgOiAnYm90dG9tJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICBpZiAocG9wcGVyW3NpZGVdIDwgZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pIC0gcG9wcGVyW21lYXN1cmVtZW50XTtcbiAgfVxuICBpZiAocG9wcGVyW29wU2lkZV0gPiBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW3NpZGVdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdmFsdWUgKyB1bml0IGludG8gYSBweCB2YWx1ZSBudW1iZXJcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzdHIgLSBWYWx1ZSArIHVuaXQgc3RyaW5nXG4gKiBAYXJndW1lbnQge1N0cmluZ30gbWVhc3VyZW1lbnQgLSBgaGVpZ2h0YCBvciBgd2lkdGhgXG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICogVmFsdWUgaW4gcGl4ZWxzLCBvciBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdmFsdWVzIHdlcmUgZXh0cmFjdGVkXG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cykge1xuICAvLyBzZXBhcmF0ZSB2YWx1ZSBmcm9tIHVuaXRcbiAgdmFyIHNwbGl0ID0gc3RyLm1hdGNoKC8oKD86XFwtfFxcKyk/XFxkKlxcLj9cXGQqKSguKikvKTtcbiAgdmFyIHZhbHVlID0gK3NwbGl0WzFdO1xuICB2YXIgdW5pdCA9IHNwbGl0WzJdO1xuXG4gIC8vIElmIGl0J3Mgbm90IGEgbnVtYmVyIGl0J3MgYW4gb3BlcmF0b3IsIEkgZ3Vlc3NcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBpZiAodW5pdC5pbmRleE9mKCclJykgPT09IDApIHtcbiAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgIGNhc2UgJyVwJzpcbiAgICAgICAgZWxlbWVudCA9IHBvcHBlck9mZnNldHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJSc6XG4gICAgICBjYXNlICclcic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbGVtZW50ID0gcmVmZXJlbmNlT2Zmc2V0cztcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3ZoJyB8fCB1bml0ID09PSAndncnKSB7XG4gICAgLy8gaWYgaXMgYSB2aCBvciB2dywgd2UgY2FsY3VsYXRlIHRoZSBzaXplIGJhc2VkIG9uIHRoZSB2aWV3cG9ydFxuICAgIHZhciBzaXplID0gdm9pZCAwO1xuICAgIGlmICh1bml0ID09PSAndmgnKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpcyBhbiBleHBsaWNpdCBwaXhlbCB1bml0LCB3ZSBnZXQgcmlkIG9mIHRoZSB1bml0IGFuZCBrZWVwIHRoZSB2YWx1ZVxuICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBgb2Zmc2V0YCBzdHJpbmcgdG8gZXh0cmFwb2xhdGUgYHhgIGFuZCBgeWAgbnVtZXJpYyBvZmZzZXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICogQHJldHVybnMge0FycmF5fSBhIHR3byBjZWxscyBhcnJheSB3aXRoIHggYW5kIHkgb2Zmc2V0cyBpbiBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cywgYmFzZVBsYWNlbWVudCkge1xuICB2YXIgb2Zmc2V0cyA9IFswLCAwXTtcblxuICAvLyBVc2UgaGVpZ2h0IGlmIHBsYWNlbWVudCBpcyBsZWZ0IG9yIHJpZ2h0IGFuZCBpbmRleCBpcyAwIG90aGVyd2lzZSB1c2Ugd2lkdGhcbiAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAvLyB3aWxsIHVzZSB0aGUgb3RoZXIgb25lXG4gIHZhciB1c2VIZWlnaHQgPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAvLyBTcGxpdCB0aGUgb2Zmc2V0IHN0cmluZyB0byBvYnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHNcbiAgLy8gVGhlIHJlZ2V4IGFkZHJlc3NlcyB2YWx1ZXMgd2l0aCB0aGUgcGx1cyBvciBtaW51cyBzaWduIGluIGZyb250ICgrMTAsIC0yMCwgZXRjKVxuICB2YXIgZnJhZ21lbnRzID0gb2Zmc2V0LnNwbGl0KC8oXFwrfFxcLSkvKS5tYXAoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy50cmltKCk7XG4gIH0pO1xuXG4gIC8vIERldGVjdCBpZiB0aGUgb2Zmc2V0IHN0cmluZyBjb250YWlucyBhIHBhaXIgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIG9uZVxuICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICB2YXIgZGl2aWRlciA9IGZyYWdtZW50cy5pbmRleE9mKGZpbmQoZnJhZ21lbnRzLCBmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnNlYXJjaCgvLHxcXHMvKSAhPT0gLTE7XG4gIH0pKTtcblxuICBpZiAoZnJhZ21lbnRzW2RpdmlkZXJdICYmIGZyYWdtZW50c1tkaXZpZGVyXS5pbmRleE9mKCcsJykgPT09IC0xKSB7XG4gICAgY29uc29sZS53YXJuKCdPZmZzZXRzIHNlcGFyYXRlZCBieSB3aGl0ZSBzcGFjZShzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIGEgY29tbWEgKCwpIGluc3RlYWQuJyk7XG4gIH1cblxuICAvLyBJZiBkaXZpZGVyIGlzIGZvdW5kLCB3ZSBkaXZpZGUgdGhlIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kcyB0byBkaXZpZGVcbiAgLy8gdGhlbSBieSBvZnNldCBYIGFuZCBZLlxuICB2YXIgc3BsaXRSZWdleCA9IC9cXHMqLFxccyp8XFxzKy87XG4gIHZhciBvcHMgPSBkaXZpZGVyICE9PSAtMSA/IFtmcmFnbWVudHMuc2xpY2UoMCwgZGl2aWRlcikuY29uY2F0KFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMF1dKSwgW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVsxXV0uY29uY2F0KGZyYWdtZW50cy5zbGljZShkaXZpZGVyICsgMSkpXSA6IFtmcmFnbWVudHNdO1xuXG4gIC8vIENvbnZlcnQgdGhlIHZhbHVlcyB3aXRoIHVuaXRzIHRvIGFic29sdXRlIHBpeGVscyB0byBhbGxvdyBvdXIgY29tcHV0YXRpb25zXG4gIG9wcyA9IG9wcy5tYXAoZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIC8vIE1vc3Qgb2YgdGhlIHVuaXRzIHJlbHkgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwb3BwZXJcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSAoaW5kZXggPT09IDEgPyAhdXNlSGVpZ2h0IDogdXNlSGVpZ2h0KSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICByZXR1cm4gb3BcbiAgICAvLyBUaGlzIGFnZ3JlZ2F0ZXMgYW55IGArYCBvciBgLWAgc2lnbiB0aGF0IGFyZW4ndCBjb25zaWRlcmVkIG9wZXJhdG9yc1xuICAgIC8vIGUuZy46IDEwICsgKzUgPT4gWzEwLCArLCArNV1cbiAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYVthLmxlbmd0aCAtIDFdID09PSAnJyAmJiBbJysnLCAnLSddLmluZGV4T2YoYikgIT09IC0xKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2UgaWYgKG1lcmdlV2l0aFByZXZpb3VzKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSArPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgIH1cbiAgICB9LCBbXSlcbiAgICAvLyBIZXJlIHdlIGNvbnZlcnQgdGhlIHN0cmluZyB2YWx1ZXMgaW50byBudW1iZXIgdmFsdWVzIChpbiBweClcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBMb29wIHRyb3VnaCB0aGUgb2Zmc2V0cyBhcnJheXMgYW5kIGV4ZWN1dGUgdGhlIG9wZXJhdGlvbnNcbiAgb3BzLmZvckVhY2goZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIG9wLmZvckVhY2goZnVuY3Rpb24gKGZyYWcsIGluZGV4Mikge1xuICAgICAgaWYgKGlzTnVtZXJpYyhmcmFnKSkge1xuICAgICAgICBvZmZzZXRzW2luZGV4XSArPSBmcmFnICogKG9wW2luZGV4MiAtIDFdID09PSAnLScgPyAtMSA6IDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQGFyZ3VtZW50IHtOdW1iZXJ8U3RyaW5nfSBvcHRpb25zLm9mZnNldD0wXG4gKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gb2Zmc2V0KGRhdGEsIF9yZWYpIHtcbiAgdmFyIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQsXG4gICAgICBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIHZhciBvZmZzZXRzID0gdm9pZCAwO1xuICBpZiAoaXNOdW1lcmljKCtvZmZzZXQpKSB7XG4gICAgb2Zmc2V0cyA9IFsrb2Zmc2V0LCAwXTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRzID0gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYmFzZVBsYWNlbWVudCk7XG4gIH1cblxuICBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0IC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wIC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1sxXTtcbiAgfVxuXG4gIGRhdGEucG9wcGVyID0gcG9wcGVyO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kYXJpZXNFbGVtZW50ID0gb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCB8fCBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuXG4gIC8vIElmIG9mZnNldFBhcmVudCBpcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIHJlYWxseSB3YW50IHRvXG4gIC8vIGdvIG9uZSBzdGVwIHVwIGFuZCB1c2UgdGhlIG5leHQgb2Zmc2V0UGFyZW50IGFzIHJlZmVyZW5jZSB0b1xuICAvLyBhdm9pZCB0byBtYWtlIHRoaXMgbW9kaWZpZXIgY29tcGxldGVseSB1c2VsZXNzIGFuZCBsb29rIGxpa2UgYnJva2VuXG4gIGlmIChkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICBib3VuZGFyaWVzRWxlbWVudCA9IGdldE9mZnNldFBhcmVudChib3VuZGFyaWVzRWxlbWVudCk7XG4gIH1cblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzZXRzIHRoZSBwb3BwZXIncyBwb3NpdGlvbiBzbyB0aGF0IHRoZSBkb2N1bWVudCBzaXplIGNhbiBiZSBjYWxjdWxhdGVkIGV4Y2x1ZGluZ1xuICAvLyB0aGUgc2l6ZSBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgaXRzZWxmXG4gIHZhciB0cmFuc2Zvcm1Qcm9wID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcbiAgdmFyIHBvcHBlclN0eWxlcyA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnN0eWxlOyAvLyBhc3NpZ25tZW50IHRvIGhlbHAgbWluaWZpY2F0aW9uXG4gIHZhciB0b3AgPSBwb3BwZXJTdHlsZXMudG9wLFxuICAgICAgbGVmdCA9IHBvcHBlclN0eWxlcy5sZWZ0LFxuICAgICAgdHJhbnNmb3JtID0gcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdO1xuXG4gIHBvcHBlclN0eWxlcy50b3AgPSAnJztcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSAnJztcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gJyc7XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIG9mZnNldHMgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gIHBvcHBlclN0eWxlcy50b3AgPSB0b3A7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gbGVmdDtcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuXG4gIG9wdGlvbnMuYm91bmRhcmllcyA9IGJvdW5kYXJpZXM7XG5cbiAgdmFyIG9yZGVyID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgdmFyIGNoZWNrID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uIHByaW1hcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgocG9wcGVyW3BsYWNlbWVudF0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIHBsYWNlbWVudCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5OiBmdW5jdGlvbiBzZWNvbmRhcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPiBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKHBvcHBlclttYWluU2lkZV0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSAtIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIG1haW5TaWRlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHZhciBzaWRlID0gWydsZWZ0JywgJ3RvcCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5JztcbiAgICBwb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBjaGVja1tzaWRlXShwbGFjZW1lbnQpKTtcbiAgfSk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gc2hpZnQoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBzaGlmdHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIC8vIGlmIHNoaWZ0IHNoaWZ0dmFyaWF0aW9uIGlzIHNwZWNpZmllZCwgcnVuIHRoZSBtb2RpZmllclxuICBpZiAoc2hpZnR2YXJpYXRpb24pIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyO1xuXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgdmFyIHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgIHN0YXJ0OiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdKSxcbiAgICAgIGVuZDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVttZWFzdXJlbWVudF0gLSBwb3BwZXJbbWVhc3VyZW1lbnRdKVxuICAgIH07XG5cbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgc2hpZnRPZmZzZXRzW3NoaWZ0dmFyaWF0aW9uXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciByZWZSZWN0ID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIGJvdW5kID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdwcmV2ZW50T3ZlcmZsb3cnO1xuICB9KS5ib3VuZGFyaWVzO1xuXG4gIGlmIChyZWZSZWN0LmJvdHRvbSA8IGJvdW5kLnRvcCB8fCByZWZSZWN0LmxlZnQgPiBib3VuZC5yaWdodCB8fCByZWZSZWN0LnRvcCA+IGJvdW5kLmJvdHRvbSB8fCByZWZSZWN0LnJpZ2h0IDwgYm91bmQubGVmdCkge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IHRydWU7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gZmFsc2U7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBpbm5lcihkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc0hvcml6ID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIHN1YnRyYWN0TGVuZ3RoID0gWyd0b3AnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPT09IC0xO1xuXG4gIHBvcHBlcltpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCddID0gcmVmZXJlbmNlW2Jhc2VQbGFjZW1lbnRdIC0gKHN1YnRyYWN0TGVuZ3RoID8gcG9wcGVyW2lzSG9yaXogPyAnd2lkdGgnIDogJ2hlaWdodCddIDogMCk7XG5cbiAgZGF0YS5wbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChwb3BwZXIpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyIGZ1bmN0aW9uLCBlYWNoIG1vZGlmaWVyIGNhbiBoYXZlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIGFzc2lnbmVkXG4gKiB0byBpdHMgYGZuYCBwcm9wZXJ0eS48YnIgLz5cbiAqIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZSwgdGhpcyBtZWFucyB0aGF0IHlvdSBtdXN0XG4gKiBtYWtlIHN1cmUgdGhleSBhcmUgcGVyZm9ybWFudCBlbm91Z2ggdG8gYXZvaWQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuXG4gKlxuICogQGZ1bmN0aW9uIE1vZGlmaWVyRm5cbiAqIEBhcmd1bWVudCB7ZGF0YU9iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5cbi8qKlxuICogTW9kaWZpZXJzIGFyZSBwbHVnaW5zIHVzZWQgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHlvdXIgcG9wcGVycy48YnIgLz5cbiAqIFBvcHBlci5qcyB1c2VzIGEgc2V0IG9mIDkgbW9kaWZpZXJzIHRvIHByb3ZpZGUgYWxsIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXNcbiAqIG5lZWRlZCBieSB0aGUgbGlicmFyeS5cbiAqXG4gKiBVc3VhbGx5IHlvdSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIHRoZSBgb3JkZXJgLCBgZm5gIGFuZCBgb25Mb2FkYCBwcm9wcy5cbiAqIEFsbCB0aGUgb3RoZXIgcHJvcGVydGllcyBhcmUgY29uZmlndXJhdGlvbnMgdGhhdCBjb3VsZCBiZSB0d2Vha2VkLlxuICogQG5hbWVzcGFjZSBtb2RpZmllcnNcbiAqL1xudmFyIG1vZGlmaWVycyA9IHtcbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gc2hpZnQgdGhlIHBvcHBlciBvbiB0aGUgc3RhcnQgb3IgZW5kIG9mIGl0cyByZWZlcmVuY2VcbiAgICogZWxlbWVudC48YnIgLz5cbiAgICogSXQgd2lsbCByZWFkIHRoZSB2YXJpYXRpb24gb2YgdGhlIGBwbGFjZW1lbnRgIHByb3BlcnR5LjxiciAvPlxuICAgKiBJdCBjYW4gYmUgb25lIGVpdGhlciBgLWVuZGAgb3IgYC1zdGFydGAuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBzaGlmdDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0xMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHNoaWZ0XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBgb2Zmc2V0YCBtb2RpZmllciBjYW4gc2hpZnQgeW91ciBwb3BwZXIgb24gYm90aCBpdHMgYXhpcy5cbiAgICpcbiAgICogSXQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHVuaXRzOlxuICAgKiAtIGBweGAgb3IgdW5pdC1sZXNzLCBpbnRlcnByZXRlZCBhcyBwaXhlbHNcbiAgICogLSBgJWAgb3IgYCVyYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICAgKiAtIGAlcGAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogLSBgdndgLCBDU1Mgdmlld3BvcnQgd2lkdGggdW5pdFxuICAgKiAtIGB2aGAsIENTUyB2aWV3cG9ydCBoZWlnaHQgdW5pdFxuICAgKlxuICAgKiBGb3IgbGVuZ3RoIGlzIGludGVuZGVkIHRoZSBtYWluIGF4aXMgcmVsYXRpdmUgdG8gdGhlIHBsYWNlbWVudCBvZiB0aGUgcG9wcGVyLjxiciAvPlxuICAgKiBUaGlzIG1lYW5zIHRoYXQgaWYgdGhlIHBsYWNlbWVudCBpcyBgdG9wYCBvciBgYm90dG9tYCwgdGhlIGxlbmd0aCB3aWxsIGJlIHRoZVxuICAgKiBgd2lkdGhgLiBJbiBjYXNlIG9mIGBsZWZ0YCBvciBgcmlnaHRgLCBpdCB3aWxsIGJlIHRoZSBgaGVpZ2h0YC5cbiAgICpcbiAgICogWW91IGNhbiBwcm92aWRlIGEgc2luZ2xlIHZhbHVlIChhcyBgTnVtYmVyYCBvciBgU3RyaW5nYCksIG9yIGEgcGFpciBvZiB2YWx1ZXNcbiAgICogYXMgYFN0cmluZ2AgZGl2aWRlZCBieSBhIGNvbW1hIG9yIG9uZSAob3IgbW9yZSkgd2hpdGUgc3BhY2VzLjxiciAvPlxuICAgKiBUaGUgbGF0dGVyIGlzIGEgZGVwcmVjYXRlZCBtZXRob2QgYmVjYXVzZSBpdCBsZWFkcyB0byBjb25mdXNpb24gYW5kIHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpbiB2Mi48YnIgLz5cbiAgICogQWRkaXRpb25hbGx5LCBpdCBhY2NlcHRzIGFkZGl0aW9ucyBhbmQgc3VidHJhY3Rpb25zIGJldHdlZW4gZGlmZmVyZW50IHVuaXRzLlxuICAgKiBOb3RlIHRoYXQgbXVsdGlwbGljYXRpb25zIGFuZCBkaXZpc2lvbnMgYXJlbid0IHN1cHBvcnRlZC5cbiAgICpcbiAgICogVmFsaWQgZXhhbXBsZXMgYXJlOlxuICAgKiBgYGBcbiAgICogMTBcbiAgICogJzEwJSdcbiAgICogJzEwLCAxMCdcbiAgICogJzEwJSwgMTAnXG4gICAqICcxMCArIDEwJSdcbiAgICogJzEwIC0gNXZoICsgMyUnXG4gICAqICctMTBweCArIDV2aCwgNXB4IC0gNiUnXG4gICAqIGBgYFxuICAgKiA+ICoqTkIqKjogSWYgeW91IGRlc2lyZSB0byBhcHBseSBvZmZzZXRzIHRvIHlvdXIgcG9wcGVycyBpbiBhIHdheSB0aGF0IG1heSBtYWtlIHRoZW0gb3ZlcmxhcFxuICAgKiA+IHdpdGggdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnQsIHVuZm9ydHVuYXRlbHksIHlvdSB3aWxsIGhhdmUgdG8gZGlzYWJsZSB0aGUgYGZsaXBgIG1vZGlmaWVyLlxuICAgKiA+IFlvdSBjYW4gcmVhZCBtb3JlIG9uIHRoaXMgYXQgdGhpcyBbaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL2lzc3Vlcy8zNzMpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgb2Zmc2V0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTIwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogb2Zmc2V0LFxuICAgIC8qKiBAcHJvcCB7TnVtYmVyfFN0cmluZ30gb2Zmc2V0PTBcbiAgICAgKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBvZmZzZXQ6IDBcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBwcmV2ZW50IHRoZSBwb3BwZXIgZnJvbSBiZWluZyBwb3NpdGlvbmVkIG91dHNpZGUgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBBIHNjZW5hcmlvIGV4aXN0cyB3aGVyZSB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBub3Qgd2l0aGluIHRoZSBib3VuZGFyaWVzLjxiciAvPlxuICAgKiBXZSBjYW4gc2F5IGl0IGhhcyBcImVzY2FwZWQgdGhlIGJvdW5kYXJpZXNcIiDigJQgb3IganVzdCBcImVzY2FwZWRcIi48YnIgLz5cbiAgICogSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHBvcHBlciBzaG91bGQgZWl0aGVyOlxuICAgKlxuICAgKiAtIGRldGFjaCBmcm9tIHRoZSByZWZlcmVuY2UgYW5kIHJlbWFpbiBcInRyYXBwZWRcIiBpbiB0aGUgYm91bmRhcmllcywgb3JcbiAgICogLSBpZiBpdCBzaG91bGQgaWdub3JlIHRoZSBib3VuZGFyeSBhbmQgXCJlc2NhcGUgd2l0aCBpdHMgcmVmZXJlbmNlXCJcbiAgICpcbiAgICogV2hlbiBgZXNjYXBlV2l0aFJlZmVyZW5jZWAgaXMgc2V0IHRvYHRydWVgIGFuZCByZWZlcmVuY2UgaXMgY29tcGxldGVseVxuICAgKiBvdXRzaWRlIGl0cyBib3VuZGFyaWVzLCB0aGUgcG9wcGVyIHdpbGwgb3ZlcmZsb3cgKG9yIGNvbXBsZXRlbHkgbGVhdmUpXG4gICAqIHRoZSBib3VuZGFyaWVzIGluIG9yZGVyIHRvIHJlbWFpbiBhdHRhY2hlZCB0byB0aGUgZWRnZSBvZiB0aGUgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTMwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtBcnJheX0gW3ByaW9yaXR5PVsnbGVmdCcsJ3JpZ2h0JywndG9wJywnYm90dG9tJ11dXG4gICAgICogUG9wcGVyIHdpbGwgdHJ5IHRvIHByZXZlbnQgb3ZlcmZsb3cgZm9sbG93aW5nIHRoZXNlIHByaW9yaXRpZXMgYnkgZGVmYXVsdCxcbiAgICAgKiB0aGVuLCBpdCBjb3VsZCBvdmVyZmxvdyBvbiB0aGUgbGVmdCBhbmQgb24gdG9wIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcHJpb3JpdHk6IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogQW1vdW50IG9mIHBpeGVsIHVzZWQgdG8gZGVmaW5lIGEgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib3VuZGFyaWVzXG4gICAgICogYW5kIHRoZSBwb3BwZXIuIFRoaXMgbWFrZXMgc3VyZSB0aGUgcG9wcGVyIGFsd2F5cyBoYXMgYSBsaXR0bGUgcGFkZGluZ1xuICAgICAqIGJldHdlZW4gdGhlIGVkZ2VzIG9mIGl0cyBjb250YWluZXJcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSdzY3JvbGxQYXJlbnQnXG4gICAgICogQm91bmRhcmllcyB1c2VkIGJ5IHRoZSBtb2RpZmllci4gQ2FuIGJlIGBzY3JvbGxQYXJlbnRgLCBgd2luZG93YCxcbiAgICAgKiBgdmlld3BvcnRgIG9yIGFueSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3Njcm9sbFBhcmVudCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHJlZmVyZW5jZSBhbmQgaXRzIHBvcHBlciBzdGF5IG5lYXIgZWFjaCBvdGhlclxuICAgKiB3aXRob3V0IGxlYXZpbmcgYW55IGdhcCBiZXR3ZWVuIHRoZSB0d28uIEVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gdGhlIGFycm93IGlzXG4gICAqIGVuYWJsZWQgYW5kIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0IGl0IHBvaW50cyB0byBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEl0IGNhcmVzIG9ubHkgYWJvdXQgdGhlIGZpcnN0IGF4aXMuIFlvdSBjYW4gc3RpbGwgaGF2ZSBwb3BwZXJzIHdpdGggbWFyZ2luXG4gICAqIGJldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAga2VlcFRvZ2V0aGVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTQwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNDAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjoga2VlcFRvZ2V0aGVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kaWZpZXIgaXMgdXNlZCB0byBtb3ZlIHRoZSBgYXJyb3dFbGVtZW50YCBvZiB0aGUgcG9wcGVyIHRvIG1ha2VcbiAgICogc3VyZSBpdCBpcyBwb3NpdGlvbmVkIGJldHdlZW4gdGhlIHJlZmVyZW5jZSBlbGVtZW50IGFuZCBpdHMgcG9wcGVyIGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgb3V0ZXIgc2l6ZSBvZiB0aGUgYGFycm93RWxlbWVudGAgbm9kZSB0byBkZXRlY3QgaG93IG1hbnlcbiAgICogcGl4ZWxzIG9mIGNvbmp1bmN0aW9uIGFyZSBuZWVkZWQuXG4gICAqXG4gICAqIEl0IGhhcyBubyBlZmZlY3QgaWYgbm8gYGFycm93RWxlbWVudGAgaXMgcHJvdmlkZWQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcnJvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj01MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDUwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFycm93LFxuICAgIC8qKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBlbGVtZW50PSdbeC1hcnJvd10nIC0gU2VsZWN0b3Igb3Igbm9kZSB1c2VkIGFzIGFycm93ICovXG4gICAgZWxlbWVudDogJ1t4LWFycm93XSdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBmbGlwIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQgd2hlbiBpdCBzdGFydHMgdG8gb3ZlcmxhcCBpdHNcbiAgICogcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICpcbiAgICogKipOT1RFOioqIHRoaXMgbW9kaWZpZXIgd2lsbCBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlIGFuZCB3aWxsXG4gICAqIHJlc3RhcnQgaXQgaWYgaXQgZGV0ZWN0cyB0aGUgbmVlZCB0byBmbGlwIHRoZSBwbGFjZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBmbGlwOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTYwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogZmxpcCxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEFycmF5fSBiZWhhdmlvcj0nZmxpcCdcbiAgICAgKiBUaGUgYmVoYXZpb3IgdXNlZCB0byBjaGFuZ2UgdGhlIHBvcHBlcidzIHBsYWNlbWVudC4gSXQgY2FuIGJlIG9uZSBvZlxuICAgICAqIGBmbGlwYCwgYGNsb2Nrd2lzZWAsIGBjb3VudGVyY2xvY2t3aXNlYCBvciBhbiBhcnJheSB3aXRoIGEgbGlzdCBvZiB2YWxpZFxuICAgICAqIHBsYWNlbWVudHMgKHdpdGggb3B0aW9uYWwgdmFyaWF0aW9ucylcbiAgICAgKi9cbiAgICBiZWhhdmlvcjogJ2ZsaXAnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBmbGlwIGlmIGl0IGhpdHMgdGhlIGVkZ2VzIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0ndmlld3BvcnQnXG4gICAgICogVGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBvcHBlciBwb3NpdGlvbi5cbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgbmV2ZXIgYmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllc1xuICAgICAqIChleGNlcHQgaWYgYGtlZXBUb2dldGhlcmAgaXMgZW5hYmxlZClcbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3ZpZXdwb3J0JyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnM9ZmFsc2VcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgc3dpdGNoIHBsYWNlbWVudCB2YXJpYXRpb24gYmV0d2VlbiBgLXN0YXJ0YCBhbmQgYC1lbmRgIHdoZW5cbiAgICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIGJvdW5kYXJpZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3JpZ2luYWwgcGxhY2VtZW50IHNob3VsZCBoYXZlIGEgc2V0IHZhcmlhdGlvbi5cbiAgICAgKi9cbiAgICBmbGlwVmFyaWF0aW9uczogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGZsaXBWYXJpYXRpb25zQnlDb250ZW50PWZhbHNlXG4gICAgICogVGhlIHBvcHBlciB3aWxsIHN3aXRjaCBwbGFjZW1lbnQgdmFyaWF0aW9uIGJldHdlZW4gYC1zdGFydGAgYW5kIGAtZW5kYCB3aGVuXG4gICAgICogdGhlIHBvcHBlciBlbGVtZW50IG92ZXJsYXBzIGl0cyByZWZlcmVuY2UgYm91bmRhcmllcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAqL1xuICAgIGZsaXBWYXJpYXRpb25zQnlDb250ZW50OiBmYWxzZVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2UgdGhlIHBvcHBlciBmbG93IHRvd2FyZCB0aGUgaW5uZXIgb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBCeSBkZWZhdWx0LCB3aGVuIHRoaXMgbW9kaWZpZXIgaXMgZGlzYWJsZWQsIHRoZSBwb3BwZXIgd2lsbCBiZSBwbGFjZWQgb3V0c2lkZVxuICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBpbm5lcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj03MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDcwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9ZmFsc2UgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaW5uZXJcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBoaWRlIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0c2lkZSBvZiB0aGVcbiAgICogcG9wcGVyIGJvdW5kYXJpZXMuIEl0IHdpbGwgc2V0IGEgYHgtb3V0LW9mLWJvdW5kYXJpZXNgIGF0dHJpYnV0ZSB3aGljaCBjYW5cbiAgICogYmUgdXNlZCB0byBoaWRlIHdpdGggYSBDU1Mgc2VsZWN0b3IgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgaXNcbiAgICogb3V0IG9mIGJvdW5kYXJpZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGhpZGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBoaWRlXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdHlsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGVsZW1lbnQgdG8gZ2V0c1xuICAgKiBwcm9wZXJseSBwb3NpdGlvbmVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtb2RpZmllciB3aWxsIG5vdCB0b3VjaCB0aGUgRE9NLCBpdCBqdXN0IHByZXBhcmVzIHRoZSBzdHlsZXNcbiAgICogc28gdGhhdCBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgY2FuIGFwcGx5IGl0LiBUaGlzIHNlcGFyYXRpb24gaXMgdXNlZnVsXG4gICAqIGluIGNhc2UgeW91IG5lZWQgdG8gcmVwbGFjZSBgYXBwbHlTdHlsZWAgd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtb2RpZmllciBoYXMgYDg1MGAgYXMgYG9yZGVyYCB2YWx1ZSB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgUG9wcGVyLmpzLiBFeHBlY3QgdGhlIG1vZGlmaWVycyBvcmRlcmluZyBtZXRob2RcbiAgICogdG8gY2hhbmdlIGluIGZ1dHVyZSBtYWpvciB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGNvbXB1dGVTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04NTAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDg1MCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGNvbXB1dGVTdHlsZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHRydWUsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2JvdHRvbSddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBYIGF4aXMgKGBib3R0b21gIG9yIGB0b3BgKS4gQUtBIFggb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgYm90dG9tYFxuICAgICAqL1xuICAgIHg6ICdib3R0b20nLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdsZWZ0J11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFkgYXhpcyAoYGxlZnRgIG9yIGByaWdodGApLiBBS0EgWSBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGByaWdodGBcbiAgICAgKi9cbiAgICB5OiAncmlnaHQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGNvbXB1dGVkIHN0eWxlcyB0byB0aGUgcG9wcGVyIGVsZW1lbnQuXG4gICAqXG4gICAqIEFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgYXJlIGxpbWl0ZWQgdG8gdGhpcyBtb2RpZmllci4gVGhpcyBpcyB1c2VmdWwgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBpbnRlZ3JhdGUgUG9wcGVyLmpzIGluc2lkZSBhIGZyYW1ld29yayBvciB2aWV3IGxpYnJhcnkgYW5kIHlvdVxuICAgKiB3YW50IHRvIGRlbGVnYXRlIGFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgdG8gaXQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiB5b3UgZGlzYWJsZSB0aGlzIG1vZGlmaWVyLCB5b3UgbXVzdCBtYWtlIHN1cmUgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIGhhcyBpdHMgcG9zaXRpb24gc2V0IHRvIGBhYnNvbHV0ZWAgYmVmb3JlIFBvcHBlci5qcyBjYW4gZG8gaXRzIHdvcmshXG4gICAqXG4gICAqIEp1c3QgZGlzYWJsZSB0aGlzIG1vZGlmaWVyIGFuZCBkZWZpbmUgeW91ciBvd24gdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCBlZmZlY3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcHBseVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTkwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogOTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXBwbHlTdHlsZSxcbiAgICAvKiogQHByb3Age0Z1bmN0aW9ufSAqL1xuICAgIG9uTG9hZDogYXBwbHlTdHlsZU9uTG9hZCxcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMTAuMCwgdGhlIHByb3BlcnR5IG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNEIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB1bmRlZmluZWRcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgYGRhdGFPYmplY3RgIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgaW5mb3JtYXRpb24gdXNlZCBieSBQb3BwZXIuanMuXG4gKiBUaGlzIG9iamVjdCBpcyBwYXNzZWQgdG8gbW9kaWZpZXJzIGFuZCB0byB0aGUgYG9uQ3JlYXRlYCBhbmQgYG9uVXBkYXRlYCBjYWxsYmFja3MuXG4gKiBAbmFtZSBkYXRhT2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5pbnN0YW5jZSBUaGUgUG9wcGVyLmpzIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5wbGFjZW1lbnQgUGxhY2VtZW50IGFwcGxpZWQgdG8gcG9wcGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5mbGlwcGVkIFRydWUgaWYgcG9wcGVyIGhhcyBiZWVuIGZsaXBwZWQgYnkgZmxpcCBtb2RpZmllclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmhpZGUgVHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0IG9mIGJvdW5kYXJpZXMsIHVzZWZ1bCB0byBrbm93IHdoZW4gdG8gaGlkZSB0aGUgcG9wcGVyXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBkYXRhLmFycm93RWxlbWVudCBOb2RlIHVzZWQgYXMgYXJyb3cgYnkgYXJyb3cgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLnN0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmFycm93U3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGFycm93LiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYm91bmRhcmllcyBPZmZzZXRzIG9mIHRoZSBwb3BwZXIgYm91bmRhcmllc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cyBUaGUgbWVhc3VyZW1lbnRzIG9mIHBvcHBlciwgcmVmZXJlbmNlIGFuZCBhcnJvdyBlbGVtZW50c1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5wb3BwZXIgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMuYXJyb3ddIGB0b3BgIGFuZCBgbGVmdGAgb2Zmc2V0cywgb25seSBvbmUgb2YgdGhlbSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIDBcbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBwcm92aWRlZCB0byBQb3BwZXIuanMgY29uc3RydWN0b3IuPGJyIC8+XG4gKiBUaGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiB1c2luZyB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IG9mIFBvcHBlci5qcy48YnIgLz5cbiAqIFRvIG92ZXJyaWRlIGFuIG9wdGlvbiwgc2ltcGx5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWVcbiAqIHN0cnVjdHVyZSBvZiB0aGUgYG9wdGlvbnNgIG9iamVjdCwgYXMgdGhlIDNyZCBhcmd1bWVudC4gRm9yIGV4YW1wbGU6XG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmLCBwb3AsIHtcbiAqICAgbW9kaWZpZXJzOiB7XG4gKiAgICAgcHJldmVudE92ZXJmbG93OiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIERlZmF1bHRzID0ge1xuICAvKipcbiAgICogUG9wcGVyJ3MgcGxhY2VtZW50LlxuICAgKiBAcHJvcCB7UG9wcGVyLnBsYWNlbWVudHN9IHBsYWNlbWVudD0nYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAvKipcbiAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCBwb3BwZXIgdG8gcG9zaXRpb24gaXQgc2VsZiBpbiAnZml4ZWQnIG1vZGVcbiAgICogQHByb3Age0Jvb2xlYW59IHBvc2l0aW9uRml4ZWQ9ZmFsc2VcbiAgICovXG4gIHBvc2l0aW9uRml4ZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGV2ZW50cyAocmVzaXplLCBzY3JvbGwpIGFyZSBpbml0aWFsbHkgZW5hYmxlZC5cbiAgICogQHByb3Age0Jvb2xlYW59IGV2ZW50c0VuYWJsZWQ9dHJ1ZVxuICAgKi9cbiAgZXZlbnRzRW5hYmxlZDogdHJ1ZSxcblxuICAvKipcbiAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZW1vdmUgdGhlIHBvcHBlciB3aGVuXG4gICAqIHlvdSBjYWxsIHRoZSBgZGVzdHJveWAgbWV0aG9kLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcmVtb3ZlT25EZXN0cm95PWZhbHNlXG4gICAqL1xuICByZW1vdmVPbkRlc3Ryb3k6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIGNyZWF0ZWQuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uQ3JlYXRlfVxuICAgKi9cbiAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgdXBkYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBub3QgY2FsbGVkXG4gICAqIG9uIHRoZSBpbml0aWFsaXphdGlvbi9jcmVhdGlvbiBvZiB0aGUgcG9wcGVyLCBidXQgb25seSBvbiBzdWJzZXF1ZW50XG4gICAqIHVwZGF0ZXMuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uVXBkYXRlfVxuICAgKi9cbiAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgbW9kaWZpZXJzIHVzZWQgdG8gbW9kaWZ5IHRoZSBvZmZzZXRzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuXG4gICAqIFRoZXkgcHJvdmlkZSBtb3N0IG9mIHRoZSBmdW5jdGlvbmFsaXRpZXMgb2YgUG9wcGVyLmpzLlxuICAgKiBAcHJvcCB7bW9kaWZpZXJzfVxuICAgKi9cbiAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIG9uQ3JlYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBvblVwZGF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLy8gVXRpbHNcbi8vIE1ldGhvZHNcbnZhciBQb3BwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFBvcHBlci5qcyBpbnN0YW5jZS5cbiAgICogQGNsYXNzIFBvcHBlclxuICAgKiBAcGFyYW0ge0VsZW1lbnR8cmVmZXJlbmNlT2JqZWN0fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgLyBYTUwgZWxlbWVudCB1c2VkIGFzIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBZb3VyIGN1c3RvbSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBvbmVzIGRlZmluZWQgaW4gW0RlZmF1bHRzXSgjZGVmYXVsdHMpXG4gICAqIEByZXR1cm4ge09iamVjdH0gaW5zdGFuY2UgLSBUaGUgZ2VuZXJhdGVkIFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQb3BwZXIpO1xuXG4gICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMudXBkYXRlKTtcbiAgICB9O1xuXG4gICAgLy8gbWFrZSB1cGRhdGUoKSBkZWJvdW5jZWQsIHNvIHRoYXQgaXQgb25seSBydW5zIGF0IG1vc3Qgb25jZS1wZXItdGlja1xuICAgIHRoaXMudXBkYXRlID0gZGVib3VuY2UodGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG5cbiAgICAvLyB3aXRoIHt9IHdlIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3B0aW9ucyBpbnNpZGUgaXRcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgIC8vIGluaXQgc3RhdGVcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgICAgaXNDcmVhdGVkOiBmYWxzZSxcbiAgICAgIHNjcm9sbFBhcmVudHM6IFtdXG4gICAgfTtcblxuICAgIC8vIGdldCByZWZlcmVuY2UgYW5kIHBvcHBlciBlbGVtZW50cyAoYWxsb3cgalF1ZXJ5IHdyYXBwZXJzKVxuICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5qcXVlcnkgPyByZWZlcmVuY2VbMF0gOiByZWZlcmVuY2U7XG4gICAgdGhpcy5wb3BwZXIgPSBwb3BwZXIgJiYgcG9wcGVyLmpxdWVyeSA/IHBvcHBlclswXSA6IHBvcHBlcjtcblxuICAgIC8vIERlZXAgbWVyZ2UgbW9kaWZpZXJzIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMubW9kaWZpZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnMsIG9wdGlvbnMubW9kaWZpZXJzKSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVyc1tuYW1lXSB8fCB7fSwgb3B0aW9ucy5tb2RpZmllcnMgPyBvcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA6IHt9KTtcbiAgICB9KTtcblxuICAgIC8vIFJlZmFjdG9yaW5nIG1vZGlmaWVycycgbGlzdCAoT2JqZWN0ID0+IEFycmF5KVxuICAgIHRoaXMubW9kaWZpZXJzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLm1vZGlmaWVycykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9LCBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSk7XG4gICAgfSlcbiAgICAvLyBzb3J0IHRoZSBtb2RpZmllcnMgYnkgb3JkZXJcbiAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgIH0pO1xuXG4gICAgLy8gbW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSB3aGVuIFBvcHBlci5qcyBnZXQgaW5pdGVkXG4gICAgLy8gc3VjaCBjb2RlIGlzIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIG9mIGl0cyBtb2RpZmllclxuICAgIC8vIHRoZXkgY291bGQgYWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZWlyIG9wdGlvbnMgY29uZmlndXJhdGlvblxuICAgIC8vIEJFIEFXQVJFOiBkb24ndCBhZGQgb3B0aW9ucyB0byBgb3B0aW9ucy5tb2RpZmllcnMubmFtZWAgYnV0IHRvIGBtb2RpZmllck9wdGlvbnNgIVxuICAgIHRoaXMubW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyT3B0aW9ucykge1xuICAgICAgaWYgKG1vZGlmaWVyT3B0aW9ucy5lbmFibGVkICYmIGlzRnVuY3Rpb24obW9kaWZpZXJPcHRpb25zLm9uTG9hZCkpIHtcbiAgICAgICAgbW9kaWZpZXJPcHRpb25zLm9uTG9hZChfdGhpcy5yZWZlcmVuY2UsIF90aGlzLnBvcHBlciwgX3RoaXMub3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBfdGhpcy5zdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBmaXJlIHRoZSBmaXJzdCB1cGRhdGUgdG8gcG9zaXRpb24gdGhlIHBvcHBlciBpbiB0aGUgcmlnaHQgcGxhY2VcbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgdmFyIGV2ZW50c0VuYWJsZWQgPSB0aGlzLm9wdGlvbnMuZXZlbnRzRW5hYmxlZDtcbiAgICBpZiAoZXZlbnRzRW5hYmxlZCkge1xuICAgICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzLCB0aGV5IHdpbGwgdGFrZSBjYXJlIG9mIHVwZGF0ZSB0aGUgcG9zaXRpb24gaW4gc3BlY2lmaWMgc2l0dWF0aW9uc1xuICAgICAgdGhpcy5lbmFibGVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGV2ZW50c0VuYWJsZWQ7XG4gIH1cblxuICAvLyBXZSBjYW4ndCB1c2UgY2xhc3MgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgZG9uJ3QgZ2V0IGxpc3RlZCBpbiB0aGVcbiAgLy8gY2xhc3MgcHJvdG90eXBlIGFuZCBicmVhayBzdHVmZiBsaWtlIFNpbm9uIHN0dWJzXG5cblxuICBjcmVhdGVDbGFzcyhQb3BwZXIsIFt7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlJCQxKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95JCQxKCkge1xuICAgICAgcmV0dXJuIGRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGVuYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGRpc2FibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhbiB1cGRhdGUuIEl0IHdpbGwgcnVuIG9uIHRoZSBuZXh0IFVJIHVwZGF0ZSBhdmFpbGFibGUuXG4gICAgICogQG1ldGhvZCBzY2hlZHVsZVVwZGF0ZVxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdGlvbiBvZiB1dGlsaXRpZXMgdXNlZnVsIHdoZW4gd3JpdGluZyBjdXN0b20gbW9kaWZpZXJzLlxuICAgICAqIFN0YXJ0aW5nIGZyb20gdmVyc2lvbiAxLjcsIHRoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBvbmx5IGlmIHlvdVxuICAgICAqIGluY2x1ZGUgYHBvcHBlci11dGlscy5qc2AgYmVmb3JlIGBwb3BwZXIuanNgLlxuICAgICAqXG4gICAgICogKipERVBSRUNBVElPTioqOiBUaGlzIHdheSB0byBhY2Nlc3MgUG9wcGVyVXRpbHMgaXMgZGVwcmVjYXRlZFxuICAgICAqIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjIhIFVzZSB0aGUgUG9wcGVyVXRpbHMgbW9kdWxlIGRpcmVjdGx5IGluc3RlYWQuXG4gICAgICogRHVlIHRvIHRoZSBoaWdoIGluc3RhYmlsaXR5IG9mIHRoZSBtZXRob2RzIGNvbnRhaW5lZCBpbiBVdGlscywgd2UgY2FuJ3RcbiAgICAgKiBndWFyYW50ZWUgdGhlbSB0byBmb2xsb3cgc2VtdmVyLiBVc2UgdGhlbSBhdCB5b3VyIG93biByaXNrIVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjhcbiAgICAgKiBAbWVtYmVyIFV0aWxzXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG4gIH1dKTtcbiAgcmV0dXJuIFBvcHBlcjtcbn0oKTtcblxuLyoqXG4gKiBUaGUgYHJlZmVyZW5jZU9iamVjdGAgaXMgYW4gb2JqZWN0IHRoYXQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGNvbXBhdGlibGUgd2l0aCBQb3BwZXIuanNcbiAqIGFuZCBsZXRzIHlvdSB1c2UgaXQgYXMgcmVwbGFjZW1lbnQgb2YgYSByZWFsIERPTSBub2RlLjxiciAvPlxuICogWW91IGNhbiB1c2UgdGhpcyBtZXRob2QgdG8gcG9zaXRpb24gYSBwb3BwZXIgcmVsYXRpdmVseSB0byBhIHNldCBvZiBjb29yZGluYXRlc1xuICogaW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhIERPTSBub2RlIHRvIHVzZSBhcyByZWZlcmVuY2UuXG4gKlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZmVyZW5jZU9iamVjdCwgcG9wcGVyTm9kZSk7XG4gKiBgYGBcbiAqXG4gKiBOQjogVGhpcyBmZWF0dXJlIGlzbid0IHN1cHBvcnRlZCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMC5cbiAqIEBuYW1lIHJlZmVyZW5jZU9iamVjdFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZGF0YS5nZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2V0IG9mIGNvb3JkaW5hdGVzIGNvbXBhdGlibGUgd2l0aCB0aGUgbmF0aXZlIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudFdpZHRoXG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50SGVpZ2h0XG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqL1xuXG5cblBvcHBlci5VdGlscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCkuUG9wcGVyVXRpbHM7XG5Qb3BwZXIucGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5Qb3BwZXIuRGVmYXVsdHMgPSBEZWZhdWx0cztcblxucmV0dXJuIFBvcHBlcjtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5qcy5tYXBcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBnbG9iYWwsIGRlZmluZSwgU3lzdGVtLCBSZWZsZWN0LCBQcm9taXNlICovXHJcbnZhciBfX2V4dGVuZHM7XHJcbnZhciBfX2Fzc2lnbjtcclxudmFyIF9fcmVzdDtcclxudmFyIF9fZGVjb3JhdGU7XHJcbnZhciBfX3BhcmFtO1xyXG52YXIgX19tZXRhZGF0YTtcclxudmFyIF9fYXdhaXRlcjtcclxudmFyIF9fZ2VuZXJhdG9yO1xyXG52YXIgX19leHBvcnRTdGFyO1xyXG52YXIgX192YWx1ZXM7XHJcbnZhciBfX3JlYWQ7XHJcbnZhciBfX3NwcmVhZDtcclxudmFyIF9fc3ByZWFkQXJyYXlzO1xyXG52YXIgX19hd2FpdDtcclxudmFyIF9fYXN5bmNHZW5lcmF0b3I7XHJcbnZhciBfX2FzeW5jRGVsZWdhdG9yO1xyXG52YXIgX19hc3luY1ZhbHVlcztcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0O1xyXG52YXIgX19pbXBvcnRTdGFyO1xyXG52YXIgX19pbXBvcnREZWZhdWx0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQ7XHJcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgPyB0aGlzIDoge307XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoXCJ0c2xpYlwiLCBbXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAoZXhwb3J0cykgeyBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMpKSk7IH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKG1vZHVsZS5leHBvcnRzKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFeHBvcnRlcihleHBvcnRzLCBwcmV2aW91cykge1xyXG4gICAgICAgIGlmIChleHBvcnRzICE9PSByb290KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQsIHYpIHsgcmV0dXJuIGV4cG9ydHNbaWRdID0gcHJldmlvdXMgPyBwcmV2aW91cyhpZCwgdikgOiB2OyB9O1xyXG4gICAgfVxyXG59KVxyXG4oZnVuY3Rpb24gKGV4cG9ydGVyKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVzdCA9IGZ1bmN0aW9uIChzLCBlKSB7XHJcbiAgICAgICAgdmFyIHQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19kZWNvcmF0ZSA9IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgICAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcGFyYW0gPSBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fbWV0YWRhdGEgPSBmdW5jdGlvbiAobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ZXIgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgX19nZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICAgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2V4cG9ydFN0YXIgPSBmdW5jdGlvbiAobSwgZXhwb3J0cykge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH07XHJcblxyXG4gICAgX192YWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICAgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICAgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVhZCA9IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICAgICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fc3ByZWFkQXJyYXlzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNHZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgaSwgcDtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY1ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCA9IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICAgICAgcmV0dXJuIGNvb2tlZDtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnRTdGFyID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICAgICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2ltcG9ydERlZmF1bHQgPSBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICAgICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcclxuICAgICAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgcHJpdmF0ZU1hcCwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3NpZ25cIiwgX19hc3NpZ24pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3Jlc3RcIiwgX19yZXN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlKTtcclxuICAgIGV4cG9ydGVyKFwiX19wYXJhbVwiLCBfX3BhcmFtKTtcclxuICAgIGV4cG9ydGVyKFwiX19tZXRhZGF0YVwiLCBfX21ldGFkYXRhKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcik7XHJcbiAgICBleHBvcnRlcihcIl9fZ2VuZXJhdG9yXCIsIF9fZ2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19leHBvcnRTdGFyXCIsIF9fZXhwb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9fdmFsdWVzXCIsIF9fdmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZWFkXCIsIF9fcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkXCIsIF9fc3ByZWFkKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheXNcIiwgX19zcHJlYWRBcnJheXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2F3YWl0XCIsIF9fYXdhaXQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jR2VuZXJhdG9yXCIsIF9fYXN5bmNHZW5lcmF0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jRGVsZWdhdG9yXCIsIF9fYXN5bmNEZWxlZ2F0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jVmFsdWVzXCIsIF9fYXN5bmNWYWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX21ha2VUZW1wbGF0ZU9iamVjdFwiLCBfX21ha2VUZW1wbGF0ZU9iamVjdCk7XHJcbiAgICBleHBvcnRlcihcIl9faW1wb3J0U3RhclwiLCBfX2ltcG9ydFN0YXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2ltcG9ydERlZmF1bHRcIiwgX19pbXBvcnREZWZhdWx0KTtcclxuICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZEdldFwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KTtcclxuICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZFNldFwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KTtcclxufSk7XHJcbiJdfQ==
;