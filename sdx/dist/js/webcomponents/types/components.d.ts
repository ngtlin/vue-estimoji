/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "./stencil-public-runtime";
import { ArrowDirection, ArrowPosition, } from "./components/accordion/types";
import { BackgroundTheme, ButtonTheme, CSSRules, Display, FlipDirection, } from "./core/types/types";
import { AnimationName, } from "./components/animation/types";
import { Size, } from "./components/icon/types";
import { ButtonGroupLayout, ButtonType, } from "./components/button/types";
import { Color, } from "./components/color-picker/types";
import { InputType, } from "./components/input/types";
import { InputItemType, Theme, } from "./components/input-item/types";
import { Direction, } from "./components/menu-flyout/types";
import { Option, } from "./components/option-picker/types";
import { PieChartDataPoint, } from "./components/pie-chart/types";
import { Size as Size1, } from "./components/price/types";
import { Status, StepPosition, } from "./components/progress-full/types";
import { Design, Position, Size as Size2, } from "./components/ribbon/types";
import { Position as Position1, } from "./components/scroll-to-top/types";
import { KeyboardBehavior, } from "./components/select/types";
export namespace Components {
    interface SdxAccordion {
        /**
          * Position of the arrow in the header.
         */
        "arrowPosition": ArrowPosition;
        /**
          * Closes the accordion item.
          * @param index Index of the accordion item.
         */
        "close": (index: number) => Promise<void>;
        /**
          * Closes all accordion items.
         */
        "closeAll": () => Promise<void>;
        /**
          * @private
         */
        "componentStyle": CSSRules;
        /**
          * Allow to keep multiple accordion items opened.
         */
        "keepOpen": boolean;
        /**
          * Opens the accordion item.
          * @param index Index of the accordion item.
         */
        "open": (index: number) => Promise<void>;
        /**
          * Opens all accordion items.
         */
        "openAll": () => Promise<void>;
        /**
          * Toggle display of the accordion item.
          * @param index Index of the accordion item.
         */
        "toggle": (index: number) => Promise<void>;
    }
    interface SdxAccordionArrow {
        /**
          * @private
         */
        "arrowPosition": ArrowPosition;
        /**
          * @private
         */
        "direction": ArrowDirection;
        /**
          * @private
         */
        "hover": boolean;
    }
    interface SdxAccordionItem {
        /**
          * If the accordion item is initially open.
         */
        "open": boolean;
    }
    interface SdxAccordionItemBody {
        /**
          * @private
         */
        "arrowPosition": ArrowPosition;
        /**
          * @private
         */
        "componentStyle": CSSRules;
        /**
          * Toggles body directly when initial load or with an animation.
          * @param isOpen Open state of the accordion item.
         */
        "toggle": (isOpen: boolean) => Promise<void>;
    }
    interface SdxAccordionItemHeader {
        /**
          * @private
         */
        "arrowPosition": ArrowPosition;
        /**
          * @private
         */
        "buttonStyle": CSSRules;
        /**
          * Closes this accordion item.
         */
        "closeItem": () => Promise<void>;
        /**
          * @private
         */
        "expand": boolean;
        /**
          * Opens this accordion item.
         */
        "openItem": () => Promise<void>;
        /**
          * Triggers toggle information in accordion
         */
        "toggle": () => void;
    }
    interface SdxAccordionItemSection {
    }
    interface SdxAnimation {
        /**
          * Callback that will fire when the animation starts.
         */
        "animationBeginCallback": (() => void);
        /**
          * The animation to play.
         */
        "animationName"?: AnimationName;
    }
    interface SdxArrow {
        /**
          * Callback that will fire when the animation starts.
         */
        "animationBeginCallback": (() => void);
        /**
          * Which side it looks towards.
         */
        "direction": "down" | "up" | "left" | "right";
        /**
          * Hide the arrow (animated).
         */
        "hideArrow": boolean;
        /**
          * Hide the background.
         */
        "hideBackground": boolean;
    }
    interface SdxButton {
        /**
          * Value for aria-expanded that will be applied to the button element. Used for buttons that trigger expanding/collapsing such as an accordion, dropdown menu or tooltip.
         */
        "ariaExpandedOnButton"?: boolean;
        /**
          * Background theme. Use "dark" to make button colorless, whenever it is used on a colored or dark background (single color or image).
         */
        "background": BackgroundTheme;
        /**
          * Button disabled.
         */
        "disabled": boolean;
        /**
          * "href" when used as a link looking like a button.
         */
        "href": string;
        /**
          * Which icon to display.
         */
        "iconName": string;
        /**
          * Size of the displayed icon. Can only be modified when theme="transparent". Font-size will be adjusted automatically.
         */
        "iconSize": Size;
        /**
          * Button text.
         */
        "label": string;
        /**
          * Description text read by the screen reader. Will be appended to the button content.
         */
        "srHint": string;
        /**
          * "target" when used as a link looking like a button.
         */
        "target"?: string;
        /**
          * Button theme. For further information about the different themes, see designers' section: https://sdx.swisscom.ch/components_-_buttons.html#design
         */
        "theme": ButtonTheme;
        /**
          * Button type.
         */
        "type": ButtonType;
        /**
          * @private only used for icon-buttons within input fields such as numeric stepper, search, select, datepicker etc.
         */
        "valid"?: boolean;
    }
    interface SdxButtonGroup {
        /**
          * Defines how buttons are aligned, sized and distributed.
         */
        "layout": ButtonGroupLayout;
    }
    interface SdxColorPicker {
        /**
          * Callback when the checking an option.
         */
        "changeCallback": ((selection: string[]) => void) | string | undefined;
        /**
          * List of selectable colors.
         */
        "colors": Color[] | string;
        /**
          * Enable multi select.
         */
        "multiple": boolean;
    }
    interface SdxDummy {
    }
    interface SdxExpandAndCollapse {
        /**
          * Label that shows when the component is expanded and ready to be collapsed.
         */
        "collapseLabel": string;
        /**
          * Label that shows when the component is collapsed and ready to be expanded.
         */
        "expandLabel": string;
    }
    interface SdxFlip {
        /**
          * Mirror the content across one or both axes (or none at all).
         */
        "direction": FlipDirection;
    }
    interface SdxIcon {
        /**
          * SDX predefined color class.
         */
        "colorClass": string;
        /**
          * Mirror the icon.
         */
        "flip": FlipDirection;
        /**
          * Hide the icon (animated).
         */
        "hidden": boolean;
        /**
          * Name of the SDX icon (e.g. "icon-clear-circle").
         */
        "iconName": string;
        /**
          * The dimension of the icon.
         */
        "size": Size;
        /**
          * Description text read by the screen reader.
         */
        "srHint": string;
    }
    interface SdxInput {
        /**
          * Specifies the input fields native autocomplete behavior on modern browsers (e.g. "off", "username" or "new-password").
         */
        "autocomplete"?: string;
        /**
          * Callback that will fire when the input loses focus.
         */
        "blurCallback"?: (() => void) | string;
        /**
          * Callback that will fire when the value has changed, regardless of method (keyboard or programmatical).
         */
        "changeCallback"?: ((value: string) => void) | string;
        /**
          * Disabled and not focussable using tab.
         */
        "disabled": boolean;
        /**
          * @private Renders a div that looks exactly like an input field. Overflowing content will have an ellipsis. Only implemented for `type="text"`.
         */
        "editable": boolean;
        /**
          * Datepicker settings. When <code>type="date"</code>, flatpickr is used and can be configured via this attribute. Examples: <code>{ locale: "fr" }</code>, <code>{ minDate: "today" }</code> or <code>{ "altInput": true, "altFormat": "l j. F, Y" }</code>. See available options: https://sdx.swisscom.com/components_-_picker_(date).html
         */
        "flatpickrOptions": any;
        /**
          * Callback that will fire when the input gets focus.
         */
        "focusCallback"?: (() => void) | string;
        /**
          * Callback that will fire on hitting enter.
         */
        "hitEnterCallback"?: (() => void) | string;
        /**
          * Callback that will fire when the value changes using the keyboard.
         */
        "inputCallback"?: ((value: string) => void) | string;
        /**
          * @private CSS styles applied to the input element.
         */
        "inputStyle": {
            [key: string]: string;
        };
        /**
          * Callback that will fire when the a key is pressed down.
         */
        "keyDownCallback"?: ((e: Event) => void) | string;
        /**
          * Text that will be written on the top.
         */
        "label": string;
        /**
          * For input type="number", maximum valid input value.
         */
        "max"?: number;
        /**
          * Allowed number of characters.
         */
        "maxlength"?: number;
        /**
          * For input type="number", minimum valid input value.
         */
        "min"?: number;
        /**
          * Name parameter (useful when the item is embedded in a traditional HTML form submit).
         */
        "name"?: string;
        /**
          * Default text that will be shown unless there's a value.
         */
        "placeholder": string;
        /**
          * Disabled, but focussable using tab.
         */
        "readonly": boolean;
        /**
          * Marks the component as required (please note that this itself does not handle validation &mdash; use the "valid" and "validation-message" for that).
         */
        "required": boolean;
        /**
          * Marks the text within the input on focus.
         */
        "selectTextOnFocus": boolean;
        /**
          * Text for the screen reader labelling the input field.
         */
        "srHint": string;
        /**
          * For input type="number", step size.
         */
        "step"?: number;
        /**
          * Default input field type (e.g. "search", "password", "date", etc.). When set to "date", flatpickr will take over. Caution: flatpickr does not fulfill the accessibility requirements of SDX, yet (but we're on it...).
         */
        "type": InputType;
        /**
          * Set this to false to declare the component as invalid (and use the "validation-message" attribute to explain why). It can also be set to true, but this should only be done in rare cases (e.g. when checking a user name for availabilty using server-side validation).
         */
        "valid"?: boolean;
        /**
          * Text that explains the validation status to the user.
         */
        "validationMessage"?: string;
        /**
          * Can be used for both reading and writing the value.
         */
        "value": string;
    }
    interface SdxInputGroup {
        /**
          * Callback when the checking an option.
         */
        "changeCallback": ((selection: any[]) => void) | string | undefined;
        /**
          * @deprecated read the "value" prop instead Returns the current selection.
         */
        "getSelection": () => Promise<any[]>;
        /**
          * Display all input items in a row (for maximum two items &mdash; more items should be embedded in a grid).
         */
        "inline": boolean;
        /**
          * Label of the input group.
         */
        "label": string;
        /**
          * Name parameter (useful when the item is embedded in a traditional HTML form submit).
         */
        "name": string;
        /**
          * Marks the component as required (please note that this itself does not handle validation &mdash; use the "valid" and "validation-message" for that).
         */
        "required": boolean;
        /**
          * Styling theme for the input items within this group.
         */
        "theme": Theme;
        /**
          * The form input variant of the item.
         */
        "type": InputItemType;
        /**
          * Set this to false to declare the component as invalid (and use the "validation-message" attribute to explain why).
         */
        "valid"?: boolean;
        /**
          * Text that explains the validation status to the user.
         */
        "validationMessage"?: string;
        /**
          * The value(s) of the currently checked items(s). Please note that this is always an array, even when type="checkbox", for both getting and setting the value <code>(e.g. myGroup.value = [ "value1" ])</code>). Note that when being used for setting the initial value, the "checked" attribute on the <code>&lt;sdx-input-item /&gt;</code> has the higher priority.
         */
        "value": any[];
    }
    interface SdxInputItem {
        /**
          * Callback whenever the user checks/unchecks the component.
         */
        "changeCallback"?: ((checked: boolean) => void) | string;
        /**
          * Whether the item is turned on or off.
         */
        "checked": boolean;
        /**
          * Make sure that the input item does not receive focus. Use this when the input item is used within a component that already handles focus (e.g. sdx-select-option in sdx-select with multiselect).
         */
        "disableFocus": boolean;
        /**
          * Not selectable.
         */
        "disabled": boolean;
        /**
          * @private Hide the checkbox or radio checked indicator icon.
         */
        "hideCheckedIcon": boolean;
        /**
          * Icon name of the icon inside the container variation.
         */
        "iconName"?: string;
        /**
          * Icon size of the icon inside the container variation.
         */
        "iconSize"?: Size;
        /**
          * @private
         */
        "labelStyle": CSSRules;
        /**
          * Name parameter (useful when the item is embedded in a traditional HTML form submit).
         */
        "name"?: string;
        /**
          * Marks the component as required (please note that this itself does not handle validation &mdash; use the "valid" and "validation-message" for that).
         */
        "required": boolean;
        /**
          * The form input type of the item (radio or checkbox).
         */
        "type": InputItemType;
        /**
          * Set this to false to declare the component as invalid (and use the "validation-message" attribute to explain why).
         */
        "valid"?: boolean;
        /**
          * Text that explains the validation status to the user.
         */
        "validationMessage"?: string;
        /**
          * The current value.
         */
        "value": any;
    }
    interface SdxItunesAutocomplete {
    }
    interface SdxLoadingSpinner {
        /**
          * Dimension of the spinner.
         */
        "size": "small" | "large";
        /**
          * Description text read by the screen reader.
         */
        "srHint": string;
    }
    interface SdxMenuFlyout {
        /**
          * Closes the flyout.
         */
        "close": () => Promise<void>;
        /**
          * Close if the user clicks on the flyout.
         */
        "closeOnClick": boolean;
        /**
          * In which direction the flyout opens.
         */
        "direction": Direction;
        /**
          * Callback that will fire after the flyouts display status has changed.
         */
        "displayChangeCallback"?: ((display: Display) => void) | string;
        /**
          * Opens the flyout.
         */
        "open": () => Promise<void>;
        /**
          * Toggles the flyout.
         */
        "toggle": () => Promise<void>;
    }
    interface SdxMenuFlyoutContent {
    }
    interface SdxMenuFlyoutCta {
        /**
          * Width of the flyout. If none is set, the Flyout grows dynamically (up to a certain point) based on the content.
         */
        "size": "small" | "medium" | "large" | "auto";
    }
    interface SdxMenuFlyoutList {
    }
    interface SdxMenuFlyoutListItem {
        /**
          * Whether the item is disabled.
         */
        "disabled": boolean;
        /**
          * The URL this item should link to (if itâ€™s a regular link not handled by JS).
         */
        "href": string;
        /**
          * Optional language of the page the URL points to
         */
        "hreflang": string;
        /**
          * If the item is not selectable, it is neither highlighted nor has it cursor: pointer.
         */
        "selectable": boolean;
    }
    interface SdxMenuFlyoutToggle {
    }
    interface SdxNumericStepper {
        /**
          * Callback that will fire on change.
         */
        "changeCallback"?: ((value: string) => void) | string;
        /**
          * Disabled and not focusable using tab.
         */
        "disabled": boolean;
        /**
          * Text that will be written on the top of the numeric stepper. Make sure to include the maximum possible value here for the user.
         */
        "label": string;
        /**
          * Maximum value. Cannot be set greater than 999.
         */
        "max": number;
        /**
          * Minimum value. Cannot be negative.
         */
        "min": number;
        /**
          * Text for the screen reader describing the numeric stepper.
         */
        "srHint": string;
        /**
          * Step size.
         */
        "step": number;
        /**
          * Set this to false to declare the component as invalid (and use the "validation-message" attribute to explain why). It can also be set to true, but this should only be done in rare cases (e.g. when checking a user name for availabilty using server-side validation).
         */
        "valid"?: boolean;
        /**
          * Text that explains the validation status to the user.
         */
        "validationMessage"?: string;
        /**
          * Initial value. Must be between 0 and 999 including.
         */
        "value": number | undefined;
    }
    interface SdxOptionPicker {
        /**
          * Callback when the checking an option.
         */
        "changeCallback": ((selection: any[]) => void) | string | undefined;
        /**
          * Enable multi select.
         */
        "multiple": boolean;
        /**
          * List of selectable options.
         */
        "options": Option[] | string;
    }
    interface SdxPieChart {
        /**
          * Background color scheme.
         */
        "backgroundTheme": BackgroundTheme;
        /**
          * The values to display.
         */
        "data": PieChartDataPoint[] | string;
        /**
          * Description text of what is displayed (e.g. "Storage" or "Available"). This does not appear in the "small" version.
         */
        "description"?: string;
        /**
          * Where to render the labels.
         */
        "legendPosition": "bottom" | "right";
        /**
          * Dimension of the chart.
         */
        "size": "small" | "medium";
        /**
          * Text that contains the relevant information (e.g. "100 %"). It will be displayed in the center of the chart.
         */
        "value": string;
    }
    interface SdxPrice {
        /**
          * The amount to be paid.
         */
        "amount": number;
        /**
          * Time period, for example "/mo.".
         */
        "period": string;
        /**
          * The font size.
         */
        "size": Size;
        /**
          * Description text read by the screen reader.
         */
        "srHint": string;
    }
    interface SdxProgressFull {
        /**
          * @private Disable animations for testing.
         */
        "animated": boolean;
        /**
          * Get the current active step.
         */
        "getActiveStep": () => Promise<number>;
        /**
          * Move to next step if its available.
         */
        "nextStep": () => Promise<void>;
        /**
          * Move to previous step if its available.
         */
        "previousStep": () => Promise<void>;
        /**
          * Set a step as active based on an index.
          * @param index Index of the new active step.
          * @param animation Allow animations when moving between steps.
         */
        "setActiveStep": (index: number, animation: boolean) => Promise<void>;
        /**
          * Current active step of the progress bar.
         */
        "step": number;
        /**
          * Triggered when the active step was changed.
         */
        "stepChangeCallback"?: ((activeStep: number, previousActiveStep?: number) => void) | string;
        /**
          * Label used next to total amount of steps when not all steps are being displayed.
         */
        "stepsLabel": string;
    }
    interface SdxProgressFullStep {
        /**
          * @private
         */
        "position": StepPosition;
        /**
          * @private
         */
        "status": Status;
        /**
          * Triggered when a user clicks on the button or description of a completed step.
         */
        "stepClickCallback"?: (() => void) | string;
        /**
          * @private
         */
        "value": number;
    }
    interface SdxRibbon {
        /**
          * Look.
         */
        "design": Design;
        /**
          * Text content.
         */
        "label": string;
        /**
          * Location.
         */
        "position": Position;
        /**
          * Dimension.
         */
        "size": Size;
    }
    interface SdxScrollToTop {
        /**
          * @private
         */
        "demo": boolean;
        /**
          * @private
         */
        "position": Position;
    }
    interface SdxSearch {
        /**
          * Callback that will fire when the value has changed, regardless of method (keyboard or programmatical).
         */
        "changeCallback"?: ((value: string) => void) | string;
        /**
          * Default text that will disappear on type.
         */
        "placeholder": string;
        /**
          * Callback that will fire on hitting enter or on clicking the button.
         */
        "searchSubmitCallback"?: ((value: string) => void) | string;
        /**
          * Text for the screen reader labelling the search input field.
         */
        "srHint": string;
        /**
          * Button text for the screen reader to read in place of the search icon.
         */
        "srHintForButton": string;
        /**
          * Can be used for both reading and writing the value.
         */
        "value": string;
        /**
          * @private Deprecated, use "changeCallback" Callback that will fire when the value has changed, regardless of method (keyboard or programmatical). Same as changeCallback.
         */
        "valueChangeCallback"?: ((value: string) => void) | string;
    }
    interface SdxSelect {
        /**
          * @private Disable animations for testing.
         */
        "animated": boolean;
        /**
          * Background color scheme.
         */
        "backgroundTheme": BackgroundTheme;
        /**
          * Callback that will fire when the input loses focus. Used when "keyboard-behavior" is "filter" or "autocomplete".
         */
        "blurCallback"?: (() => void) | string;
        /**
          * Callback when user selects an option (or types something while in "autocomplete" mode).
         */
        "changeCallback"?: ((selection: any[]) => void) | string;
        /**
          * Closes the sdx-select.
         */
        "close": () => Promise<void>;
        /**
          * Disables the sdx-select.
         */
        "disabled": boolean;
        /**
          * Function that decides whether an option element matches a filter by returning true or false. Defaults to a function that performs a simple string match test on the option elements textContent property. Used when "keyboard-behavior" is "filter" or "autocomplete".
         */
        "filterFunction"?: ((optionEl: HTMLSdxSelectOptionElement, keyword: string) => boolean) | string;
        /**
          * @private Deprecated, use "keyboard-behavior" Filter the options of the sdx-select by typing. Shortcut for keyboard-behavior="filter"
         */
        "filterable": boolean;
        /**
          * Callback that will fire when the input gets focus. Used when "keyboard-behavior" is "filter" or "autocomplete".
         */
        "focusCallback"?: (() => void) | string;
        /**
          * @deprecated read the "value" prop instead Returns the current selection.
         */
        "getSelection": () => Promise<any[]>;
        /**
          * How the component should behave when the user types something on the keyboard. "focus" jumps to and focuses the option starting with the typed character. "filter" lists only options (and optgroups) that match the entered keyword. "autocomplete" is similar to "filter", but makes the component behave more like an input field, e.g. the "value" reflects the content of the filter and there is no thumb to open or close.
         */
        "keyboardBehavior": KeyboardBehavior;
        /**
          * Will be written on the top of the sdx-select.
         */
        "label": string;
        /**
          * Shows a loading spinner and disables the sdx-select.
         */
        "loading": boolean;
        /**
          * Maximum dropdown height (e.g. "300px"), supported units are "px" and "vh". If no unit is provided, "px" will be used.
         */
        "maxHeight"?: string | number;
        /**
          * Enable multi select.
         */
        "multiple": boolean;
        /**
          * Name parameter (useful when the item is embedded in a traditional HTML form submit).
         */
        "name"?: string;
        /**
          * Label for "no matches found".
         */
        "noMatchesFoundLabel": string;
        /**
          * Opens the sdx-select.
         */
        "open": () => Promise<void>;
        /**
          * Text to be displayed when nothing is selected.
         */
        "placeholder": string;
        /**
          * Marks the component as required (please note that this itself does not handle validation &mdash; use the "valid" and "validation-message" for that).
         */
        "required": boolean;
        /**
          * Callback when user selects an option (and the select is *not* in "autocomplete" mode).
         */
        "selectCallback"?: ((selection: any[]) => void) | string;
        /**
          * Description text read by the screen reader.
         */
        "srHint": string;
        /**
          * Toggles the sdx-select.
         */
        "toggle": () => Promise<void>;
        /**
          * Set this to false to declare the component as invalid (note that this only works with when the "validation-message" attribute is set - and vice versa).
         */
        "valid"?: boolean;
        /**
          * Text that explains the validation status to the user.
         */
        "validationMessage"?: string;
        /**
          * The value(s) of the currently selected option(s). Please note that this is always an array, even without the "multiple" attribute, for both getting and setting the value <code>(e.g. mySelect.value = [ "value1" ])</code>). Note that when being used for setting the initial value, the "selected" attribute on the <code>&lt;sdx-select-option /&gt;</code> has the higher priority.
         */
        "value": any[];
    }
    interface SdxSelectOptgroup {
        /**
          * Label of the group to be displayed.
         */
        "name": string;
    }
    interface SdxSelectOption {
        /**
          * Not selectable (event propagation will be stopped).
         */
        "disabled": boolean;
        /**
          * @private Whether this option is the placeholder element.
         */
        "placeholder": boolean;
        /**
          * Whether this option is initially selected.
         */
        "selected": boolean;
        /**
          * Value of the option that will be returned in the selection.
         */
        "value": any;
    }
    interface SdxShowMore {
        /**
          * Button theme.
         */
        "buttonTheme": ButtonTheme;
        /**
          * Label for "from".
         */
        "fromLabel": string;
        /**
          * How many items to add by each turn.
         */
        "incrementBy": number;
        /**
          * Triggered when the number of displayed items has incremented.
         */
        "incrementCallback"?: ((count: number) => void) | string;
        /**
          * Number of items to start from.
         */
        "initialItems": number;
        /**
          * Label for "more".
         */
        "moreLabel": string;
        /**
          * Number of all items in total.
         */
        "totalItems": number;
    }
    interface SdxStickerCircle {
        /**
          * SDX predefined color class (or transparent) for the sticker background.
         */
        "bgColorClass": string;
        /**
          * Offset from the bottom edge, in % of the content's height.
         */
        "bottom"?: number;
        /**
          * SDX predefined color class for the text and border.
         */
        "colorClass": string;
        /**
          * The content width at which the sticker should be normal size (nonscaled).
         */
        "contentWidth"?: number;
        /**
          * Offset from the left edge, in % of the content's width.
         */
        "left"?: number;
        /**
          * Offset from the right edge, in % of the content's width.
         */
        "right"?: number;
        /**
          * The size (diameter) in px.
         */
        "size": number;
        /**
          * Description text read by the screen reader.
         */
        "srHint": string;
        /**
          * Offset from the top edge, in % of the content's height.
         */
        "top"?: number;
    }
    interface SdxTabs {
        /**
          * Callback that will fire when the active tab has changed. Provides the active tab DOM node.
         */
        "changeCallback"?: ((activeTab: Node) => void) | string;
    }
    interface SdxTabsItem {
        /**
          * The tab is not selectable.
         */
        "disabled": boolean;
        /**
          * Which icon to display.
         */
        "iconName": string;
        /**
          * Title of the tab.
         */
        "label": string;
        /**
          * The tab is active.
         */
        "selected": boolean;
    }
    interface SdxTextTruncate {
    }
    interface SdxValidationMessage {
        "valid": boolean;
        "validationMessage": string;
    }
}
declare global {
    interface HTMLSdxAccordionElement extends Components.SdxAccordion, HTMLStencilElement {
    }
    var HTMLSdxAccordionElement: {
        prototype: HTMLSdxAccordionElement;
        new (): HTMLSdxAccordionElement;
    };
    interface HTMLSdxAccordionArrowElement extends Components.SdxAccordionArrow, HTMLStencilElement {
    }
    var HTMLSdxAccordionArrowElement: {
        prototype: HTMLSdxAccordionArrowElement;
        new (): HTMLSdxAccordionArrowElement;
    };
    interface HTMLSdxAccordionItemElement extends Components.SdxAccordionItem, HTMLStencilElement {
    }
    var HTMLSdxAccordionItemElement: {
        prototype: HTMLSdxAccordionItemElement;
        new (): HTMLSdxAccordionItemElement;
    };
    interface HTMLSdxAccordionItemBodyElement extends Components.SdxAccordionItemBody, HTMLStencilElement {
    }
    var HTMLSdxAccordionItemBodyElement: {
        prototype: HTMLSdxAccordionItemBodyElement;
        new (): HTMLSdxAccordionItemBodyElement;
    };
    interface HTMLSdxAccordionItemHeaderElement extends Components.SdxAccordionItemHeader, HTMLStencilElement {
    }
    var HTMLSdxAccordionItemHeaderElement: {
        prototype: HTMLSdxAccordionItemHeaderElement;
        new (): HTMLSdxAccordionItemHeaderElement;
    };
    interface HTMLSdxAccordionItemSectionElement extends Components.SdxAccordionItemSection, HTMLStencilElement {
    }
    var HTMLSdxAccordionItemSectionElement: {
        prototype: HTMLSdxAccordionItemSectionElement;
        new (): HTMLSdxAccordionItemSectionElement;
    };
    interface HTMLSdxAnimationElement extends Components.SdxAnimation, HTMLStencilElement {
    }
    var HTMLSdxAnimationElement: {
        prototype: HTMLSdxAnimationElement;
        new (): HTMLSdxAnimationElement;
    };
    interface HTMLSdxArrowElement extends Components.SdxArrow, HTMLStencilElement {
    }
    var HTMLSdxArrowElement: {
        prototype: HTMLSdxArrowElement;
        new (): HTMLSdxArrowElement;
    };
    interface HTMLSdxButtonElement extends Components.SdxButton, HTMLStencilElement {
    }
    var HTMLSdxButtonElement: {
        prototype: HTMLSdxButtonElement;
        new (): HTMLSdxButtonElement;
    };
    interface HTMLSdxButtonGroupElement extends Components.SdxButtonGroup, HTMLStencilElement {
    }
    var HTMLSdxButtonGroupElement: {
        prototype: HTMLSdxButtonGroupElement;
        new (): HTMLSdxButtonGroupElement;
    };
    interface HTMLSdxColorPickerElement extends Components.SdxColorPicker, HTMLStencilElement {
    }
    var HTMLSdxColorPickerElement: {
        prototype: HTMLSdxColorPickerElement;
        new (): HTMLSdxColorPickerElement;
    };
    interface HTMLSdxDummyElement extends Components.SdxDummy, HTMLStencilElement {
    }
    var HTMLSdxDummyElement: {
        prototype: HTMLSdxDummyElement;
        new (): HTMLSdxDummyElement;
    };
    interface HTMLSdxExpandAndCollapseElement extends Components.SdxExpandAndCollapse, HTMLStencilElement {
    }
    var HTMLSdxExpandAndCollapseElement: {
        prototype: HTMLSdxExpandAndCollapseElement;
        new (): HTMLSdxExpandAndCollapseElement;
    };
    interface HTMLSdxFlipElement extends Components.SdxFlip, HTMLStencilElement {
    }
    var HTMLSdxFlipElement: {
        prototype: HTMLSdxFlipElement;
        new (): HTMLSdxFlipElement;
    };
    interface HTMLSdxIconElement extends Components.SdxIcon, HTMLStencilElement {
    }
    var HTMLSdxIconElement: {
        prototype: HTMLSdxIconElement;
        new (): HTMLSdxIconElement;
    };
    interface HTMLSdxInputElement extends Components.SdxInput, HTMLStencilElement {
    }
    var HTMLSdxInputElement: {
        prototype: HTMLSdxInputElement;
        new (): HTMLSdxInputElement;
    };
    interface HTMLSdxInputGroupElement extends Components.SdxInputGroup, HTMLStencilElement {
    }
    var HTMLSdxInputGroupElement: {
        prototype: HTMLSdxInputGroupElement;
        new (): HTMLSdxInputGroupElement;
    };
    interface HTMLSdxInputItemElement extends Components.SdxInputItem, HTMLStencilElement {
    }
    var HTMLSdxInputItemElement: {
        prototype: HTMLSdxInputItemElement;
        new (): HTMLSdxInputItemElement;
    };
    interface HTMLSdxItunesAutocompleteElement extends Components.SdxItunesAutocomplete, HTMLStencilElement {
    }
    var HTMLSdxItunesAutocompleteElement: {
        prototype: HTMLSdxItunesAutocompleteElement;
        new (): HTMLSdxItunesAutocompleteElement;
    };
    interface HTMLSdxLoadingSpinnerElement extends Components.SdxLoadingSpinner, HTMLStencilElement {
    }
    var HTMLSdxLoadingSpinnerElement: {
        prototype: HTMLSdxLoadingSpinnerElement;
        new (): HTMLSdxLoadingSpinnerElement;
    };
    interface HTMLSdxMenuFlyoutElement extends Components.SdxMenuFlyout, HTMLStencilElement {
    }
    var HTMLSdxMenuFlyoutElement: {
        prototype: HTMLSdxMenuFlyoutElement;
        new (): HTMLSdxMenuFlyoutElement;
    };
    interface HTMLSdxMenuFlyoutContentElement extends Components.SdxMenuFlyoutContent, HTMLStencilElement {
    }
    var HTMLSdxMenuFlyoutContentElement: {
        prototype: HTMLSdxMenuFlyoutContentElement;
        new (): HTMLSdxMenuFlyoutContentElement;
    };
    interface HTMLSdxMenuFlyoutCtaElement extends Components.SdxMenuFlyoutCta, HTMLStencilElement {
    }
    var HTMLSdxMenuFlyoutCtaElement: {
        prototype: HTMLSdxMenuFlyoutCtaElement;
        new (): HTMLSdxMenuFlyoutCtaElement;
    };
    interface HTMLSdxMenuFlyoutListElement extends Components.SdxMenuFlyoutList, HTMLStencilElement {
    }
    var HTMLSdxMenuFlyoutListElement: {
        prototype: HTMLSdxMenuFlyoutListElement;
        new (): HTMLSdxMenuFlyoutListElement;
    };
    interface HTMLSdxMenuFlyoutListItemElement extends Components.SdxMenuFlyoutListItem, HTMLStencilElement {
    }
    var HTMLSdxMenuFlyoutListItemElement: {
        prototype: HTMLSdxMenuFlyoutListItemElement;
        new (): HTMLSdxMenuFlyoutListItemElement;
    };
    interface HTMLSdxMenuFlyoutToggleElement extends Components.SdxMenuFlyoutToggle, HTMLStencilElement {
    }
    var HTMLSdxMenuFlyoutToggleElement: {
        prototype: HTMLSdxMenuFlyoutToggleElement;
        new (): HTMLSdxMenuFlyoutToggleElement;
    };
    interface HTMLSdxNumericStepperElement extends Components.SdxNumericStepper, HTMLStencilElement {
    }
    var HTMLSdxNumericStepperElement: {
        prototype: HTMLSdxNumericStepperElement;
        new (): HTMLSdxNumericStepperElement;
    };
    interface HTMLSdxOptionPickerElement extends Components.SdxOptionPicker, HTMLStencilElement {
    }
    var HTMLSdxOptionPickerElement: {
        prototype: HTMLSdxOptionPickerElement;
        new (): HTMLSdxOptionPickerElement;
    };
    interface HTMLSdxPieChartElement extends Components.SdxPieChart, HTMLStencilElement {
    }
    var HTMLSdxPieChartElement: {
        prototype: HTMLSdxPieChartElement;
        new (): HTMLSdxPieChartElement;
    };
    interface HTMLSdxPriceElement extends Components.SdxPrice, HTMLStencilElement {
    }
    var HTMLSdxPriceElement: {
        prototype: HTMLSdxPriceElement;
        new (): HTMLSdxPriceElement;
    };
    interface HTMLSdxProgressFullElement extends Components.SdxProgressFull, HTMLStencilElement {
    }
    var HTMLSdxProgressFullElement: {
        prototype: HTMLSdxProgressFullElement;
        new (): HTMLSdxProgressFullElement;
    };
    interface HTMLSdxProgressFullStepElement extends Components.SdxProgressFullStep, HTMLStencilElement {
    }
    var HTMLSdxProgressFullStepElement: {
        prototype: HTMLSdxProgressFullStepElement;
        new (): HTMLSdxProgressFullStepElement;
    };
    interface HTMLSdxRibbonElement extends Components.SdxRibbon, HTMLStencilElement {
    }
    var HTMLSdxRibbonElement: {
        prototype: HTMLSdxRibbonElement;
        new (): HTMLSdxRibbonElement;
    };
    interface HTMLSdxScrollToTopElement extends Components.SdxScrollToTop, HTMLStencilElement {
    }
    var HTMLSdxScrollToTopElement: {
        prototype: HTMLSdxScrollToTopElement;
        new (): HTMLSdxScrollToTopElement;
    };
    interface HTMLSdxSearchElement extends Components.SdxSearch, HTMLStencilElement {
    }
    var HTMLSdxSearchElement: {
        prototype: HTMLSdxSearchElement;
        new (): HTMLSdxSearchElement;
    };
    interface HTMLSdxSelectElement extends Components.SdxSelect, HTMLStencilElement {
    }
    var HTMLSdxSelectElement: {
        prototype: HTMLSdxSelectElement;
        new (): HTMLSdxSelectElement;
    };
    interface HTMLSdxSelectOptgroupElement extends Components.SdxSelectOptgroup, HTMLStencilElement {
    }
    var HTMLSdxSelectOptgroupElement: {
        prototype: HTMLSdxSelectOptgroupElement;
        new (): HTMLSdxSelectOptgroupElement;
    };
    interface HTMLSdxSelectOptionElement extends Components.SdxSelectOption, HTMLStencilElement {
    }
    var HTMLSdxSelectOptionElement: {
        prototype: HTMLSdxSelectOptionElement;
        new (): HTMLSdxSelectOptionElement;
    };
    interface HTMLSdxShowMoreElement extends Components.SdxShowMore, HTMLStencilElement {
    }
    var HTMLSdxShowMoreElement: {
        prototype: HTMLSdxShowMoreElement;
        new (): HTMLSdxShowMoreElement;
    };
    interface HTMLSdxStickerCircleElement extends Components.SdxStickerCircle, HTMLStencilElement {
    }
    var HTMLSdxStickerCircleElement: {
        prototype: HTMLSdxStickerCircleElement;
        new (): HTMLSdxStickerCircleElement;
    };
    interface HTMLSdxTabsElement extends Components.SdxTabs, HTMLStencilElement {
    }
    var HTMLSdxTabsElement: {
        prototype: HTMLSdxTabsElement;
        new (): HTMLSdxTabsElement;
    };
    interface HTMLSdxTabsItemElement extends Components.SdxTabsItem, HTMLStencilElement {
    }
    var HTMLSdxTabsItemElement: {
        prototype: HTMLSdxTabsItemElement;
        new (): HTMLSdxTabsItemElement;
    };
    interface HTMLSdxTextTruncateElement extends Components.SdxTextTruncate, HTMLStencilElement {
    }
    var HTMLSdxTextTruncateElement: {
        prototype: HTMLSdxTextTruncateElement;
        new (): HTMLSdxTextTruncateElement;
    };
    interface HTMLSdxValidationMessageElement extends Components.SdxValidationMessage, HTMLStencilElement {
    }
    var HTMLSdxValidationMessageElement: {
        prototype: HTMLSdxValidationMessageElement;
        new (): HTMLSdxValidationMessageElement;
    };
    interface HTMLElementTagNameMap {
        "sdx-accordion": HTMLSdxAccordionElement;
        "sdx-accordion-arrow": HTMLSdxAccordionArrowElement;
        "sdx-accordion-item": HTMLSdxAccordionItemElement;
        "sdx-accordion-item-body": HTMLSdxAccordionItemBodyElement;
        "sdx-accordion-item-header": HTMLSdxAccordionItemHeaderElement;
        "sdx-accordion-item-section": HTMLSdxAccordionItemSectionElement;
        "sdx-animation": HTMLSdxAnimationElement;
        "sdx-arrow": HTMLSdxArrowElement;
        "sdx-button": HTMLSdxButtonElement;
        "sdx-button-group": HTMLSdxButtonGroupElement;
        "sdx-color-picker": HTMLSdxColorPickerElement;
        "sdx-dummy": HTMLSdxDummyElement;
        "sdx-expand-and-collapse": HTMLSdxExpandAndCollapseElement;
        "sdx-flip": HTMLSdxFlipElement;
        "sdx-icon": HTMLSdxIconElement;
        "sdx-input": HTMLSdxInputElement;
        "sdx-input-group": HTMLSdxInputGroupElement;
        "sdx-input-item": HTMLSdxInputItemElement;
        "sdx-itunes-autocomplete": HTMLSdxItunesAutocompleteElement;
        "sdx-loading-spinner": HTMLSdxLoadingSpinnerElement;
        "sdx-menu-flyout": HTMLSdxMenuFlyoutElement;
        "sdx-menu-flyout-content": HTMLSdxMenuFlyoutContentElement;
        "sdx-menu-flyout-cta": HTMLSdxMenuFlyoutCtaElement;
        "sdx-menu-flyout-list": HTMLSdxMenuFlyoutListElement;
        "sdx-menu-flyout-list-item": HTMLSdxMenuFlyoutListItemElement;
        "sdx-menu-flyout-toggle": HTMLSdxMenuFlyoutToggleElement;
        "sdx-numeric-stepper": HTMLSdxNumericStepperElement;
        "sdx-option-picker": HTMLSdxOptionPickerElement;
        "sdx-pie-chart": HTMLSdxPieChartElement;
        "sdx-price": HTMLSdxPriceElement;
        "sdx-progress-full": HTMLSdxProgressFullElement;
        "sdx-progress-full-step": HTMLSdxProgressFullStepElement;
        "sdx-ribbon": HTMLSdxRibbonElement;
        "sdx-scroll-to-top": HTMLSdxScrollToTopElement;
        "sdx-search": HTMLSdxSearchElement;
        "sdx-select": HTMLSdxSelectElement;
        "sdx-select-optgroup": HTMLSdxSelectOptgroupElement;
        "sdx-select-option": HTMLSdxSelectOptionElement;
        "sdx-show-more": HTMLSdxShowMoreElement;
        "sdx-sticker-circle": HTMLSdxStickerCircleElement;
        "sdx-tabs": HTMLSdxTabsElement;
        "sdx-tabs-item": HTMLSdxTabsItemElement;
        "sdx-text-truncate": HTMLSdxTextTruncateElement;
        "sdx-validation-message": HTMLSdxValidationMessageElement;
    }
}
declare namespace LocalJSX {
    interface SdxAccordion {
        /**
          * Position of the arrow in the header.
         */
        "arrowPosition"?: ArrowPosition;
        /**
          * @private
         */
        "componentStyle"?: CSSRules;
        /**
          * Allow to keep multiple accordion items opened.
         */
        "keepOpen"?: boolean;
    }
    interface SdxAccordionArrow {
        /**
          * @private
         */
        "arrowPosition"?: ArrowPosition;
        /**
          * @private
         */
        "direction"?: ArrowDirection;
        /**
          * @private
         */
        "hover"?: boolean;
    }
    interface SdxAccordionItem {
        /**
          * If the accordion item is initially open.
         */
        "open"?: boolean;
    }
    interface SdxAccordionItemBody {
        /**
          * @private
         */
        "arrowPosition"?: ArrowPosition;
        /**
          * @private
         */
        "componentStyle"?: CSSRules;
    }
    interface SdxAccordionItemHeader {
        /**
          * @private
         */
        "arrowPosition"?: ArrowPosition;
        /**
          * @private
         */
        "buttonStyle"?: CSSRules;
        /**
          * @private
         */
        "expand"?: boolean;
        /**
          * Triggers toggle information in accordion
         */
        "toggle"?: () => void;
    }
    interface SdxAccordionItemSection {
    }
    interface SdxAnimation {
        /**
          * Callback that will fire when the animation starts.
         */
        "animationBeginCallback"?: (() => void);
        /**
          * The animation to play.
         */
        "animationName"?: AnimationName;
    }
    interface SdxArrow {
        /**
          * Callback that will fire when the animation starts.
         */
        "animationBeginCallback"?: (() => void);
        /**
          * Which side it looks towards.
         */
        "direction"?: "down" | "up" | "left" | "right";
        /**
          * Hide the arrow (animated).
         */
        "hideArrow"?: boolean;
        /**
          * Hide the background.
         */
        "hideBackground"?: boolean;
    }
    interface SdxButton {
        /**
          * Value for aria-expanded that will be applied to the button element. Used for buttons that trigger expanding/collapsing such as an accordion, dropdown menu or tooltip.
         */
        "ariaExpandedOnButton"?: boolean;
        /**
          * Background theme. Use "dark" to make button colorless, whenever it is used on a colored or dark background (single color or image).
         */
        "background"?: BackgroundTheme;
        /**
          * Button disabled.
         */
        "disabled"?: boolean;
        /**
          * "href" when used as a link looking like a button.
         */
        "href"?: string;
        /**
          * Which icon to display.
         */
        "iconName"?: string;
        /**
          * Size of the displayed icon. Can only be modified when theme="transparent". Font-size will be adjusted automatically.
         */
        "iconSize"?: Size;
        /**
          * Button text.
         */
        "label"?: string;
        /**
          * Description text read by the screen reader. Will be appended to the button content.
         */
        "srHint"?: string;
        /**
          * "target" when used as a link looking like a button.
         */
        "target"?: string;
        /**
          * Button theme. For further information about the different themes, see designers' section: https://sdx.swisscom.ch/components_-_buttons.html#design
         */
        "theme"?: ButtonTheme;
        /**
          * Button type.
         */
        "type"?: ButtonType;
        /**
          * @private only used for icon-buttons within input fields such as numeric stepper, search, select, datepicker etc.
         */
        "valid"?: boolean;
    }
    interface SdxButtonGroup {
        /**
          * Defines how buttons are aligned, sized and distributed.
         */
        "layout"?: ButtonGroupLayout;
    }
    interface SdxColorPicker {
        /**
          * Callback when the checking an option.
         */
        "changeCallback"?: ((selection: string[]) => void) | string | undefined;
        /**
          * List of selectable colors.
         */
        "colors"?: Color[] | string;
        /**
          * Enable multi select.
         */
        "multiple"?: boolean;
    }
    interface SdxDummy {
    }
    interface SdxExpandAndCollapse {
        /**
          * Label that shows when the component is expanded and ready to be collapsed.
         */
        "collapseLabel"?: string;
        /**
          * Label that shows when the component is collapsed and ready to be expanded.
         */
        "expandLabel"?: string;
    }
    interface SdxFlip {
        /**
          * Mirror the content across one or both axes (or none at all).
         */
        "direction"?: FlipDirection;
    }
    interface SdxIcon {
        /**
          * SDX predefined color class.
         */
        "colorClass"?: string;
        /**
          * Mirror the icon.
         */
        "flip"?: FlipDirection;
        /**
          * Hide the icon (animated).
         */
        "hidden"?: boolean;
        /**
          * Name of the SDX icon (e.g. "icon-clear-circle").
         */
        "iconName"?: string;
        /**
          * The dimension of the icon.
         */
        "size"?: Size;
        /**
          * Description text read by the screen reader.
         */
        "srHint"?: string;
    }
    interface SdxInput {
        /**
          * Specifies the input fields native autocomplete behavior on modern browsers (e.g. "off", "username" or "new-password").
         */
        "autocomplete"?: string;
        /**
          * Callback that will fire when the input loses focus.
         */
        "blurCallback"?: (() => void) | string;
        /**
          * Callback that will fire when the value has changed, regardless of method (keyboard or programmatical).
         */
        "changeCallback"?: ((value: string) => void) | string;
        /**
          * Disabled and not focussable using tab.
         */
        "disabled"?: boolean;
        /**
          * @private Renders a div that looks exactly like an input field. Overflowing content will have an ellipsis. Only implemented for `type="text"`.
         */
        "editable"?: boolean;
        /**
          * Datepicker settings. When <code>type="date"</code>, flatpickr is used and can be configured via this attribute. Examples: <code>{ locale: "fr" }</code>, <code>{ minDate: "today" }</code> or <code>{ "altInput": true, "altFormat": "l j. F, Y" }</code>. See available options: https://sdx.swisscom.com/components_-_picker_(date).html
         */
        "flatpickrOptions"?: any;
        /**
          * Callback that will fire when the input gets focus.
         */
        "focusCallback"?: (() => void) | string;
        /**
          * Callback that will fire on hitting enter.
         */
        "hitEnterCallback"?: (() => void) | string;
        /**
          * Callback that will fire when the value changes using the keyboard.
         */
        "inputCallback"?: ((value: string) => void) | string;
        /**
          * @private CSS styles applied to the input element.
         */
        "inputStyle"?: {
            [key: string]: string;
        };
        /**
          * Callback that will fire when the a key is pressed down.
         */
        "keyDownCallback"?: ((e: Event) => void) | string;
        /**
          * Text that will be written on the top.
         */
        "label"?: string;
        /**
          * For input type="number", maximum valid input value.
         */
        "max"?: number;
        /**
          * Allowed number of characters.
         */
        "maxlength"?: number;
        /**
          * For input type="number", minimum valid input value.
         */
        "min"?: number;
        /**
          * Name parameter (useful when the item is embedded in a traditional HTML form submit).
         */
        "name"?: string;
        /**
          * Default text that will be shown unless there's a value.
         */
        "placeholder"?: string;
        /**
          * Disabled, but focussable using tab.
         */
        "readonly"?: boolean;
        /**
          * Marks the component as required (please note that this itself does not handle validation &mdash; use the "valid" and "validation-message" for that).
         */
        "required"?: boolean;
        /**
          * Marks the text within the input on focus.
         */
        "selectTextOnFocus"?: boolean;
        /**
          * Text for the screen reader labelling the input field.
         */
        "srHint"?: string;
        /**
          * For input type="number", step size.
         */
        "step"?: number;
        /**
          * Default input field type (e.g. "search", "password", "date", etc.). When set to "date", flatpickr will take over. Caution: flatpickr does not fulfill the accessibility requirements of SDX, yet (but we're on it...).
         */
        "type"?: InputType;
        /**
          * Set this to false to declare the component as invalid (and use the "validation-message" attribute to explain why). It can also be set to true, but this should only be done in rare cases (e.g. when checking a user name for availabilty using server-side validation).
         */
        "valid"?: boolean;
        /**
          * Text that explains the validation status to the user.
         */
        "validationMessage"?: string;
        /**
          * Can be used for both reading and writing the value.
         */
        "value"?: string;
    }
    interface SdxInputGroup {
        /**
          * Callback when the checking an option.
         */
        "changeCallback"?: ((selection: any[]) => void) | string | undefined;
        /**
          * Display all input items in a row (for maximum two items &mdash; more items should be embedded in a grid).
         */
        "inline"?: boolean;
        /**
          * Label of the input group.
         */
        "label"?: string;
        /**
          * Name parameter (useful when the item is embedded in a traditional HTML form submit).
         */
        "name"?: string;
        /**
          * Marks the component as required (please note that this itself does not handle validation &mdash; use the "valid" and "validation-message" for that).
         */
        "required"?: boolean;
        /**
          * Styling theme for the input items within this group.
         */
        "theme"?: Theme;
        /**
          * The form input variant of the item.
         */
        "type"?: InputItemType;
        /**
          * Set this to false to declare the component as invalid (and use the "validation-message" attribute to explain why).
         */
        "valid"?: boolean;
        /**
          * Text that explains the validation status to the user.
         */
        "validationMessage"?: string;
        /**
          * The value(s) of the currently checked items(s). Please note that this is always an array, even when type="checkbox", for both getting and setting the value <code>(e.g. myGroup.value = [ "value1" ])</code>). Note that when being used for setting the initial value, the "checked" attribute on the <code>&lt;sdx-input-item /&gt;</code> has the higher priority.
         */
        "value"?: any[];
    }
    interface SdxInputItem {
        /**
          * Callback whenever the user checks/unchecks the component.
         */
        "changeCallback"?: ((checked: boolean) => void) | string;
        /**
          * Whether the item is turned on or off.
         */
        "checked"?: boolean;
        /**
          * Make sure that the input item does not receive focus. Use this when the input item is used within a component that already handles focus (e.g. sdx-select-option in sdx-select with multiselect).
         */
        "disableFocus"?: boolean;
        /**
          * Not selectable.
         */
        "disabled"?: boolean;
        /**
          * @private Hide the checkbox or radio checked indicator icon.
         */
        "hideCheckedIcon"?: boolean;
        /**
          * Icon name of the icon inside the container variation.
         */
        "iconName"?: string;
        /**
          * Icon size of the icon inside the container variation.
         */
        "iconSize"?: Size;
        /**
          * @private
         */
        "labelStyle"?: CSSRules;
        /**
          * Name parameter (useful when the item is embedded in a traditional HTML form submit).
         */
        "name"?: string;
        /**
          * Marks the component as required (please note that this itself does not handle validation &mdash; use the "valid" and "validation-message" for that).
         */
        "required"?: boolean;
        /**
          * The form input type of the item (radio or checkbox).
         */
        "type"?: InputItemType;
        /**
          * Set this to false to declare the component as invalid (and use the "validation-message" attribute to explain why).
         */
        "valid"?: boolean;
        /**
          * Text that explains the validation status to the user.
         */
        "validationMessage"?: string;
        /**
          * The current value.
         */
        "value"?: any;
    }
    interface SdxItunesAutocomplete {
    }
    interface SdxLoadingSpinner {
        /**
          * Dimension of the spinner.
         */
        "size"?: "small" | "large";
        /**
          * Description text read by the screen reader.
         */
        "srHint"?: string;
    }
    interface SdxMenuFlyout {
        /**
          * Close if the user clicks on the flyout.
         */
        "closeOnClick"?: boolean;
        /**
          * In which direction the flyout opens.
         */
        "direction"?: Direction;
        /**
          * Callback that will fire after the flyouts display status has changed.
         */
        "displayChangeCallback"?: ((display: Display) => void) | string;
    }
    interface SdxMenuFlyoutContent {
    }
    interface SdxMenuFlyoutCta {
        /**
          * Width of the flyout. If none is set, the Flyout grows dynamically (up to a certain point) based on the content.
         */
        "size"?: "small" | "medium" | "large" | "auto";
    }
    interface SdxMenuFlyoutList {
    }
    interface SdxMenuFlyoutListItem {
        /**
          * Whether the item is disabled.
         */
        "disabled"?: boolean;
        /**
          * The URL this item should link to (if itâ€™s a regular link not handled by JS).
         */
        "href"?: string;
        /**
          * Optional language of the page the URL points to
         */
        "hreflang"?: string;
        /**
          * If the item is not selectable, it is neither highlighted nor has it cursor: pointer.
         */
        "selectable"?: boolean;
    }
    interface SdxMenuFlyoutToggle {
    }
    interface SdxNumericStepper {
        /**
          * Callback that will fire on change.
         */
        "changeCallback"?: ((value: string) => void) | string;
        /**
          * Disabled and not focusable using tab.
         */
        "disabled"?: boolean;
        /**
          * Text that will be written on the top of the numeric stepper. Make sure to include the maximum possible value here for the user.
         */
        "label"?: string;
        /**
          * Maximum value. Cannot be set greater than 999.
         */
        "max"?: number;
        /**
          * Minimum value. Cannot be negative.
         */
        "min"?: number;
        /**
          * Text for the screen reader describing the numeric stepper.
         */
        "srHint"?: string;
        /**
          * Step size.
         */
        "step"?: number;
        /**
          * Set this to false to declare the component as invalid (and use the "validation-message" attribute to explain why). It can also be set to true, but this should only be done in rare cases (e.g. when checking a user name for availabilty using server-side validation).
         */
        "valid"?: boolean;
        /**
          * Text that explains the validation status to the user.
         */
        "validationMessage"?: string;
        /**
          * Initial value. Must be between 0 and 999 including.
         */
        "value"?: number | undefined;
    }
    interface SdxOptionPicker {
        /**
          * Callback when the checking an option.
         */
        "changeCallback"?: ((selection: any[]) => void) | string | undefined;
        /**
          * Enable multi select.
         */
        "multiple"?: boolean;
        /**
          * List of selectable options.
         */
        "options"?: Option[] | string;
    }
    interface SdxPieChart {
        /**
          * Background color scheme.
         */
        "backgroundTheme"?: BackgroundTheme;
        /**
          * The values to display.
         */
        "data"?: PieChartDataPoint[] | string;
        /**
          * Description text of what is displayed (e.g. "Storage" or "Available"). This does not appear in the "small" version.
         */
        "description"?: string;
        /**
          * Where to render the labels.
         */
        "legendPosition"?: "bottom" | "right";
        /**
          * Dimension of the chart.
         */
        "size"?: "small" | "medium";
        /**
          * Text that contains the relevant information (e.g. "100 %"). It will be displayed in the center of the chart.
         */
        "value"?: string;
    }
    interface SdxPrice {
        /**
          * The amount to be paid.
         */
        "amount"?: number;
        /**
          * Time period, for example "/mo.".
         */
        "period"?: string;
        /**
          * The font size.
         */
        "size"?: Size;
        /**
          * Description text read by the screen reader.
         */
        "srHint"?: string;
    }
    interface SdxProgressFull {
        /**
          * @private Disable animations for testing.
         */
        "animated"?: boolean;
        /**
          * Current active step of the progress bar.
         */
        "step"?: number;
        /**
          * Triggered when the active step was changed.
         */
        "stepChangeCallback"?: ((activeStep: number, previousActiveStep?: number) => void) | string;
        /**
          * Label used next to total amount of steps when not all steps are being displayed.
         */
        "stepsLabel"?: string;
    }
    interface SdxProgressFullStep {
        /**
          * @private
         */
        "position"?: StepPosition;
        /**
          * @private
         */
        "status"?: Status;
        /**
          * Triggered when a user clicks on the button or description of a completed step.
         */
        "stepClickCallback"?: (() => void) | string;
        /**
          * @private
         */
        "value"?: number;
    }
    interface SdxRibbon {
        /**
          * Look.
         */
        "design"?: Design;
        /**
          * Text content.
         */
        "label"?: string;
        /**
          * Location.
         */
        "position"?: Position;
        /**
          * Dimension.
         */
        "size"?: Size;
    }
    interface SdxScrollToTop {
        /**
          * @private
         */
        "demo"?: boolean;
        /**
          * @private
         */
        "position"?: Position;
    }
    interface SdxSearch {
        /**
          * Callback that will fire when the value has changed, regardless of method (keyboard or programmatical).
         */
        "changeCallback"?: ((value: string) => void) | string;
        /**
          * Default text that will disappear on type.
         */
        "placeholder"?: string;
        /**
          * Callback that will fire on hitting enter or on clicking the button.
         */
        "searchSubmitCallback"?: ((value: string) => void) | string;
        /**
          * Text for the screen reader labelling the search input field.
         */
        "srHint"?: string;
        /**
          * Button text for the screen reader to read in place of the search icon.
         */
        "srHintForButton"?: string;
        /**
          * Can be used for both reading and writing the value.
         */
        "value"?: string;
        /**
          * @private Deprecated, use "changeCallback" Callback that will fire when the value has changed, regardless of method (keyboard or programmatical). Same as changeCallback.
         */
        "valueChangeCallback"?: ((value: string) => void) | string;
    }
    interface SdxSelect {
        /**
          * @private Disable animations for testing.
         */
        "animated"?: boolean;
        /**
          * Background color scheme.
         */
        "backgroundTheme"?: BackgroundTheme;
        /**
          * Callback that will fire when the input loses focus. Used when "keyboard-behavior" is "filter" or "autocomplete".
         */
        "blurCallback"?: (() => void) | string;
        /**
          * Callback when user selects an option (or types something while in "autocomplete" mode).
         */
        "changeCallback"?: ((selection: any[]) => void) | string;
        /**
          * Disables the sdx-select.
         */
        "disabled"?: boolean;
        /**
          * Function that decides whether an option element matches a filter by returning true or false. Defaults to a function that performs a simple string match test on the option elements textContent property. Used when "keyboard-behavior" is "filter" or "autocomplete".
         */
        "filterFunction"?: ((optionEl: HTMLSdxSelectOptionElement, keyword: string) => boolean) | string;
        /**
          * @private Deprecated, use "keyboard-behavior" Filter the options of the sdx-select by typing. Shortcut for keyboard-behavior="filter"
         */
        "filterable"?: boolean;
        /**
          * Callback that will fire when the input gets focus. Used when "keyboard-behavior" is "filter" or "autocomplete".
         */
        "focusCallback"?: (() => void) | string;
        /**
          * How the component should behave when the user types something on the keyboard. "focus" jumps to and focuses the option starting with the typed character. "filter" lists only options (and optgroups) that match the entered keyword. "autocomplete" is similar to "filter", but makes the component behave more like an input field, e.g. the "value" reflects the content of the filter and there is no thumb to open or close.
         */
        "keyboardBehavior"?: KeyboardBehavior;
        /**
          * Will be written on the top of the sdx-select.
         */
        "label"?: string;
        /**
          * Shows a loading spinner and disables the sdx-select.
         */
        "loading"?: boolean;
        /**
          * Maximum dropdown height (e.g. "300px"), supported units are "px" and "vh". If no unit is provided, "px" will be used.
         */
        "maxHeight"?: string | number;
        /**
          * Enable multi select.
         */
        "multiple"?: boolean;
        /**
          * Name parameter (useful when the item is embedded in a traditional HTML form submit).
         */
        "name"?: string;
        /**
          * Label for "no matches found".
         */
        "noMatchesFoundLabel"?: string;
        /**
          * Text to be displayed when nothing is selected.
         */
        "placeholder"?: string;
        /**
          * Marks the component as required (please note that this itself does not handle validation &mdash; use the "valid" and "validation-message" for that).
         */
        "required"?: boolean;
        /**
          * Callback when user selects an option (and the select is *not* in "autocomplete" mode).
         */
        "selectCallback"?: ((selection: any[]) => void) | string;
        /**
          * Description text read by the screen reader.
         */
        "srHint"?: string;
        /**
          * Set this to false to declare the component as invalid (note that this only works with when the "validation-message" attribute is set - and vice versa).
         */
        "valid"?: boolean;
        /**
          * Text that explains the validation status to the user.
         */
        "validationMessage"?: string;
        /**
          * The value(s) of the currently selected option(s). Please note that this is always an array, even without the "multiple" attribute, for both getting and setting the value <code>(e.g. mySelect.value = [ "value1" ])</code>). Note that when being used for setting the initial value, the "selected" attribute on the <code>&lt;sdx-select-option /&gt;</code> has the higher priority.
         */
        "value"?: any[];
    }
    interface SdxSelectOptgroup {
        /**
          * Label of the group to be displayed.
         */
        "name"?: string;
    }
    interface SdxSelectOption {
        /**
          * Not selectable (event propagation will be stopped).
         */
        "disabled"?: boolean;
        /**
          * @private Whether this option is the placeholder element.
         */
        "placeholder"?: boolean;
        /**
          * Whether this option is initially selected.
         */
        "selected"?: boolean;
        /**
          * Value of the option that will be returned in the selection.
         */
        "value"?: any;
    }
    interface SdxShowMore {
        /**
          * Button theme.
         */
        "buttonTheme"?: ButtonTheme;
        /**
          * Label for "from".
         */
        "fromLabel"?: string;
        /**
          * How many items to add by each turn.
         */
        "incrementBy"?: number;
        /**
          * Triggered when the number of displayed items has incremented.
         */
        "incrementCallback"?: ((count: number) => void) | string;
        /**
          * Number of items to start from.
         */
        "initialItems"?: number;
        /**
          * Label for "more".
         */
        "moreLabel"?: string;
        /**
          * Number of all items in total.
         */
        "totalItems"?: number;
    }
    interface SdxStickerCircle {
        /**
          * SDX predefined color class (or transparent) for the sticker background.
         */
        "bgColorClass"?: string;
        /**
          * Offset from the bottom edge, in % of the content's height.
         */
        "bottom"?: number;
        /**
          * SDX predefined color class for the text and border.
         */
        "colorClass"?: string;
        /**
          * The content width at which the sticker should be normal size (nonscaled).
         */
        "contentWidth"?: number;
        /**
          * Offset from the left edge, in % of the content's width.
         */
        "left"?: number;
        /**
          * Offset from the right edge, in % of the content's width.
         */
        "right"?: number;
        /**
          * The size (diameter) in px.
         */
        "size"?: number;
        /**
          * Description text read by the screen reader.
         */
        "srHint"?: string;
        /**
          * Offset from the top edge, in % of the content's height.
         */
        "top"?: number;
    }
    interface SdxTabs {
        /**
          * Callback that will fire when the active tab has changed. Provides the active tab DOM node.
         */
        "changeCallback"?: ((activeTab: Node) => void) | string;
    }
    interface SdxTabsItem {
        /**
          * The tab is not selectable.
         */
        "disabled"?: boolean;
        /**
          * Which icon to display.
         */
        "iconName"?: string;
        /**
          * Title of the tab.
         */
        "label"?: string;
        /**
          * The tab is active.
         */
        "selected"?: boolean;
    }
    interface SdxTextTruncate {
    }
    interface SdxValidationMessage {
        "valid"?: boolean;
        "validationMessage"?: string;
    }
    interface IntrinsicElements {
        "sdx-accordion": SdxAccordion;
        "sdx-accordion-arrow": SdxAccordionArrow;
        "sdx-accordion-item": SdxAccordionItem;
        "sdx-accordion-item-body": SdxAccordionItemBody;
        "sdx-accordion-item-header": SdxAccordionItemHeader;
        "sdx-accordion-item-section": SdxAccordionItemSection;
        "sdx-animation": SdxAnimation;
        "sdx-arrow": SdxArrow;
        "sdx-button": SdxButton;
        "sdx-button-group": SdxButtonGroup;
        "sdx-color-picker": SdxColorPicker;
        "sdx-dummy": SdxDummy;
        "sdx-expand-and-collapse": SdxExpandAndCollapse;
        "sdx-flip": SdxFlip;
        "sdx-icon": SdxIcon;
        "sdx-input": SdxInput;
        "sdx-input-group": SdxInputGroup;
        "sdx-input-item": SdxInputItem;
        "sdx-itunes-autocomplete": SdxItunesAutocomplete;
        "sdx-loading-spinner": SdxLoadingSpinner;
        "sdx-menu-flyout": SdxMenuFlyout;
        "sdx-menu-flyout-content": SdxMenuFlyoutContent;
        "sdx-menu-flyout-cta": SdxMenuFlyoutCta;
        "sdx-menu-flyout-list": SdxMenuFlyoutList;
        "sdx-menu-flyout-list-item": SdxMenuFlyoutListItem;
        "sdx-menu-flyout-toggle": SdxMenuFlyoutToggle;
        "sdx-numeric-stepper": SdxNumericStepper;
        "sdx-option-picker": SdxOptionPicker;
        "sdx-pie-chart": SdxPieChart;
        "sdx-price": SdxPrice;
        "sdx-progress-full": SdxProgressFull;
        "sdx-progress-full-step": SdxProgressFullStep;
        "sdx-ribbon": SdxRibbon;
        "sdx-scroll-to-top": SdxScrollToTop;
        "sdx-search": SdxSearch;
        "sdx-select": SdxSelect;
        "sdx-select-optgroup": SdxSelectOptgroup;
        "sdx-select-option": SdxSelectOption;
        "sdx-show-more": SdxShowMore;
        "sdx-sticker-circle": SdxStickerCircle;
        "sdx-tabs": SdxTabs;
        "sdx-tabs-item": SdxTabsItem;
        "sdx-text-truncate": SdxTextTruncate;
        "sdx-validation-message": SdxValidationMessage;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "sdx-accordion": LocalJSX.SdxAccordion & JSXBase.HTMLAttributes<HTMLSdxAccordionElement>;
            "sdx-accordion-arrow": LocalJSX.SdxAccordionArrow & JSXBase.HTMLAttributes<HTMLSdxAccordionArrowElement>;
            "sdx-accordion-item": LocalJSX.SdxAccordionItem & JSXBase.HTMLAttributes<HTMLSdxAccordionItemElement>;
            "sdx-accordion-item-body": LocalJSX.SdxAccordionItemBody & JSXBase.HTMLAttributes<HTMLSdxAccordionItemBodyElement>;
            "sdx-accordion-item-header": LocalJSX.SdxAccordionItemHeader & JSXBase.HTMLAttributes<HTMLSdxAccordionItemHeaderElement>;
            "sdx-accordion-item-section": LocalJSX.SdxAccordionItemSection & JSXBase.HTMLAttributes<HTMLSdxAccordionItemSectionElement>;
            "sdx-animation": LocalJSX.SdxAnimation & JSXBase.HTMLAttributes<HTMLSdxAnimationElement>;
            "sdx-arrow": LocalJSX.SdxArrow & JSXBase.HTMLAttributes<HTMLSdxArrowElement>;
            "sdx-button": LocalJSX.SdxButton & JSXBase.HTMLAttributes<HTMLSdxButtonElement>;
            "sdx-button-group": LocalJSX.SdxButtonGroup & JSXBase.HTMLAttributes<HTMLSdxButtonGroupElement>;
            "sdx-color-picker": LocalJSX.SdxColorPicker & JSXBase.HTMLAttributes<HTMLSdxColorPickerElement>;
            "sdx-dummy": LocalJSX.SdxDummy & JSXBase.HTMLAttributes<HTMLSdxDummyElement>;
            "sdx-expand-and-collapse": LocalJSX.SdxExpandAndCollapse & JSXBase.HTMLAttributes<HTMLSdxExpandAndCollapseElement>;
            "sdx-flip": LocalJSX.SdxFlip & JSXBase.HTMLAttributes<HTMLSdxFlipElement>;
            "sdx-icon": LocalJSX.SdxIcon & JSXBase.HTMLAttributes<HTMLSdxIconElement>;
            "sdx-input": LocalJSX.SdxInput & JSXBase.HTMLAttributes<HTMLSdxInputElement>;
            "sdx-input-group": LocalJSX.SdxInputGroup & JSXBase.HTMLAttributes<HTMLSdxInputGroupElement>;
            "sdx-input-item": LocalJSX.SdxInputItem & JSXBase.HTMLAttributes<HTMLSdxInputItemElement>;
            "sdx-itunes-autocomplete": LocalJSX.SdxItunesAutocomplete & JSXBase.HTMLAttributes<HTMLSdxItunesAutocompleteElement>;
            "sdx-loading-spinner": LocalJSX.SdxLoadingSpinner & JSXBase.HTMLAttributes<HTMLSdxLoadingSpinnerElement>;
            "sdx-menu-flyout": LocalJSX.SdxMenuFlyout & JSXBase.HTMLAttributes<HTMLSdxMenuFlyoutElement>;
            "sdx-menu-flyout-content": LocalJSX.SdxMenuFlyoutContent & JSXBase.HTMLAttributes<HTMLSdxMenuFlyoutContentElement>;
            "sdx-menu-flyout-cta": LocalJSX.SdxMenuFlyoutCta & JSXBase.HTMLAttributes<HTMLSdxMenuFlyoutCtaElement>;
            "sdx-menu-flyout-list": LocalJSX.SdxMenuFlyoutList & JSXBase.HTMLAttributes<HTMLSdxMenuFlyoutListElement>;
            "sdx-menu-flyout-list-item": LocalJSX.SdxMenuFlyoutListItem & JSXBase.HTMLAttributes<HTMLSdxMenuFlyoutListItemElement>;
            "sdx-menu-flyout-toggle": LocalJSX.SdxMenuFlyoutToggle & JSXBase.HTMLAttributes<HTMLSdxMenuFlyoutToggleElement>;
            "sdx-numeric-stepper": LocalJSX.SdxNumericStepper & JSXBase.HTMLAttributes<HTMLSdxNumericStepperElement>;
            "sdx-option-picker": LocalJSX.SdxOptionPicker & JSXBase.HTMLAttributes<HTMLSdxOptionPickerElement>;
            "sdx-pie-chart": LocalJSX.SdxPieChart & JSXBase.HTMLAttributes<HTMLSdxPieChartElement>;
            "sdx-price": LocalJSX.SdxPrice & JSXBase.HTMLAttributes<HTMLSdxPriceElement>;
            "sdx-progress-full": LocalJSX.SdxProgressFull & JSXBase.HTMLAttributes<HTMLSdxProgressFullElement>;
            "sdx-progress-full-step": LocalJSX.SdxProgressFullStep & JSXBase.HTMLAttributes<HTMLSdxProgressFullStepElement>;
            "sdx-ribbon": LocalJSX.SdxRibbon & JSXBase.HTMLAttributes<HTMLSdxRibbonElement>;
            "sdx-scroll-to-top": LocalJSX.SdxScrollToTop & JSXBase.HTMLAttributes<HTMLSdxScrollToTopElement>;
            "sdx-search": LocalJSX.SdxSearch & JSXBase.HTMLAttributes<HTMLSdxSearchElement>;
            "sdx-select": LocalJSX.SdxSelect & JSXBase.HTMLAttributes<HTMLSdxSelectElement>;
            "sdx-select-optgroup": LocalJSX.SdxSelectOptgroup & JSXBase.HTMLAttributes<HTMLSdxSelectOptgroupElement>;
            "sdx-select-option": LocalJSX.SdxSelectOption & JSXBase.HTMLAttributes<HTMLSdxSelectOptionElement>;
            "sdx-show-more": LocalJSX.SdxShowMore & JSXBase.HTMLAttributes<HTMLSdxShowMoreElement>;
            "sdx-sticker-circle": LocalJSX.SdxStickerCircle & JSXBase.HTMLAttributes<HTMLSdxStickerCircleElement>;
            "sdx-tabs": LocalJSX.SdxTabs & JSXBase.HTMLAttributes<HTMLSdxTabsElement>;
            "sdx-tabs-item": LocalJSX.SdxTabsItem & JSXBase.HTMLAttributes<HTMLSdxTabsItemElement>;
            "sdx-text-truncate": LocalJSX.SdxTextTruncate & JSXBase.HTMLAttributes<HTMLSdxTextTruncateElement>;
            "sdx-validation-message": LocalJSX.SdxValidationMessage & JSXBase.HTMLAttributes<HTMLSdxValidationMessageElement>;
        }
    }
}
export * from "../../../es6/sdx"